---
title: 查詢建構器 (Query Builder)
description: Laravel Query Builder 提供方便流暢的介面來建立和執行資料庫查詢
---

- [簡介](#introduction)
- [執行資料庫查詢](#running-database-queries)
  - [分塊結果](#chunking-results)
  - [延遲串流結果](#streaming-results-lazily)
  - [聚合函數](#aggregates)
- [Select 陳述式](#select-statements)
- [Raw 表達式](#raw-expressions)
- [Joins](#joins)
- [Unions](#unions)
- [基本 Where 子句](#basic-where-clauses)
  - [Where 子句](#where-clauses)
  - [Or Where 子句](#or-where-clauses)
  - [Where Not 子句](#where-not-clauses)
  - [Where Any / All / None 子句](#where-any-all-none-clauses)
  - [JSON Where 子句](#json-where-clauses)
  - [其他 Where 子句](#additional-where-clauses)
  - [邏輯分組](#logical-grouping)
- [進階 Where 子句](#advanced-where-clauses)
  - [Where Exists 子句](#where-exists-clauses)
  - [子查詢 Where 子句](#subquery-where-clauses)
  - [全文 Where 子句](#full-text-where-clauses)
- [排序、分組、限制和偏移](#ordering-grouping-limit-and-offset)
  - [排序](#ordering)
  - [分組](#grouping)
  - [限制和偏移](#limit-and-offset)
- [條件子句](#conditional-clauses)
- [Insert 陳述式](#insert-statements)
  - [Upserts](#upserts)
- [Update 陳述式](#update-statements)
  - [更新 JSON 欄位](#updating-json-columns)
  - [遞增和遞減](#increment-and-decrement)
- [Delete 陳述式](#delete-statements)
- [悲觀鎖定](#pessimistic-locking)
- [可重複使用的查詢元件](#reusable-query-components)
- [除錯](#debugging)

<a name="introduction"></a>
## 簡介 (Introduction)

Laravel 的資料庫查詢建構器提供了一個方便、流暢的介面來建立和執行資料庫查詢。它可以用於執行應用程式中大多數的資料庫操作，並且與 Laravel 支援的所有資料庫系統完美配合。

Laravel 查詢建構器使用 PDO 參數綁定來保護您的應用程式免受 SQL 注入攻擊。作為查詢綁定傳遞給查詢建構器的字串無需清理或消毒。

> [!WARNING]
> PDO 不支援綁定欄位名稱。因此，您絕不應該允許使用者輸入來決定查詢所參考的欄位名稱，包括「order by」欄位。

<a name="running-database-queries"></a>
## 執行資料庫查詢 (Running Database Queries)

<a name="retrieving-all-rows-from-a-table"></a>
#### 從資料表取得所有列 (Retrieving All Rows From A Table)

您可以使用 `DB` facade 提供的 `table` 方法來開始查詢。`table` 方法為給定的資料表回傳一個流暢的查詢建構器實例，允許您在查詢上串接更多的約束條件，然後最後使用 `get` 方法取得查詢結果：

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Support\Facades\DB;
use Illuminate\View\View;

class UserController extends Controller
{
    /**
     * 顯示所有應用程式使用者的清單。
     */
    public function index(): View
    {
        $users = DB::table('users')->get();

        return view('user.index', ['users' => $users]);
    }
}
```

`get` 方法回傳一個包含查詢結果的 `Illuminate\Support\Collection` 實例，其中每個結果都是 PHP `stdClass` 物件的實例。您可以透過存取物件的屬性來存取每個欄位的值：

```php
use Illuminate\Support\Facades\DB;

$users = DB::table('users')->get();

foreach ($users as $user) {
    echo $user->name;
}
```

> [!NOTE]
> Laravel collections 提供了各種極其強大的方法來映射和減少資料。有關 Laravel collections 的更多資訊，請查看 [collection 文件](/docs/collections)。

<a name="retrieving-a-single-row-column-from-a-table"></a>
#### 從資料表取得單一列 / 欄位 (Retrieving A Single Row Column From A Table)

如果您只需要從資料庫資料表取得單一列，您可以使用 `DB` facade 的 `first` 方法。此方法將回傳單一 `stdClass` 物件：

```php
$user = DB::table('users')->where('name', 'John')->first();

return $user->email;
```

如果您想從資料庫資料表取得單一列，但如果找不到匹配的列則拋出 `Illuminate\Database\RecordNotFoundException`，您可以使用 `firstOrFail` 方法。如果 `RecordNotFoundException` 沒有被捕獲，將自動向客戶端發送 404 HTTP 回應：

```php
$user = DB::table('users')->where('name', 'John')->firstOrFail();
```

如果您不需要整列，可以使用 `value` 方法從記錄中提取單一值。此方法將直接回傳欄位的值：

```php
$email = DB::table('users')->where('name', 'John')->value('email');
```

若要透過 `id` 欄位值取得單一列，請使用 `find` 方法：

```php
$user = DB::table('users')->find(3);
```

<a name="retrieving-a-list-of-column-values"></a>
#### 取得欄位值清單 (Retrieving A List Of Column Values)

如果您想取得包含單一欄位值的 `Illuminate\Support\Collection` 實例，您可以使用 `pluck` 方法。在此範例中，我們將取得使用者標題的 collection：

```php
use Illuminate\Support\Facades\DB;

$titles = DB::table('users')->pluck('title');

foreach ($titles as $title) {
    echo $title;
}
```

您可以透過提供第二個引數給 `pluck` 方法來指定結果 collection 應使用的鍵：

```php
$titles = DB::table('users')->pluck('title', 'name');

foreach ($titles as $name => $title) {
    echo $title;
}
```

<a name="chunking-results"></a>
### 分塊結果 (Chunking Results)

如果您需要處理數千筆資料庫記錄，請考慮使用 `DB` facade 提供的 `chunk` 方法。此方法一次取得一小塊結果，並將每個塊傳遞給閉包進行處理。例如，讓我們以每次 100 筆記錄的方式取得整個 `users` 資料表：

```php
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;

DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
    foreach ($users as $user) {
        // ...
    }
});
```

您可以透過從閉包回傳 `false` 來停止處理更多的塊：

```php
DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
    // 處理記錄...

    return false;
});
```

如果您在分塊結果時更新資料庫記錄，您的分塊結果可能會以意想不到的方式改變。如果您計劃在分塊時更新取得的記錄，最好改用 `chunkById` 方法。此方法將根據記錄的主鍵自動分頁結果：

```php
DB::table('users')->where('active', false)
    ->chunkById(100, function (Collection $users) {
        foreach ($users as $user) {
            DB::table('users')
                ->where('id', $user->id)
                ->update(['active' => true]);
        }
    });
```

由於 `chunkById` 和 `lazyById` 方法會向正在執行的查詢新增它們自己的「where」條件，您通常應該在閉包中 [邏輯分組](#logical-grouping) 您自己的條件：

```php
DB::table('users')->where(function ($query) {
    $query->where('credits', 1)->orWhere('credits', 2);
})->chunkById(100, function (Collection $users) {
    foreach ($users as $user) {
        DB::table('users')
            ->where('id', $user->id)
            ->update(['credits' => 3]);
    }
});
```

> [!WARNING]
> 在分塊回呼中更新或刪除記錄時，對主鍵或外鍵的任何更改都可能影響分塊查詢。這可能導致記錄未包含在分塊結果中。

<a name="streaming-results-lazily"></a>
### 延遲串流結果 (Streaming Results Lazily)

`lazy` 方法的工作方式類似於 [chunk 方法](#chunking-results)，它以塊的方式執行查詢。但是，`lazy()` 方法不是將每個塊傳遞給回呼，而是回傳一個 [LazyCollection](/docs/collections#lazy-collections)，讓您可以將結果作為單一串流進行互動：

```php
use Illuminate\Support\Facades\DB;

DB::table('users')->orderBy('id')->lazy()->each(function (object $user) {
    // ...
});
```

同樣，如果您計劃在迭代時更新取得的記錄，最好改用 `lazyById` 或 `lazyByIdDesc` 方法。這些方法將根據記錄的主鍵自動分頁結果：

```php
DB::table('users')->where('active', false)
    ->lazyById()->each(function (object $user) {
        DB::table('users')
            ->where('id', $user->id)
            ->update(['active' => true]);
    });
```

> [!WARNING]
> 在迭代時更新或刪除記錄時，對主鍵或外鍵的任何更改都可能影響分塊查詢。這可能導致記錄未包含在結果中。

<a name="aggregates"></a>
### 聚合函數 (Aggregates)

查詢建構器還提供了各種方法來取得聚合值，例如 `count`、`max`、`min`、`avg` 和 `sum`。您可以在建構查詢後呼叫這些方法中的任何一個：

```php
use Illuminate\Support\Facades\DB;

$users = DB::table('users')->count();

$price = DB::table('orders')->max('price');
```

當然，您可以將這些方法與其他子句結合使用，以微調聚合值的計算方式：

```php
$price = DB::table('orders')
    ->where('finalized', 1)
    ->avg('price');
```

<a name="determining-if-records-exist"></a>
#### 判斷記錄是否存在 (Determining If Records Exist)

您可以使用 `exists` 和 `doesntExist` 方法來判斷是否存在符合查詢約束條件的記錄，而不是使用 `count` 方法：

```php
if (DB::table('orders')->where('finalized', 1)->exists()) {
    // ...
}

if (DB::table('orders')->where('finalized', 1)->doesntExist()) {
    // ...
}
```

<a name="select-statements"></a>
## Select 陳述式 (Select Statements)

<a name="specifying-a-select-clause"></a>
#### 指定 Select 子句 (Specifying A Select Clause)

您可能並不總是想從資料庫資料表中選取所有欄位。使用 `select` 方法，您可以為查詢指定自訂的「select」子句：

```php
use Illuminate\Support\Facades\DB;

$users = DB::table('users')
    ->select('name', 'email as user_email')
    ->get();
```

`distinct` 方法允許您強制查詢回傳不重複的結果：

```php
$users = DB::table('users')->distinct()->get();
```

如果您已經有一個查詢建構器實例，並且希望將欄位新增到其現有的 select 子句中，您可以使用 `addSelect` 方法：

```php
$query = DB::table('users')->select('name');

$users = $query->addSelect('age')->get();
```

<a name="raw-expressions"></a>
## Raw 表達式 (Raw Expressions)

有時候您可能需要在查詢中插入任意字串。若要建立原始字串表達式，您可以使用 `DB` Facade 提供的 `raw` 方法：

```php
$users = DB::table('users')
    ->select(DB::raw('count(*) as user_count, status'))
    ->where('status', '<>', 1)
    ->groupBy('status')
    ->get();
```

> [!WARNING]
> Raw 語句會以字串形式注入查詢中，因此您應該非常小心以避免建立 SQL 注入漏洞。

<a name="raw-methods"></a>
### Raw 方法 (Raw Methods)

除了使用 `DB::raw` 方法之外，您也可以使用以下方法將原始表達式插入查詢的各個部分。**請記住，Laravel 無法保證任何使用原始表達式的查詢受到 SQL 注入漏洞的保護。**

<a name="selectraw"></a>
#### `selectRaw`

`selectRaw` 方法可以用來取代 `addSelect(DB::raw(/* ... */))`。此方法接受一個可選的綁定陣列作為其第二個參數：

```php
$orders = DB::table('orders')
    ->selectRaw('price * ? as price_with_tax', [1.0825])
    ->get();
```

<a name="whereraw-orwhereraw"></a>
#### `whereRaw / orWhereRaw`

`whereRaw` 和 `orWhereRaw` 方法可用於在查詢中注入原始 "where" 子句。這些方法接受一個可選的綁定陣列作為其第二個參數：

```php
$orders = DB::table('orders')
    ->whereRaw('price > IF(state = "TX", ?, 100)', [200])
    ->get();
```

<a name="havingraw-orhavingraw"></a>
#### `havingRaw / orHavingRaw`

`havingRaw` 和 `orHavingRaw` 方法可用於提供原始字串作為 "having" 子句的值。這些方法接受一個可選的綁定陣列作為其第二個參數：

```php
$orders = DB::table('orders')
    ->select('department', DB::raw('SUM(price) as total_sales'))
    ->groupBy('department')
    ->havingRaw('SUM(price) > ?', [2500])
    ->get();
```

<a name="orderbyraw"></a>
#### `orderByRaw`

`orderByRaw` 方法可用於提供原始字串作為 "order by" 子句的值：

```php
$orders = DB::table('orders')
    ->orderByRaw('updated_at - created_at DESC')
    ->get();
```

<a name="groupbyraw"></a>
### `groupByRaw`

`groupByRaw` 方法可用於提供原始字串作為 `group by` 子句的值：

```php
$orders = DB::table('orders')
    ->select('city', 'state')
    ->groupByRaw('city, state')
    ->get();
```

<a name="joins"></a>
## Joins

<a name="inner-join-clause"></a>
#### Inner Join 子句 (Inner Join Clause)

查詢建構器也可用於在查詢中加入 join 子句。若要執行基本的 "inner join"，您可以在查詢建構器實例上使用 `join` 方法。傳遞給 `join` 方法的第一個參數是您需要 join 的資料表名稱，其餘參數則指定 join 的欄位約束。您甚至可以在單一查詢中 join 多個資料表：

```php
use Illuminate\Support\Facades\DB;

$users = DB::table('users')
    ->join('contacts', 'users.id', '=', 'contacts.user_id')
    ->join('orders', 'users.id', '=', 'orders.user_id')
    ->select('users.*', 'contacts.phone', 'orders.price')
    ->get();
```

<a name="left-join-right-join-clause"></a>
#### Left Join / Right Join 子句 (Left Join / Right Join Clause)

如果您想執行 "left join" 或 "right join" 而非 "inner join"，請使用 `leftJoin` 或 `rightJoin` 方法。這些方法與 `join` 方法具有相同的簽章：

```php
$users = DB::table('users')
    ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
    ->get();

$users = DB::table('users')
    ->rightJoin('posts', 'users.id', '=', 'posts.user_id')
    ->get();
```

<a name="cross-join-clause"></a>
#### Cross Join 子句 (Cross Join Clause)

您可以使用 `crossJoin` 方法來執行 "cross join"。Cross join 會在第一個資料表和被 join 的資料表之間產生笛卡兒積：

```php
$sizes = DB::table('sizes')
    ->crossJoin('colors')
    ->get();
```

<a name="advanced-join-clauses"></a>
#### 進階 Join 子句 (Advanced Join Clauses)

您也可以指定更進階的 join 子句。首先，傳遞一個閉包作為 `join` 方法的第二個參數。該閉包將接收一個 `Illuminate\Database\Query\JoinClause` 實例，讓您可以在 "join" 子句上指定約束：

```php
DB::table('users')
    ->join('contacts', function (JoinClause $join) {
        $join->on('users.id', '=', 'contacts.user_id')->orOn(/* ... */);
    })
    ->get();
```

如果您想在 join 上使用 "where" 子句，您可以使用 `JoinClause` 實例提供的 `where` 和 `orWhere` 方法。這些方法不是比較兩個欄位，而是將欄位與值進行比較：

```php
DB::table('users')
    ->join('contacts', function (JoinClause $join) {
        $join->on('users.id', '=', 'contacts.user_id')
            ->where('contacts.user_id', '>', 5);
    })
    ->get();
```

<a name="subquery-joins"></a>
#### 子查詢 Joins (Subquery Joins)

您可以使用 `joinSub`、`leftJoinSub` 和 `rightJoinSub` 方法將查詢 join 到子查詢。這些方法各接收三個參數：子查詢、其資料表別名，以及定義相關欄位的閉包。在此範例中，我們將取得使用者集合，其中每個使用者記錄還包含使用者最近發佈的部落格文章的 `created_at` 時間戳記：

```php
$latestPosts = DB::table('posts')
    ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
    ->where('is_published', true)
    ->groupBy('user_id');

$users = DB::table('users')
    ->joinSub($latestPosts, 'latest_posts', function (JoinClause $join) {
        $join->on('users.id', '=', 'latest_posts.user_id');
    })->get();
```

<a name="lateral-joins"></a>
#### Lateral Joins

> [!WARNING]
> Lateral joins 目前由 PostgreSQL、MySQL >= 8.0.14 和 SQL Server 支援。

您可以使用 `joinLateral` 和 `leftJoinLateral` 方法來執行與子查詢的 "lateral join"。這些方法各接收兩個參數：子查詢及其資料表別名。Join 條件應在給定子查詢的 `where` 子句中指定。Lateral joins 會針對每一列進行評估，並可以參照子查詢外部的欄位。

在此範例中，我們將取得使用者集合以及使用者最近的三篇部落格文章。每個使用者最多可以在結果集中產生三列：每篇最近的部落格文章一列。Join 條件在子查詢內使用 `whereColumn` 子句指定，參照目前的使用者列：

```php
$latestPosts = DB::table('posts')
    ->select('id as post_id', 'title as post_title', 'created_at as post_created_at')
    ->whereColumn('user_id', 'users.id')
    ->orderBy('created_at', 'desc')
    ->limit(3);

$users = DB::table('users')
    ->joinLateral($latestPosts, 'latest_posts')
    ->get();
```

<a name="unions"></a>
## Unions

查詢建構器也提供了一個便利的方法來「union」兩個或更多查詢。例如，您可以建立一個初始查詢，並使用 `union` 方法將其與更多查詢進行 union：

```php
use Illuminate\Support\Facades\DB;

$first = DB::table('users')
    ->whereNull('first_name');

$users = DB::table('users')
    ->whereNull('last_name')
    ->union($first)
    ->get();
```

除了 `union` 方法外，查詢建構器還提供了 `unionAll` 方法。使用 `unionAll` 方法合併的查詢不會移除重複的結果。`unionAll` 方法與 `union` 方法具有相同的方法簽章。

<a name="basic-where-clauses"></a>
## 基本 Where 子句 (Basic Where Clauses)

<a name="where-clauses"></a>
### Where 子句 (Where Clauses)

您可以使用查詢建構器的 `where` 方法來為查詢新增 "where" 子句。對 `where` 方法最基本的呼叫需要三個參數。第一個參數是欄位名稱。第二個參數是運算子，可以是資料庫支援的任何運算子。第三個參數是要與欄位值進行比較的值。

例如，以下查詢會取得 `votes` 欄位值等於 `100` 且 `age` 欄位值大於 `35` 的使用者：

```php
$users = DB::table('users')
    ->where('votes', '=', 100)
    ->where('age', '>', 35)
    ->get();
```

為了方便起見，如果您想驗證某個欄位是否 `=` 某個給定值，您可以將該值作為第二個參數傳遞給 `where` 方法。Laravel 會假設您想使用 `=` 運算子：

```php
$users = DB::table('users')->where('votes', 100)->get();
```

您也可以向 `where` 方法提供關聯陣列來快速查詢多個欄位：

```php
$users = DB::table('users')->where([
    'first_name' => 'Jane',
    'last_name' => 'Doe',
])->get();
```

如前所述，您可以使用資料庫系統支援的任何運算子：

```php
$users = DB::table('users')
    ->where('votes', '>=', 100)
    ->get();

$users = DB::table('users')
    ->where('votes', '<>', 100)
    ->get();

$users = DB::table('users')
    ->where('name', 'like', 'T%')
    ->get();
```

您也可以向 `where` 函式傳遞一個條件陣列。陣列中的每個元素應該是一個包含通常傳遞給 `where` 方法的三個參數的陣列：

```php
$users = DB::table('users')->where([
    ['status', '=', '1'],
    ['subscribed', '<>', '1'],
])->get();
```

> [!WARNING]
> PDO 不支援綁定欄位名稱。因此，您永遠不應該讓使用者輸入決定查詢中參照的欄位名稱，包括 "order by" 欄位。

> [!WARNING]
> MySQL 和 MariaDB 會在字串與數字比較時自動將字串轉型為整數。在此過程中，非數字字串會被轉換為 `0`，這可能會導致意外的結果。例如，如果您的資料表有一個值為 `aaa` 的 `secret` 欄位，而您執行 `User::where('secret', 0)`，該列將會被回傳。為避免這種情況，請確保所有值在查詢中使用前都已轉型為適當的類型。

<a name="or-where-clauses"></a>
### Or Where 子句 (Or Where Clauses)

當將呼叫鏈接到查詢建構器的 `where` 方法時，"where" 子句將使用 `and` 運算子連接在一起。然而，您可以使用 `orWhere` 方法來使用 `or` 運算子將子句連接到查詢。`orWhere` 方法接受與 `where` 方法相同的參數：

```php
$users = DB::table('users')
    ->where('votes', '>', 100)
    ->orWhere('name', 'John')
    ->get();
```

如果您需要在括號內分組一個 "or" 條件，您可以傳遞一個閉包作為 `orWhere` 方法的第一個參數：

```php
use Illuminate\Database\Query\Builder;

$users = DB::table('users')
    ->where('votes', '>', 100)
    ->orWhere(function (Builder $query) {
        $query->where('name', 'Abigail')
            ->where('votes', '>', 50);
        })
    ->get();
```

上面的範例將產生以下 SQL：

```sql
select * from users where votes > 100 or (name = 'Abigail' and votes > 50)
```

> [!WARNING]
> 您應該始終將 `orWhere` 呼叫分組，以避免在套用全域作用域時出現意外行為。

<a name="where-not-clauses"></a>
### Where Not 子句 (Where Not Clauses)

`whereNot` 和 `orWhereNot` 方法可用於否定給定的一組查詢約束。例如，以下查詢會排除正在清倉或價格低於十元的產品：

```php
$products = DB::table('products')
    ->whereNot(function (Builder $query) {
        $query->where('clearance', true)
            ->orWhere('price', '<', 10);
        })
    ->get();
```

<a name="where-any-all-none-clauses"></a>
### Where Any / All / None 子句 (Where Any / All / None Clauses)

有時您可能需要將相同的查詢約束套用於多個欄位。例如，您可能想取得給定清單中任何欄位 `LIKE` 給定值的所有記錄。您可以使用 `whereAny` 方法來完成此操作：

```php
$users = DB::table('users')
    ->where('active', true)
    ->whereAny([
        'name',
        'email',
        'phone',
    ], 'like', 'Example%')
    ->get();
```

上述查詢將產生以下 SQL：

```sql
SELECT *
FROM users
WHERE active = true AND (
    name LIKE 'Example%' OR
    email LIKE 'Example%' OR
    phone LIKE 'Example%'
)
```

同樣地，`whereAll` 方法可用於取得所有給定欄位都符合給定約束的記錄：

```php
$posts = DB::table('posts')
    ->where('published', true)
    ->whereAll([
        'title',
        'content',
    ], 'like', '%Laravel%')
    ->get();
```

上述查詢將產生以下 SQL：

```sql
SELECT *
FROM posts
WHERE published = true AND (
    title LIKE '%Laravel%' AND
    content LIKE '%Laravel%'
)
```

`whereNone` 方法可用於取得沒有任何給定欄位符合給定約束的記錄：

```php
$posts = DB::table('albums')
    ->where('published', true)
    ->whereNone([
        'title',
        'lyrics',
        'tags',
    ], 'like', '%explicit%')
    ->get();
```

上述查詢將產生以下 SQL：

```sql
SELECT *
FROM albums
WHERE published = true AND NOT (
    title LIKE '%explicit%' OR
    lyrics LIKE '%explicit%' OR
    tags LIKE '%explicit%'
)
```

<a name="json-where-clauses"></a>
### JSON Where 子句 (JSON Where Clauses)

Laravel 也支援在提供 JSON 欄位類型支援的資料庫上查詢 JSON 欄位類型。目前，這包括 MariaDB 10.3+、MySQL 8.0+、PostgreSQL 12.0+、SQL Server 2017+ 和 SQLite 3.39.0+。若要查詢 JSON 欄位，請使用 `->` 運算子：

```php
$users = DB::table('users')
    ->where('preferences->dining->meal', 'salad')
    ->get();

$users = DB::table('users')
    ->whereIn('preferences->dining->meal', ['pasta', 'salad', 'sandwiches'])
    ->get();
```

您可以使用 `whereJsonContains` 和 `whereJsonDoesntContain` 方法來查詢 JSON 陣列：

```php
$users = DB::table('users')
    ->whereJsonContains('options->languages', 'en')
    ->get();

$users = DB::table('users')
    ->whereJsonDoesntContain('options->languages', 'en')
    ->get();
```

如果您的應用程式使用 MariaDB、MySQL 或 PostgreSQL 資料庫，您可以向 `whereJsonContains` 和 `whereJsonDoesntContain` 方法傳遞一個值陣列：

```php
$users = DB::table('users')
    ->whereJsonContains('options->languages', ['en', 'de'])
    ->get();

$users = DB::table('users')
    ->whereJsonDoesntContain('options->languages', ['en', 'de'])
    ->get();
```

此外，您可以使用 `whereJsonContainsKey` 或 `whereJsonDoesntContainKey` 方法來取得包含或不包含 JSON 鍵的結果：

```php
$users = DB::table('users')
    ->whereJsonContainsKey('preferences->dietary_requirements')
    ->get();

$users = DB::table('users')
    ->whereJsonDoesntContainKey('preferences->dietary_requirements')
    ->get();
```

最後，您可以使用 `whereJsonLength` 方法根據 JSON 陣列的長度來查詢：

```php
$users = DB::table('users')
    ->whereJsonLength('options->languages', 0)
    ->get();

$users = DB::table('users')
    ->whereJsonLength('options->languages', '>', 1)
    ->get();
```

<a name="additional-where-clauses"></a>
### 其他 Where 子句 (Additional Where Clauses)

**whereLike / orWhereLike / whereNotLike / orWhereNotLike**

`whereLike` 方法允許您將 "LIKE" 子句新增到查詢中進行模式比對。這些方法提供了一種資料庫無關的方式來執行字串比對查詢，並且可以切換大小寫敏感性。預設情況下，字串比對不區分大小寫：

```php
$users = DB::table('users')
    ->whereLike('name', '%John%')
    ->get();
```

您可以透過 `caseSensitive` 參數啟用區分大小寫的搜尋：

```php
$users = DB::table('users')
    ->whereLike('name', '%John%', caseSensitive: true)
    ->get();
```

`orWhereLike` 方法允許您新增帶有 LIKE 條件的 "or" 子句：

```php
$users = DB::table('users')
    ->where('votes', '>', 100)
    ->orWhereLike('name', '%John%')
    ->get();
```

`whereNotLike` 方法允許您將 "NOT LIKE" 子句新增到查詢中：

```php
$users = DB::table('users')
    ->whereNotLike('name', '%John%')
    ->get();
```

同樣地，您可以使用 `orWhereNotLike` 來新增帶有 NOT LIKE 條件的 "or" 子句：

```php
$users = DB::table('users')
    ->where('votes', '>', 100)
    ->orWhereNotLike('name', '%John%')
    ->get();
```

> [!WARNING]
> SQL Server 目前不支援 `whereLike` 的區分大小寫搜尋選項。

**whereIn / whereNotIn / orWhereIn / orWhereNotIn**

`whereIn` 方法驗證給定欄位的值是否包含在給定陣列中：

```php
$users = DB::table('users')
    ->whereIn('id', [1, 2, 3])
    ->get();
```

`whereNotIn` 方法驗證給定欄位的值是否不包含在給定陣列中：

```php
$users = DB::table('users')
    ->whereNotIn('id', [1, 2, 3])
    ->get();
```

您也可以提供查詢物件作為 `whereIn` 方法的第二個參數：

```php
$activeUsers = DB::table('users')->select('id')->where('is_active', 1);

$users = DB::table('comments')
    ->whereIn('user_id', $activeUsers)
    ->get();
```

上述範例將產生以下 SQL：

```sql
select * from comments where user_id in (
    select id
    from users
    where is_active = 1
)
```

> [!WARNING]
> 如果您要在查詢中新增大量整數綁定，可以使用 `whereIntegerInRaw` 或 `whereIntegerNotInRaw` 方法來大幅減少記憶體使用量。

**whereBetween / orWhereBetween**

`whereBetween` 方法驗證欄位的值是否在兩個值之間：

```php
$users = DB::table('users')
    ->whereBetween('votes', [1, 100])
    ->get();
```

**whereNotBetween / orWhereNotBetween**

`whereNotBetween` 方法驗證欄位的值是否在兩個值之外：

```php
$users = DB::table('users')
    ->whereNotBetween('votes', [1, 100])
    ->get();
```

**whereBetweenColumns / whereNotBetweenColumns / orWhereBetweenColumns / orWhereNotBetweenColumns**

`whereBetweenColumns` 方法驗證欄位的值是否在同一資料表列中兩個欄位的值之間：

```php
$patients = DB::table('patients')
    ->whereBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])
    ->get();
```

`whereNotBetweenColumns` 方法驗證欄位的值是否在同一資料表列中兩個欄位的值之外：

```php
$patients = DB::table('patients')
    ->whereNotBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])
    ->get();
```

**whereValueBetween / whereValueNotBetween / orWhereValueBetween / orWhereValueNotBetween**

`whereValueBetween` 方法驗證給定值是否在同一資料表列中兩個相同類型欄位的值之間：

```php
$patients = DB::table('products')
    ->whereValueBetween(100, ['min_price', 'max_price'])
    ->get();
```

`whereValueNotBetween` 方法驗證值是否在同一資料表列中兩個欄位的值之外：

```php
$patients = DB::table('products')
    ->whereValueNotBetween(100, ['min_price', 'max_price'])
    ->get();
```

**whereNull / whereNotNull / orWhereNull / orWhereNotNull**

`whereNull` 方法驗證給定欄位的值是否為 `NULL`：

```php
$users = DB::table('users')
    ->whereNull('updated_at')
    ->get();
```

`whereNotNull` 方法驗證欄位的值是否不為 `NULL`：

```php
$users = DB::table('users')
    ->whereNotNull('updated_at')
    ->get();
```

**whereDate / whereMonth / whereDay / whereYear / whereTime**

`whereDate` 方法可用於將欄位的值與日期進行比較：

```php
$users = DB::table('users')
    ->whereDate('created_at', '2016-12-31')
    ->get();
```

`whereMonth` 方法可用於將欄位的值與特定月份進行比較：

```php
$users = DB::table('users')
    ->whereMonth('created_at', '12')
    ->get();
```

`whereDay` 方法可用於將欄位的值與特定月份中的某一天進行比較：

```php
$users = DB::table('users')
    ->whereDay('created_at', '31')
    ->get();
```

`whereYear` 方法可用於將欄位的值與特定年份進行比較：

```php
$users = DB::table('users')
    ->whereYear('created_at', '2016')
    ->get();
```

`whereTime` 方法可用於將欄位的值與特定時間進行比較：

```php
$users = DB::table('users')
    ->whereTime('created_at', '=', '11:20:45')
    ->get();
```

**wherePast / whereFuture / whereToday / whereBeforeToday / whereAfterToday**

`wherePast` 和 `whereFuture` 方法可用於判斷欄位的值是在過去還是未來：

```php
$invoices = DB::table('invoices')
    ->wherePast('due_at')
    ->get();

$invoices = DB::table('invoices')
    ->whereFuture('due_at')
    ->get();
```

`whereNowOrPast` 和 `whereNowOrFuture` 方法可用於判斷欄位的值是在過去還是未來，包含目前的日期和時間：

```php
$invoices = DB::table('invoices')
    ->whereNowOrPast('due_at')
    ->get();

$invoices = DB::table('invoices')
    ->whereNowOrFuture('due_at')
    ->get();
```

`whereToday`、`whereBeforeToday` 和 `whereAfterToday` 方法可用於分別判斷欄位的值是今天、今天之前還是今天之後：

```php
$invoices = DB::table('invoices')
    ->whereToday('due_at')
    ->get();

$invoices = DB::table('invoices')
    ->whereBeforeToday('due_at')
    ->get();

$invoices = DB::table('invoices')
    ->whereAfterToday('due_at')
    ->get();
```

同樣地，`whereTodayOrBefore` 和 `whereTodayOrAfter` 方法可用於判斷欄位的值是否在今天之前或今天之後，包含今天的日期：

```php
$invoices = DB::table('invoices')
    ->whereTodayOrBefore('due_at')
    ->get();

$invoices = DB::table('invoices')
    ->whereTodayOrAfter('due_at')
    ->get();
```

**whereColumn / orWhereColumn**

`whereColumn` 方法可用於驗證兩個欄位是否相等：

```php
$users = DB::table('users')
    ->whereColumn('first_name', 'last_name')
    ->get();
```

您也可以向 `whereColumn` 方法傳遞比較運算子：

```php
$users = DB::table('users')
    ->whereColumn('updated_at', '>', 'created_at')
    ->get();
```

您也可以向 `whereColumn` 方法傳遞欄位比較陣列。這些條件將使用 `and` 運算子連接：

```php
$users = DB::table('users')
    ->whereColumn([
        ['first_name', '=', 'last_name'],
        ['updated_at', '>', 'created_at'],
    ])->get();
```

<a name="logical-grouping"></a>
### 邏輯分組 (Logical Grouping)

有時您可能需要在括號內分組多個 "where" 子句，以達到查詢所需的邏輯分組。事實上，您通常應該始終將 `orWhere` 方法的呼叫分組在括號內，以避免意外的查詢行為。若要完成此操作，您可以向 `where` 方法傳遞一個閉包：

```php
$users = DB::table('users')
    ->where('name', '=', 'John')
    ->where(function (Builder $query) {
        $query->where('votes', '>', 100)
            ->orWhere('title', '=', 'Admin');
    })
    ->get();
```

如您所見，將閉包傳遞給 `where` 方法會指示查詢建構器開始一個約束群組。該閉包將接收一個查詢建構器實例，您可以使用它來設定應包含在括號群組內的約束。上述範例將產生以下 SQL：

```sql
select * from users where name = 'John' and (votes > 100 or title = 'Admin')
```

> [!WARNING]
> 您應該始終將 `orWhere` 呼叫分組，以避免在套用全域作用域時出現意外行為。

<a name="advanced-where-clauses"></a>
## 進階 Where 子句 (Advanced Where Clauses)

<a name="where-exists-clauses"></a>
### Where Exists 子句 (Where Exists Clauses)

`whereExists` 方法允許您撰寫 "where exists" SQL 子句。`whereExists` 方法接受一個閉包，該閉包將接收一個查詢建構器實例，讓您可以定義應放置在 "exists" 子句內的查詢：

```php
$users = DB::table('users')
    ->whereExists(function (Builder $query) {
        $query->select(DB::raw(1))
            ->from('orders')
            ->whereColumn('orders.user_id', 'users.id');
    })
    ->get();
```

或者，您可以向 `whereExists` 方法提供查詢物件而非閉包：

```php
$orders = DB::table('orders')
    ->select(DB::raw(1))
    ->whereColumn('orders.user_id', 'users.id');

$users = DB::table('users')
    ->whereExists($orders)
    ->get();
```

上述兩個範例都將產生以下 SQL：

```sql
select * from users
where exists (
    select 1
    from orders
    where orders.user_id = users.id
)
```

<a name="subquery-where-clauses"></a>
### 子查詢 Where 子句 (Subquery Where Clauses)

有時您可能需要建構一個將子查詢的結果與給定值進行比較的 "where" 子句。您可以透過向 `where` 方法傳遞閉包和值來完成此操作。例如，以下查詢將取得所有具有給定類型的最近「membership」的使用者：

```php
use App\Models\User;
use Illuminate\Database\Query\Builder;

$users = User::where(function (Builder $query) {
    $query->select('type')
        ->from('membership')
        ->whereColumn('membership.user_id', 'users.id')
        ->orderByDesc('membership.start_date')
        ->limit(1);
}, 'Pro')->get();
```

或者，您可能需要建構一個將欄位與子查詢結果進行比較的 "where" 子句。您可以透過向 `where` 方法傳遞欄位、運算子和閉包來完成此操作。例如，以下查詢將取得金額低於平均值的所有收入記錄：

```php
use App\Models\Income;
use Illuminate\Database\Query\Builder;

$incomes = Income::where('amount', '<', function (Builder $query) {
    $query->selectRaw('avg(i.amount)')->from('incomes as i');
})->get();
```

<a name="full-text-where-clauses"></a>
### 全文 Where 子句 (Full Text Where Clauses)

> [!WARNING]
> MariaDB、MySQL 和 PostgreSQL 目前支援全文 where 子句。

`whereFullText` 和 `orWhereFullText` 方法可用於為具有[全文索引](/docs/migrations#available-index-types)的欄位新增全文 "where" 子句到查詢中。Laravel 會將這些方法轉換為底層資料庫系統的適當 SQL。例如，對於使用 MariaDB 或 MySQL 的應用程式，將產生 `MATCH AGAINST` 子句：

```php
$users = DB::table('users')
    ->whereFullText('bio', 'web developer')
    ->get();
```

<a name="ordering-grouping-limit-and-offset"></a>
## 排序、分組、限制和偏移 (Ordering, Grouping, Limit and Offset)

<a name="ordering"></a>
### 排序 (Ordering)

<a name="orderby"></a>
#### `orderBy` 方法

`orderBy` 方法允許您依據給定欄位對查詢結果進行排序。`orderBy` 方法接受的第一個參數應該是您要排序的欄位，而第二個參數決定排序方向，可以是 `asc` 或 `desc`：

```php
$users = DB::table('users')
    ->orderBy('name', 'desc')
    ->get();
```

若要依據多個欄位排序，您可以視需要多次呼叫 `orderBy`：

```php
$users = DB::table('users')
    ->orderBy('name', 'desc')
    ->orderBy('email', 'asc')
    ->get();
```

排序方向是可選的，預設為升序。如果您想要降序排序，您可以為 `orderBy` 方法指定第二個參數，或者直接使用 `orderByDesc`：

```php
$users = DB::table('users')
    ->orderByDesc('verified_at')
    ->get();
```

最後，使用 `->` 運算子，結果可以依據 JSON 欄位內的值進行排序：

```php
$corporations = DB::table('corporations')
    ->where('country', 'US')
    ->orderBy('location->state')
    ->get();
```

<a name="latest-oldest"></a>
#### `latest` 和 `oldest` 方法 (Latest Oldest)

`latest` 和 `oldest` 方法讓您可以輕鬆地依據日期對結果進行排序。預設情況下，結果將依據資料表的 `created_at` 欄位排序。或者，您可以傳遞要排序的欄位名稱：

```php
$user = DB::table('users')
    ->latest()
    ->first();
```

<a name="random-ordering"></a>
#### 隨機排序 (Random Ordering)

`inRandomOrder` 方法可用於隨機排序查詢結果。例如，您可以使用此方法來取得隨機使用者：

```php
$randomUser = DB::table('users')
    ->inRandomOrder()
    ->first();
```

<a name="removing-existing-orderings"></a>
#### 移除現有排序 (Removing Existing Orderings)

`reorder` 方法會移除之前套用於查詢的所有 "order by" 子句：

```php
$query = DB::table('users')->orderBy('name');

$unorderedUsers = $query->reorder()->get();
```

您可以在呼叫 `reorder` 方法時傳遞欄位和方向，以移除所有現有的 "order by" 子句並對查詢套用全新的排序：

```php
$query = DB::table('users')->orderBy('name');

$usersOrderedByEmail = $query->reorder('email', 'desc')->get();
```

為了方便起見，您可以使用 `reorderDesc` 方法以降序重新排序查詢結果：

```php
$query = DB::table('users')->orderBy('name');

$usersOrderedByEmail = $query->reorderDesc('email')->get();
```

<a name="grouping"></a>
### 分組 (Grouping)

<a name="groupby-having"></a>
#### `groupBy` 和 `having` 方法 (Groupby Having)

如您所預期的，`groupBy` 和 `having` 方法可用於對查詢結果進行分組。`having` 方法的簽章與 `where` 方法類似：

```php
$users = DB::table('users')
    ->groupBy('account_id')
    ->having('account_id', '>', 100)
    ->get();
```

您可以使用 `havingBetween` 方法來過濾給定範圍內的結果：

```php
$report = DB::table('orders')
    ->selectRaw('count(id) as number_of_orders, customer_id')
    ->groupBy('customer_id')
    ->havingBetween('number_of_orders', [5, 15])
    ->get();
```

您可以向 `groupBy` 方法傳遞多個參數以依據多個欄位進行分組：

```php
$users = DB::table('users')
    ->groupBy('first_name', 'status')
    ->having('account_id', '>', 100)
    ->get();
```

若要建構更進階的 `having` 語句，請參閱 [havingRaw](#raw-methods) 方法。

<a name="limit-and-offset"></a>
### 限制和偏移 (Limit and Offset)

您可以使用 `limit` 和 `offset` 方法來限制查詢回傳的結果數量，或在查詢中略過給定數量的結果：

```php
$users = DB::table('users')
    ->offset(10)
    ->limit(5)
    ->get();
```

<a name="conditional-clauses"></a>
## 條件子句 (Conditional Clauses)

有時您可能希望某些查詢子句根據另一個條件套用於查詢。例如，您可能只想在傳入的 HTTP 請求中存在給定輸入值時才套用 `where` 語句。您可以使用 `when` 方法來完成此操作：

```php
$role = $request->input('role');

$users = DB::table('users')
    ->when($role, function (Builder $query, string $role) {
        $query->where('role_id', $role);
    })
    ->get();
```

`when` 方法只有在第一個參數為 `true` 時才會執行給定的閉包。如果第一個參數為 `false`，則閉包不會被執行。因此，在上面的範例中，只有當傳入請求中存在 `role` 欄位並評估為 `true` 時，才會呼叫給予 `when` 方法的閉包。

您可以將另一個閉包作為第三個參數傳遞給 `when` 方法。只有當第一個參數評估為 `false` 時，才會執行此閉包。為了說明此功能的用法，我們將使用它來設定查詢的預設排序：

```php
$sortByVotes = $request->boolean('sort_by_votes');

$users = DB::table('users')
    ->when($sortByVotes, function (Builder $query, bool $sortByVotes) {
        $query->orderBy('votes');
    }, function (Builder $query) {
        $query->orderBy('name');
    })
    ->get();
```

<a name="insert-statements"></a>
## Insert 語句 (Insert Statements)

查詢建構器也提供了 `insert` 方法，可用於將記錄插入資料庫資料表。`insert` 方法接受一個包含欄位名稱和值的陣列：

```php
DB::table('users')->insert([
    'email' => 'kayla@example.com',
    'votes' => 0
]);
```

您可以透過傳遞陣列的陣列來一次插入多條記錄。每個陣列代表應插入資料表的一條記錄：

```php
DB::table('users')->insert([
    ['email' => 'picard@example.com', 'votes' => 0],
    ['email' => 'janeway@example.com', 'votes' => 0],
]);
```

`insertOrIgnore` 方法會在將記錄插入資料庫時忽略錯誤。使用此方法時，您應該注意重複記錄錯誤將被忽略，其他類型的錯誤也可能根據資料庫引擎而被忽略。例如，`insertOrIgnore` 將[繞過 MySQL 的嚴格模式](https://dev.mysql.com/doc/refman/en/sql-mode.html#ignore-effect-on-execution)：

```php
DB::table('users')->insertOrIgnore([
    ['id' => 1, 'email' => 'sisko@example.com'],
    ['id' => 2, 'email' => 'archer@example.com'],
]);
```

`insertUsing` 方法會使用子查詢來決定應插入的資料，將新記錄插入資料表：

```php
DB::table('pruned_users')->insertUsing([
    'id', 'name', 'email', 'email_verified_at'
], DB::table('users')->select(
    'id', 'name', 'email', 'email_verified_at'
)->where('updated_at', '<=', now()->subMonth()));
```

<a name="auto-incrementing-ids"></a>
#### 自動遞增 ID (Auto-Incrementing IDs)

如果資料表有自動遞增的 id，請使用 `insertGetId` 方法來插入記錄，然後取得該 ID：

```php
$id = DB::table('users')->insertGetId(
    ['email' => 'john@example.com', 'votes' => 0]
);
```

> [!WARNING]
> 使用 PostgreSQL 時，`insertGetId` 方法預期自動遞增欄位的名稱為 `id`。如果您想從不同的「序列」取得 ID，您可以將欄位名稱作為第二個參數傳遞給 `insertGetId` 方法。

<a name="upserts"></a>
### Upserts

`upsert` 方法會插入不存在的記錄，並以您可以指定的新值更新已存在的記錄。該方法的第一個參數包含要插入或更新的值，而第二個參數列出在關聯資料表中唯一識別記錄的欄位。該方法的第三個也是最後一個參數是一個欄位陣列，如果資料庫中已存在相符的記錄，則應更新這些欄位：

```php
DB::table('flights')->upsert(
    [
        ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
        ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
    ],
    ['departure', 'destination'],
    ['price']
);
```

在上面的範例中，Laravel 將嘗試插入兩條記錄。如果已存在具有相同 `departure` 和 `destination` 欄位值的記錄，Laravel 將更新該記錄的 `price` 欄位。

> [!WARNING]
> 除了 SQL Server 之外，所有資料庫都要求 `upsert` 方法的第二個參數中的欄位具有「主鍵」或「唯一」索引。此外，MariaDB 和 MySQL 資料庫驅動程式會忽略 `upsert` 方法的第二個參數，並始終使用資料表的「主鍵」和「唯一」索引來偵測現有記錄。

<a name="update-statements"></a>
## Update 語句 (Update Statements)

除了將記錄插入資料庫之外，查詢建構器還可以使用 `update` 方法更新現有記錄。`update` 方法與 `insert` 方法一樣，接受一個包含欄位和值配對的陣列，表示要更新的欄位。`update` 方法回傳受影響的列數。您可以使用 `where` 子句來約束 `update` 查詢：

```php
$affected = DB::table('users')
    ->where('id', 1)
    ->update(['votes' => 1]);
```

<a name="update-or-insert"></a>
#### 更新或插入 (Update or Insert)

有時您可能想要更新資料庫中的現有記錄，或者如果沒有相符的記錄存在則建立它。在這種情況下，可以使用 `updateOrInsert` 方法。`updateOrInsert` 方法接受兩個參數：一個用於尋找記錄的條件陣列，以及一個包含欄位和值配對的陣列，表示要更新的欄位。

`updateOrInsert` 方法會嘗試使用第一個參數的欄位和值配對來定位相符的資料庫記錄。如果記錄存在，將使用第二個參數中的值進行更新。如果找不到記錄，將使用兩個參數合併的屬性插入一條新記錄：

```php
DB::table('users')
    ->updateOrInsert(
        ['email' => 'john@example.com', 'name' => 'John'],
        ['votes' => '2']
    );
```

您可以向 `updateOrInsert` 方法提供一個閉包，根據是否存在相符的記錄來自訂要更新或插入資料庫的屬性：

```php
DB::table('users')->updateOrInsert(
    ['user_id' => $user_id],
    fn ($exists) => $exists ? [
        'name' => $data['name'],
        'email' => $data['email'],
    ] : [
        'name' => $data['name'],
        'email' => $data['email'],
        'marketable' => true,
    ],
);
```

<a name="updating-json-columns"></a>
### 更新 JSON 欄位 (Updating JSON Columns)

更新 JSON 欄位時，您應該使用 `->` 語法來更新 JSON 物件中的適當鍵。此操作在 MariaDB 10.3+、MySQL 5.7+ 和 PostgreSQL 9.5+ 上受支援：

```php
$affected = DB::table('users')
    ->where('id', 1)
    ->update(['options->enabled' => true]);
```

<a name="increment-and-decrement"></a>
### 遞增和遞減 (Increment and Decrement)

查詢建構器也提供了便利的方法來遞增或遞減給定欄位的值。這兩種方法至少接受一個參數：要修改的欄位。可以提供第二個參數來指定欄位應遞增或遞減的數量：

```php
DB::table('users')->increment('votes');

DB::table('users')->increment('votes', 5);

DB::table('users')->decrement('votes');

DB::table('users')->decrement('votes', 5);
```

如果需要，您還可以在遞增或遞減操作期間指定要更新的其他欄位：

```php
DB::table('users')->increment('votes', 1, ['name' => 'John']);
```

此外，您可以使用 `incrementEach` 和 `decrementEach` 方法一次遞增或遞減多個欄位：

```php
DB::table('users')->incrementEach([
    'votes' => 5,
    'balance' => 100,
]);
```

<a name="delete-statements"></a>
## Delete 語句 (Delete Statements)

查詢建構器的 `delete` 方法可用於從資料表中刪除記錄。`delete` 方法回傳受影響的列數。您可以在呼叫 `delete` 方法之前新增 "where" 子句來約束 `delete` 語句：

```php
$deleted = DB::table('users')->delete();

$deleted = DB::table('users')->where('votes', '>', 100)->delete();
```

<a name="pessimistic-locking"></a>
## 悲觀鎖 (Pessimistic Locking)

查詢建構器還包含一些函式，可幫助您在執行 `select` 語句時實現「悲觀鎖」。若要使用「共享鎖」執行語句，您可以呼叫 `sharedLock` 方法。共享鎖會阻止選取的列在您的交易提交之前被修改：

```php
DB::table('users')
    ->where('votes', '>', 100)
    ->sharedLock()
    ->get();
```

或者，您可以使用 `lockForUpdate` 方法。「for update」鎖會阻止選取的記錄被修改或被另一個共享鎖選取：

```php
DB::table('users')
    ->where('votes', '>', 100)
    ->lockForUpdate()
    ->get();
```

雖然不是必須的，但建議將悲觀鎖包裹在[交易](/docs/database#database-transactions)中。這確保了在整個操作完成之前，取得的資料在資料庫中保持不變。如果發生失敗，交易將回滾任何變更並自動釋放鎖：

```php
DB::transaction(function () {
    $sender = DB::table('users')
        ->lockForUpdate()
        ->find(1);

    $receiver = DB::table('users')
        ->lockForUpdate()
        ->find(2);

    if ($sender->balance < 100) {
        throw new RuntimeException('Balance too low.');
    }

    DB::table('users')
        ->where('id', $sender->id)
        ->update([
            'balance' => $sender->balance - 100
        ]);

    DB::table('users')
        ->where('id', $receiver->id)
        ->update([
            'balance' => $receiver->balance + 100
        ]);
});
```

<a name="reusable-query-components"></a>
## 可重用查詢元件 (Reusable Query Components)

如果您的應用程式中有重複的查詢邏輯，您可以使用查詢建構器的 `tap` 和 `pipe` 方法將邏輯提取到可重用物件中。想像您的應用程式中有這兩個不同的查詢：

```php
use Illuminate\Database\Query\Builder;
use Illuminate\Support\Facades\DB;

$destination = $request->query('destination');

DB::table('flights')
    ->when($destination, function (Builder $query, string $destination) {
        $query->where('destination', $destination);
    })
    ->orderByDesc('price')
    ->get();

// ...

$destination = $request->query('destination');

DB::table('flights')
    ->when($destination, function (Builder $query, string $destination) {
        $query->where('destination', $destination);
    })
    ->where('user', $request->user()->id)
    ->orderBy('destination')
    ->get();
```

您可能想要將查詢之間共用的目的地過濾提取到可重用物件中：

```php
<?php

namespace App\Scopes;

use Illuminate\Database\Query\Builder;

class DestinationFilter
{
    public function __construct(
        private ?string $destination,
    ) {
        //
    }

    public function __invoke(Builder $query): void
    {
        $query->when($this->destination, function (Builder $query) {
            $query->where('destination', $this->destination);
        });
    }
}
```

然後，您可以使用查詢建構器的 `tap` 方法將物件的邏輯套用到查詢：

```php
use App\Scopes\DestinationFilter;
use Illuminate\Database\Query\Builder;
use Illuminate\Support\Facades\DB;

DB::table('flights')
    ->when($destination, function (Builder $query, string $destination) { // [tl! remove]
        $query->where('destination', $destination); // [tl! remove]
    }) // [tl! remove]
    ->tap(new DestinationFilter($destination)) // [tl! add]
    ->orderByDesc('price')
    ->get();

// ...

DB::table('flights')
    ->when($destination, function (Builder $query, string $destination) { // [tl! remove]
        $query->where('destination', $destination); // [tl! remove]
    }) // [tl! remove]
    ->tap(new DestinationFilter($destination)) // [tl! add]
    ->where('user', $request->user()->id)
    ->orderBy('destination')
    ->get();
```

<a name="query-pipes"></a>
#### 查詢管道 (Query Pipes)

`tap` 方法總是回傳查詢建構器。如果您想提取一個執行查詢並回傳另一個值的物件，您可以改用 `pipe` 方法。

考慮以下包含應用程式中使用的共用[分頁](/docs/pagination)邏輯的查詢物件。與將查詢條件套用到查詢的 `DestinationFilter` 不同，`Paginate` 物件執行查詢並回傳分頁器實例：

```php
<?php

namespace App\Scopes;

use Illuminate\Contracts\Pagination\LengthAwarePaginator;
use Illuminate\Database\Query\Builder;

class Paginate
{
    public function __construct(
        private string $sortBy = 'timestamp',
        private string $sortDirection = 'desc',
        private int $perPage = 25,
    ) {
        //
    }

    public function __invoke(Builder $query): LengthAwarePaginator
    {
        return $query->orderBy($this->sortBy, $this->sortDirection)
            ->paginate($this->perPage, pageName: 'p');
    }
}
```

使用查詢建構器的 `pipe` 方法，我們可以利用此物件來套用我們的共用分頁邏輯：

```php
$flights = DB::table('flights')
    ->tap(new DestinationFilter($destination))
    ->pipe(new Paginate);
```

<a name="debugging"></a>
## 除錯 (Debugging)

您可以在建構查詢時使用 `dd` 和 `dump` 方法來傾印目前的查詢綁定和 SQL。`dd` 方法會顯示除錯資訊，然後停止執行請求。`dump` 方法會顯示除錯資訊，但允許請求繼續執行：

```php
DB::table('users')->where('votes', '>', 100)->dd();

DB::table('users')->where('votes', '>', 100)->dump();
```

`dumpRawSql` 和 `ddRawSql` 方法可以在查詢上呼叫，以傾印已正確替換所有參數綁定的查詢 SQL：

```php
DB::table('users')->where('votes', '>', 100)->dumpRawSql();

DB::table('users')->where('votes', '>', 100)->ddRawSql();
```
