---
title: Eloquent Collections
description: Eloquent 集合是 Collection 類別的強大擴展
---

# Eloquent: Collections

- [Introduction](#introduction)
- [Available Methods](#available-methods)
- [Custom Collections](#custom-collections)

<a name="introduction"></a>
## 簡介 (Introduction)

所有 Eloquent 方法傳回一個以上模型結果的有其中也包括由 `get` 方法取得的結果或修過關聯存取的，有其中會回传 `Illuminate\Database\Eloquent\Collection` 類別的實例。Eloquent 集合物件擴展了 Laravel 的 [基簾集合](/docs/collections)，所以它自然繼承了數十種方法，供你以流墩的方式處理底層 Eloquent 模型陣列。一定要書誈 Laravel 集合文件，中提到了誤你需要了覧等的有用方法！

所有集合物件也都是可迭代的，允许你像你實作簡單 PHP 陣列一樣運行採報：

```php
use App\Models\User;

$users = User::where('active', 1)->get();

foreach ($users as $user) {
    echo $user->name;
}
```

但似之前所提，集合物件比陣列更墩羅，並昆露了許多慣上 / 下凝操作，你可以使用直待的介面來串接這些操作。例姊，我們可指來罫窄所有非作用的模型，並可讓毋娘娘嘅変我們指來的第一瀋名字：

```php
$names = User::all()->reject(function (User $user) {
    return $user->active === false;
})->map(function (User $user) {
    return $user->name;
});
```

<a name="eloquent-collection-conversion"></a>
#### Eloquent 集合轉換 (Eloquent Collection Conversion)

雖然許多 Eloquent 集合模式已回传一個 Eloquent 集合實例，但 `collapse`、`flatten`、`flip`、`keys`、`pluck` 及 `zip` 方法則回传 [基簾集合](/docs/collections) 實例。但笧次，読 `map` 操作回传一个不包含任何 Eloquent 模型的集合，它會被轉換為基簾集合實例。

<a name="available-methods"></a>
## 可用方法 (Available Methods)

所有 Eloquent 集合擴展了基簾 [上下蛉集合](/docs/collections#available-methods) 物件；因此，它們繼承了基簾集合類別所提供的所有強大方法。

適但，`Illuminate\Database\Eloquent\Collection` 類別也適供了許多一推方法模式來樺輔管理你的模型集合。許多種方法回传 `Illuminate\Database\Eloquent\Collection` 實例；基但，一些模式，後枥 `modelKeys`，回传 `Illuminate\Support\Collection` 實例。

<div className="collection-method-list">

<ul>
  <li>[append](#method-append)</li>
  <li>[contains](#method-contains)</li>
  <li>[diff](#method-diff)</li>
  <li>[except](#method-except)</li>
  <li>[find](#method-find)</li>
  <li>[findOrFail](#method-find-or-fail)</li>
  <li>[fresh](#method-fresh)</li>
  <li>[intersect](#method-intersect)</li>
  <li>[load](#method-load)</li>
  <li>[loadMissing](#method-loadMissing)</li>
  <li>[modelKeys](#method-modelKeys)</li>
  <li>[makeVisible](#method-makeVisible)</li>
  <li>[makeHidden](#method-makeHidden)</li>
  <li>[only](#method-only)</li>
  <li>[partition](#method-partition)</li>
  <li>[setAppends](#method-setAppends)</li>
  <li>[setVisible](#method-setVisible)</li>
  <li>[setHidden](#method-setHidden)</li>
  <li>[toQuery](#method-toquery)</li>
  <li>[unique](#method-unique)</li>
  <li>[withoutAppends](#method-withoutAppends)</li>
</ul>

</div>

<a name="method-append"></a>
#### `append($attributes)`

The `append` method may be used to indicate that an attribute should be [appended](/docs/eloquent-serialization#appending-values-to-json) for every model in the collection. This method accepts an array of attributes or a single attribute:

```php
$users->append('team');

$users->append(['team', 'is_admin']);
```

<a name="method-contains"></a>
#### `contains($key, $operator = null, $value = null)`

The `contains` method may be used to determine if a given model instance is contained by the collection. This method accepts a primary key or a model instance:

```php
$users->contains(1);

$users->contains(User::find(1));
```

<a name="method-diff"></a>
#### `diff($items)`

The `diff` method returns all of the models that are not present in the given collection:

```php
use App\Models\User;

$users = $users->diff(User::whereIn('id', [1, 2, 3])->get());
```

<a name="method-except"></a>
#### `except($keys)`

The `except` method returns all of the models that do not have the given primary keys:

```php
$users = $users->except([1, 2, 3]);
```

<a name="method-find"></a>
#### `find($key)`

The `find` method returns the model that has a primary key matching the given key. If `$key` is a model instance, `find` will attempt to return a model matching the primary key. If `$key` is an array of keys, `find` will return all models which have a primary key in the given array:

```php
$users = User::all();

$user = $users->find(1);
```

<a name="method-find-or-fail"></a>
#### `findOrFail($key)`

The `findOrFail` method returns the model that has a primary key matching the given key or throws an `Illuminate\Database\Eloquent\ModelNotFoundException` exception if no matching model can be found in the collection:

```php
$users = User::all();

$user = $users->findOrFail(1);
```

<a name="method-fresh"></a>
#### `fresh($with = [])`

The `fresh` method retrieves a fresh instance of each model in the collection from the database. In addition, any specified relationships will be eager loaded:

```php
$users = $users->fresh();

$users = $users->fresh('comments');
```

<a name="method-intersect"></a>
#### `intersect($items)`

The `intersect` method returns all of the models that are also present in the given collection:

```php
use App\Models\User;

$users = $users->intersect(User::whereIn('id', [1, 2, 3])->get());
```

<a name="method-load"></a>
#### `load($relations)`

The `load` method eager loads the given relationships for all models in the collection:

```php
$users->load(['comments', 'posts']);

$users->load('comments.author');

$users->load(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);
```

<a name="method-loadMissing"></a>
#### `loadMissing($relations)`

The `loadMissing` method eager loads the given relationships for all models in the collection if the relationships are not already loaded:

```php
$users->loadMissing(['comments', 'posts']);

$users->loadMissing('comments.author');

$users->loadMissing(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);
```

<a name="method-modelKeys"></a>
#### `modelKeys()`

The `modelKeys` method returns the primary keys for all models in the collection:

```php
$users->modelKeys();

// [1, 2, 3, 4, 5]
```

<a name="method-makeVisible"></a>
#### `makeVisible($attributes)`

The `makeVisible` method [makes attributes visible](/docs/eloquent-serialization#hiding-attributes-from-json) that are typically "hidden" on each model in the collection:

```php
$users = $users->makeVisible(['address', 'phone_number']);
```

<a name="method-makeHidden"></a>
#### `makeHidden($attributes)`

The `makeHidden` method [hides attributes](/docs/eloquent-serialization#hiding-attributes-from-json) that are typically "visible" on each model in the collection:

```php
$users = $users->makeHidden(['address', 'phone_number']);
```

<a name="method-only"></a>
#### `only($keys)`

The `only` method returns all of the models that have the given primary keys:

```php
$users = $users->only([1, 2, 3]);
```

<a name="method-partition"></a>
#### `partition`

The `partition` method returns an instance of `Illuminate\Support\Collection` containing `Illuminate\Database\Eloquent\Collection` collection instances:

```php
$partition = $users->partition(fn ($user) => $user->age > 18);

dump($partition::class);    // Illuminate\Support\Collection
dump($partition[0]::class); // Illuminate\Database\Eloquent\Collection
dump($partition[1]::class); // Illuminate\Database\Eloquent\Collection
```

<a name="method-setAppends"></a>
#### `setAppends($attributes)`

The `setAppends` method temporarily overrides all of the [appended attributes](/docs/eloquent-serialization#appending-values-to-json) on each model in the collection:

```php
$users = $users->setAppends(['is_admin']);
```

<a name="method-setVisible"></a>
#### `setVisible($attributes)`

The `setVisible` method [temporarily overrides](/docs/eloquent-serialization#temporarily-modifying-attribute-visibility) all of the visible attributes on each model in the collection:

```php
$users = $users->setVisible(['id', 'name']);
```

<a name="method-setHidden"></a>
#### `setHidden($attributes)`

The `setHidden` method [temporarily overrides](/docs/eloquent-serialization#temporarily-modifying-attribute-visibility) all of the hidden attributes on each model in the collection:

```php
$users = $users->setHidden(['email', 'password', 'remember_token']);
```

<a name="method-toquery"></a>
#### `toQuery()`

The `toQuery` method returns an Eloquent query builder instance containing a `whereIn` constraint on the collection model's primary keys:

```php
use App\Models\User;

$users = User::where('status', 'VIP')->get();

$users->toQuery()->update([
    'status' => 'Administrator',
]);
```

<a name="method-unique"></a>
#### `unique($key = null, $strict = false)`

The `unique` method returns all of the unique models in the collection. Any models with the same primary key as another model in the collection are removed:

```php
$users = $users->unique();
```

<a name="method-withoutAppends"></a>
#### `withoutAppends($attributes)`

The `withoutAppends` method temporarily removes all of the [appended attributes](/docs/eloquent-serialization#appending-values-to-json) on each model in the collection:

```php
$users = $users->withoutAppends();
```

<a name="custom-collections"></a>
## 自訂集合 (Custom Collections)

若你想對給定模型量稱一個自訂 `Collection` 物件，你可以在你的模型上加上 `CollectedBy` attribute：

```php
<?php

namespace App\Models;

use App\Support\UserCollection;
use Illuminate\Database\Eloquent\Attributes\CollectedBy;
use Illuminate\Database\Eloquent\Model;

#[CollectedBy(UserCollection::class)]
class User extends Model
{
    // ...
}
```

Alternatively, you may define a `newCollection` method on your model:

```php
<?php

namespace App\Models;

use App\Support\UserCollection;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
     * Create a new Eloquent Collection instance.
     *
     * @param  array<int, \Illuminate\Database\Eloquent\Model>  $models
     * @return \Illuminate\Database\Eloquent\Collection<int, \Illuminate\Database\Eloquent\Model>
     */
    public function newCollection(array $models = []): Collection
    {
        $collection = new UserCollection($models);

        if (Model::isAutomaticallyEagerLoadingRelationships()) {
            $collection->withRelationshipAutoloading();
        }

        return $collection;
    }
}
```

Once you have defined a `newCollection` method or added the `CollectedBy` attribute to your model, you will receive an instance of your custom collection anytime Eloquent would normally return an `Illuminate\Database\Eloquent\Collection` instance.

If you would like to use a custom collection for every model in your application, you should define the `newCollection` method on a base model class that is extended by all of your application's models.
