---
title: "並行 (Concurrency)"
description: Laravel Concurrency 提供了並行執行任務的便利 API
---

- [介紹](#introduction)
- [執行並行任務](#running-concurrent-tasks)
- [延遲並行任務](#deferring-concurrent-tasks)

<a name="introduction"></a>
## 介紹

有時您可能需要執行多個彼此不相依的慢速任務。在許多情況下，並行執行這些任務可以實現顯著的效能提升。Laravel 的 `Concurrency` facade 提供了一個簡單、方便的 API 來並行執行 closures。

<a name="how-it-works"></a>
#### 運作方式

Laravel 透過序列化給定的 closures 並將它們發送到隱藏的 Artisan CLI 命令來實現並行，該命令在其自己的 PHP process 中反序列化 closures 並呼叫它。在 closure 被呼叫後，結果值會被序列化回父 process。

`Concurrency` facade 支援三種驅動程式：`process`（預設）、`fork` 和 `sync`。

`fork` 驅動程式比預設的 `process` 驅動程式提供更好的效能，但它只能在 PHP 的 CLI 環境中使用，因為 PHP 不支援在 Web 請求期間進行 fork。在使用 `fork` 驅動程式之前，您需要安裝 `spatie/fork` 套件：

```shell
composer require spatie/fork
```

`sync` 驅動程式主要在測試期間有用，當您想要停用所有並行功能並在父 process 中依序執行給定的 closures 時。

<a name="running-concurrent-tasks"></a>
## 執行並行任務

要執行並行任務，您可以呼叫 `Concurrency` facade 的 `run` 方法。`run` 方法接受一個 closures 陣列，這些 closures 應該在子 PHP processes 中同時執行：

```php
use Illuminate\Support\Facades\Concurrency;
use Illuminate\Support\Facades\DB;

[$userCount, $orderCount] = Concurrency::run([
    fn () => DB::table('users')->count(),
    fn () => DB::table('orders')->count(),
]);
```

要使用特定的驅動程式，您可以使用 `driver` 方法：

```php
$results = Concurrency::driver('fork')->run(...);
```

或者，要變更預設的並行驅動程式，您應該透過 `config:publish` Artisan 命令發布 `concurrency` 設定檔，並更新檔案中的 `default` 選項：

```shell
php artisan config:publish concurrency
```

<a name="deferring-concurrent-tasks"></a>
## 延遲並行任務

如果您想並行執行一個 closures 陣列，但對這些 closures 回傳的結果不感興趣，您應該考慮使用 `defer` 方法。當呼叫 `defer` 方法時，給定的 closures 不會立即執行。相反，Laravel 會在 HTTP response 發送給使用者後並行執行這些 closures：

```php
use App\Services\Metrics;
use Illuminate\Support\Facades\Concurrency;

Concurrency::defer([
    fn () => Metrics::report('users'),
    fn () => Metrics::report('orders'),
]);
```
