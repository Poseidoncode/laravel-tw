---
title: Redis
description: Redis 是一個開源的進階鍵值儲存系統
---

# Redis

- [簡介 (Introduction)](#introduction)
- [設定 (Configuration)](#configuration)
  - [叢集 (Clusters)](#clusters)
  - [Predis](#predis)
  - [PhpRedis](#phpredis)
- [與 Redis 互動 (Interacting With Redis)](#interacting-with-redis)
  - [事務 (Transactions)](#transactions)
  - [管線指令 (Pipelining Commands)](#pipelining-commands)
- [發布 / 訂閱 (Pub / Sub)](#pubsub)

<a name="introduction"></a>
## 簡介 (Introduction)

[Redis](https://redis.io) 是一個開源的進階鍵值儲存系統。它通常被稱為資料結構伺服器，因為鍵可以包含[字串](https://redis.io/docs/latest/develop/data-types/strings/)、[雜湊](https://redis.io/docs/latest/develop/data-types/hashes/)、[列表](https://redis.io/docs/latest/develop/data-types/lists/)、[集合](https://redis.io/docs/latest/develop/data-types/sets/)和[有序集合](https://redis.io/docs/latest/develop/data-types/sorted-sets/)。

在 Laravel 中使用 Redis 之前，我們建議你透過 PECL 安裝並使用 [PhpRedis](https://github.com/phpredis/phpredis) PHP 擴充套件。與「使用者空間」PHP 套件相比，此擴充套件的安裝更加複雜，但對於大量使用 Redis 的應用程式可能會帶來更好的效能。如果你使用 [Laravel Sail](/docs/sail)，這個擴充套件已經安裝在你的應用程式 Docker 容器中。

如果你無法安裝 PhpRedis 擴充套件，可以透過 Composer 安裝 `predis/predis` 套件。Predis 是一個完全用 PHP 編寫的 Redis 客戶端，不需要任何額外的擴充套件：

```shell
composer require predis/predis
```

<a name="configuration"></a>
## 設定 (Configuration)

你可以透過 `config/database.php` 設定檔來設定應用程式的 Redis 設定。在此檔案中，你會看到一個 `redis` 陣列，其中包含應用程式使用的 Redis 伺服器：

```php
'redis' => [

    'client' => env('REDIS_CLIENT', 'phpredis'),

    'options' => [
        'cluster' => env('REDIS_CLUSTER', 'redis'),
        'prefix' => env('REDIS_PREFIX', Str::slug(env('APP_NAME', 'laravel'), '_').'_database_'),
    ],

    'default' => [
        'url' => env('REDIS_URL'),
        'host' => env('REDIS_HOST', '127.0.0.1'),
        'username' => env('REDIS_USERNAME'),
        'password' => env('REDIS_PASSWORD'),
        'port' => env('REDIS_PORT', '6379'),
        'database' => env('REDIS_DB', '0'),
    ],

    'cache' => [
        'url' => env('REDIS_URL'),
        'host' => env('REDIS_HOST', '127.0.0.1'),
        'username' => env('REDIS_USERNAME'),
        'password' => env('REDIS_PASSWORD'),
        'port' => env('REDIS_PORT', '6379'),
        'database' => env('REDIS_CACHE_DB', '1'),
    ],

],
```

設定檔中定義的每個 Redis 伺服器都必須有名稱、主機和連接埠，除非你定義了單一 URL 來代表 Redis 連線：

```php
'redis' => [

    'client' => env('REDIS_CLIENT', 'phpredis'),

    'options' => [
        'cluster' => env('REDIS_CLUSTER', 'redis'),
        'prefix' => env('REDIS_PREFIX', Str::slug(env('APP_NAME', 'laravel'), '_').'_database_'),
    ],

    'default' => [
        'url' => 'tcp://127.0.0.1:6379?database=0',
    ],

    'cache' => [
        'url' => 'tls://user:password@127.0.0.1:6380?database=1',
    ],

],
```

<a name="configuring-the-connection-scheme"></a>
#### 設定連線協定 (Configuring the Connection Scheme)

預設情況下，Redis 客戶端在連接到 Redis 伺服器時將使用 `tcp` 協定；但是，你可以透過在 Redis 伺服器的設定陣列中指定 `scheme` 設定選項來使用 TLS / SSL 加密：

```php
'default' => [
    'scheme' => 'tls',
    'url' => env('REDIS_URL'),
    'host' => env('REDIS_HOST', '127.0.0.1'),
    'username' => env('REDIS_USERNAME'),
    'password' => env('REDIS_PASSWORD'),
    'port' => env('REDIS_PORT', '6379'),
    'database' => env('REDIS_DB', '0'),
],
```

<a name="clusters"></a>
### 叢集 (Clusters)

如果你的應用程式使用 Redis 伺服器叢集，你應該在 Redis 設定的 `clusters` 鍵中定義這些叢集。此設定鍵預設不存在，因此你需要在應用程式的 `config/database.php` 設定檔中建立它：

```php
'redis' => [

    'client' => env('REDIS_CLIENT', 'phpredis'),

    'options' => [
        'cluster' => env('REDIS_CLUSTER', 'redis'),
        'prefix' => env('REDIS_PREFIX', Str::slug(env('APP_NAME', 'laravel'), '_').'_database_'),
    ],

    'clusters' => [
        'default' => [
            [
                'url' => env('REDIS_URL'),
                'host' => env('REDIS_HOST', '127.0.0.1'),
                'username' => env('REDIS_USERNAME'),
                'password' => env('REDIS_PASSWORD'),
                'port' => env('REDIS_PORT', '6379'),
                'database' => env('REDIS_DB', '0'),
            ],
        ],
    ],

    // ...
],
```

預設情況下，Laravel 將使用原生 Redis 叢集，因為 `options.cluster` 設定值設為 `redis`。Redis 叢集是一個很好的預設選項，因為它可以優雅地處理故障轉移。

Laravel 在使用 Predis 時也支援客戶端分片。然而，客戶端分片不處理故障轉移；因此，它主要適用於從另一個主要資料儲存區可用的暫時快取資料。

如果你想使用客戶端分片而不是原生 Redis 叢集，可以在應用程式的 `config/database.php` 設定檔中移除 `options.cluster` 設定值：

```php
'redis' => [

    'client' => env('REDIS_CLIENT', 'phpredis'),

    'clusters' => [
        // ...
    ],

    // ...
],
```

<a name="predis"></a>
### Predis

如果你想讓應用程式透過 Predis 套件與 Redis 互動，應該確保 `REDIS_CLIENT` 環境變數的值是 `predis`：

```php
'redis' => [

    'client' => env('REDIS_CLIENT', 'predis'),

    // ...
],
```

除了預設的設定選項外，Predis 還支援可為每個 Redis 伺服器定義的額外[連線參數](https://github.com/nrk/predis/wiki/Connection-Parameters)。若要使用這些額外的設定選項，請將它們新增到應用程式 `config/database.php` 設定檔中的 Redis 伺服器設定中：

```php
'default' => [
    'url' => env('REDIS_URL'),
    'host' => env('REDIS_HOST', '127.0.0.1'),
    'username' => env('REDIS_USERNAME'),
    'password' => env('REDIS_PASSWORD'),
    'port' => env('REDIS_PORT', '6379'),
    'database' => env('REDIS_DB', '0'),
    'read_write_timeout' => 60,
],
```

<a name="phpredis"></a>
### PhpRedis

預設情況下，Laravel 將使用 PhpRedis 擴充套件與 Redis 通訊。Laravel 用於與 Redis 通訊的客戶端由 `redis.client` 設定選項的值決定，該值通常反映 `REDIS_CLIENT` 環境變數的值：

```php
'redis' => [

    'client' => env('REDIS_CLIENT', 'phpredis'),

    // ...
],
```

除了預設的設定選項外，PhpRedis 還支援以下額外的連線參數：`name`、`persistent`、`persistent_id`、`prefix`、`read_timeout`、`retry_interval`、`max_retries`、`backoff_algorithm`、`backoff_base`、`backoff_cap`、`timeout` 和 `context`。你可以將這些選項中的任何一個新增到 `config/database.php` 設定檔中的 Redis 伺服器設定中：

```php
'default' => [
    'url' => env('REDIS_URL'),
    'host' => env('REDIS_HOST', '127.0.0.1'),
    'username' => env('REDIS_USERNAME'),
    'password' => env('REDIS_PASSWORD'),
    'port' => env('REDIS_PORT', '6379'),
    'database' => env('REDIS_DB', '0'),
    'read_timeout' => 60,
    'context' => [
        // 'auth' => ['username', 'secret'],
        // 'stream' => ['verify_peer' => false],
    ],
],
```

<a name="retry-and-backoff-configuration"></a>
#### 重試與退避設定 (Retry and Backoff Configuration)

`retry_interval`、`max_retries`、`backoff_algorithm`、`backoff_base` 和 `backoff_cap` 選項可用於設定 PhpRedis 客戶端應如何嘗試重新連接到 Redis 伺服器。支援以下退避演算法：`default`、`decorrelated_jitter`、`equal_jitter`、`exponential`、`uniform` 和 `constant`：

```php
'default' => [
    'url' => env('REDIS_URL'),
    'host' => env('REDIS_HOST', '127.0.0.1'),
    'username' => env('REDIS_USERNAME'),
    'password' => env('REDIS_PASSWORD'),
    'port' => env('REDIS_PORT', '6379'),
    'database' => env('REDIS_DB', '0'),
    'max_retries' => env('REDIS_MAX_RETRIES', 3),
    'backoff_algorithm' => env('REDIS_BACKOFF_ALGORITHM', 'decorrelated_jitter'),
    'backoff_base' => env('REDIS_BACKOFF_BASE', 100),
    'backoff_cap' => env('REDIS_BACKOFF_CAP', 1000),
],
```

<a name="unix-socket-connections"></a>
#### Unix Socket 連線 (Unix Socket Connections)

Redis 連線也可以設定為使用 Unix Socket 而不是 TCP。這可以透過消除 TCP 開銷來提高連接到與應用程式位於同一伺服器上的 Redis 實例的效能。若要設定 Redis 使用 Unix Socket，請將 `REDIS_HOST` 環境變數設為 Redis Socket 的路徑，並將 `REDIS_PORT` 環境變數設為 `0`：

```env
REDIS_HOST=/run/redis/redis.sock
REDIS_PORT=0
```

<a name="phpredis-serialization"></a>
#### PhpRedis 序列化與壓縮 (PhpRedis Serialization and Compression)

PhpRedis 擴充套件也可以設定為使用各種序列化器和壓縮演算法。這些演算法可以透過 Redis 設定的 `options` 陣列進行設定：

```php
'redis' => [

    'client' => env('REDIS_CLIENT', 'phpredis'),

    'options' => [
        'cluster' => env('REDIS_CLUSTER', 'redis'),
        'prefix' => env('REDIS_PREFIX', Str::slug(env('APP_NAME', 'laravel'), '_').'_database_'),
        'serializer' => Redis::SERIALIZER_MSGPACK,
        'compression' => Redis::COMPRESSION_LZ4,
    ],

    // ...
],
```

目前支援的序列化器包括：`Redis::SERIALIZER_NONE`（預設）、`Redis::SERIALIZER_PHP`、`Redis::SERIALIZER_JSON`、`Redis::SERIALIZER_IGBINARY` 和 `Redis::SERIALIZER_MSGPACK`。

支援的壓縮演算法包括：`Redis::COMPRESSION_NONE`（預設）、`Redis::COMPRESSION_LZF`、`Redis::COMPRESSION_ZSTD` 和 `Redis::COMPRESSION_LZ4`。

<a name="interacting-with-redis"></a>
## 與 Redis 互動 (Interacting With Redis)

你可以透過呼叫 `Redis` [Facade](/docs/facades) 上的各種方法來與 Redis 互動。`Redis` Facade 支援動態方法，這意味著你可以在 Facade 上呼叫任何 [Redis 指令](https://redis.io/commands)，該指令將直接傳遞給 Redis。在此範例中，我們將透過在 `Redis` Facade 上呼叫 `get` 方法來呼叫 Redis `GET` 指令：

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Support\Facades\Redis;
use Illuminate\View\View;

class UserController extends Controller
{
    /**
     * 顯示給定使用者的個人檔案。
     */
    public function show(string $id): View
    {
        return view('user.profile', [
            'user' => Redis::get('user:profile:'.$id)
        ]);
    }
}
```

如上所述，你可以在 `Redis` Facade 上呼叫任何 Redis 指令。Laravel 使用魔術方法將指令傳遞給 Redis 伺服器。如果 Redis 指令需要引數，你應該將這些引數傳遞給 Facade 的對應方法：

```php
use Illuminate\Support\Facades\Redis;

Redis::set('name', 'Taylor');

$values = Redis::lrange('names', 5, 10);
```

或者，你可以使用 `Redis` Facade 的 `command` 方法將指令傳遞給伺服器，該方法接受指令名稱作為第一個引數，並接受一個值陣列作為第二個引數：

```php
$values = Redis::command('lrange', ['name', 5, 10]);
```

<a name="using-multiple-redis-connections"></a>
#### 使用多個 Redis 連線 (Using Multiple Redis Connections)

你的應用程式的 `config/database.php` 設定檔允許你定義多個 Redis 連線/伺服器。你可以使用 `Redis` Facade 的 `connection` 方法取得特定 Redis 連線的連線：

```php
$redis = Redis::connection('connection-name');
```

若要取得預設 Redis 連線的實例，你可以不帶任何額外引數呼叫 `connection` 方法：

```php
$redis = Redis::connection();
```

<a name="transactions"></a>
### 事務 (Transactions)

`Redis` Facade 的 `transaction` 方法為 Redis 的原生 `MULTI` 和 `EXEC` 指令提供了一個方便的包裝。`transaction` 方法接受一個閉包作為其唯一引數。此閉包將接收一個 Redis 連線實例，並可以向此實例發送任何它想要的指令。閉包內發送的所有 Redis 指令將在單一原子事務中執行：

```php
use Redis;
use Illuminate\Support\Facades;

Facades\Redis::transaction(function (Redis $redis) {
    $redis->incr('user_visits', 1);
    $redis->incr('total_visits', 1);
});
```

> [!WARNING]
> 在定義 Redis 事務時，你可能無法從 Redis 連線中取得任何值。請記住，你的事務是作為單一原子操作執行的，並且該操作直到整個閉包完成執行其指令後才會執行。

#### Lua 腳本 (Lua Scripts)

`eval` 方法提供了另一種在單一原子操作中執行多個 Redis 指令的方法。然而，`eval` 方法的好處是能夠在該操作期間與 Redis 鍵值互動並檢查它們。Redis 腳本是用 [Lua 程式語言](https://www.lua.org) 編寫的。

`eval` 方法一開始可能看起來有點可怕，但我們將透過一個基本範例來打破僵局。`eval` 方法需要幾個引數。首先，你應該將 Lua 腳本（作為字串）傳遞給方法。其次，你應該傳遞腳本互動的鍵數量（作為整數）。第三，你應該傳遞這些鍵的名稱。最後，你可以傳遞你需要在腳本中存取的任何其他額外引數。

在此範例中，我們將遞增一個計數器，檢查其新值，如果第一個計數器的值大於五，則遞增第二個計數器。最後，我們將傳回第一個計數器的值：

```php
$value = Redis::eval(<<<'LUA'
    local counter = redis.call("incr", KEYS[1])

    if counter > 5 then
        redis.call("incr", KEYS[2])
    end

    return counter
LUA, 2, 'first-counter', 'second-counter');
```

> [!WARNING]
> 請參閱 [Redis 文件](https://redis.io/commands/eval) 以取得有關 Redis 腳本的更多資訊。

<a name="pipelining-commands"></a>
### 管線指令 (Pipelining Commands)

有時你可能需要執行數十個 Redis 指令。與其為每個指令對 Redis 伺服器進行網路傳輸，你可以使用 `pipeline` 方法。`pipeline` 方法接受一個引數：一個接收 Redis 實例的閉包。你可以向此 Redis 實例發送所有指令，它們將同時發送到 Redis 伺服器以減少對伺服器的網路傳輸。指令仍將按照發送的順序執行：

```php
use Redis;
use Illuminate\Support\Facades;

Facades\Redis::pipeline(function (Redis $pipe) {
    for ($i = 0; $i < 1000; $i++) {
        $pipe->set("key:$i", $i);
    }
});
```

<a name="pubsub"></a>
## 發布 / 訂閱 (Pub / Sub)

Laravel 為 Redis 的 `publish` 和 `subscribe` 指令提供了一個方便的介面。這些 Redis 指令允許你在給定的「頻道」上監聽訊息。你可以從另一個應用程式發布訊息到頻道，甚至使用另一種程式語言，從而實現應用程式和程序之間的輕鬆通訊。

首先，讓我們使用 `subscribe` 方法設定一個頻道監聽器。由於呼叫 `subscribe` 方法會開始一個長時間執行的程序，我們將此方法呼叫放在一個 [Artisan 指令](/docs/artisan) 中：

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Redis;

class RedisSubscribe extends Command
{
    /**
     * 控制台指令的名稱和簽章。
     *
     * @var string
     */
    protected $signature = 'redis:subscribe';

    /**
     * 控制台指令的描述。
     *
     * @var string
     */
    protected $description = '訂閱 Redis 頻道';

    /**
     * 執行控制台指令。
     */
    public function handle(): void
    {
        Redis::subscribe(['test-channel'], function (string $message) {
            echo $message;
        });
    }
}
```

現在我們可以使用 `publish` 方法向頻道發布訊息：

```php
use Illuminate\Support\Facades\Redis;

Route::get('/publish', function () {
    // ...

    Redis::publish('test-channel', json_encode([
        'name' => 'Adam Wathan'
    ]));
});
```

<a name="wildcard-subscriptions"></a>
#### 萬用字元訂閱 (Wildcard Subscriptions)

使用 `psubscribe` 方法，你可以訂閱萬用字元頻道，這對於捕獲所有頻道上的所有訊息可能很有用。頻道名稱將作為第二個引數傳遞給提供的閉包：

```php
Redis::psubscribe(['*'], function (string $message, string $channel) {
    echo $message;
});

Redis::psubscribe(['users.*'], function (string $message, string $channel) {
    echo $message;
});
```
