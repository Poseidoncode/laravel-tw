---
title: "Cashier Paddle"
description: Laravel Cashier Paddle 提供 Paddle 訂閱計費服務的整合
---

<a name="introduction"></a>
## 簡介 (Introduction)

> [!WARNING]
> 本文件適用於 Cashier Paddle 2.x 與 Paddle Billing 的整合。如果你仍在使用 Paddle Classic，應使用 [Cashier Paddle 1.x](https://github.com/laravel/cashier-paddle/tree/1.x)。

[Laravel Cashier Paddle](https://github.com/laravel/cashier-paddle) 為 [Paddle](https://paddle.com) 的訂閱計費服務提供了一個語意化且流暢的介面。它幾乎處理了所有你害怕編寫的訂閱計費樣板程式碼。除了基本的訂閱管理外，Cashier 還可以處理：更換訂閱、訂閱「數量」、暫停訂閱、取消寬限期等等。

在深入研究 Cashier Paddle 之前，我們建議你也閱讀 Paddle 的 [概念指南](https://developer.paddle.com/concepts/overview) 和 [API 文件](https://developer.paddle.com/api-reference/overview)。

<a name="upgrading-cashier"></a>
## 升級 Cashier (Upgrading Cashier)

升級到新版本的 Cashier 時，請務必仔細閱讀 [升級指南](https://github.com/laravel/cashier-paddle/blob/master/UPGRADE.md)。

<a name="installation"></a>
## 安裝 (Installation)

首先，使用 Composer 套件管理器安裝 Paddle 的 Cashier 套件：

```shell
composer require laravel/cashier-paddle
```

接下來，你應該使用 `vendor:publish` Artisan 指令發布 Cashier 的遷移檔案：

```shell
php artisan vendor:publish --tag="cashier-migrations"
```

然後，你應該執行應用程式的資料庫遷移。Cashier 遷移將建立一個新的 `customers` 資料表。此外，還將建立新的 `subscriptions` 和 `subscription_items` 資料表來儲存所有客戶的訂閱。最後，將建立一個新的 `transactions` 資料表來儲存與你的客戶相關的所有 Paddle 交易：

```shell
php artisan migrate
```

> [!WARNING]
> 為了確保 Cashier 正確處理所有 Paddle 事件，請記得 [設定 Cashier 的 Webhook 處理](#handling-paddle-webhooks)。

<a name="paddle-sandbox"></a>
### Paddle Sandbox

在本地和預備環境開發期間，你應該 [註冊一個 Paddle Sandbox 帳號](https://sandbox-login.paddle.com/signup)。此帳號將為你提供一個沙盒環境來測試和開發你的應用程式，而無需進行實際付款。你可以使用 Paddle 的 [測試卡號](https://developer.paddle.com/concepts/payment-methods/credit-debit-card#test-payment-method) 來模擬各種付款情境。

使用 Paddle Sandbox 環境時，你應該在應用程式的 `.env` 檔案中將 `PADDLE_SANDBOX` 環境變數設定為 `true`：

```ini
PADDLE_SANDBOX=true
```

完成應用程式開發後，你可以 [申請 Paddle 供應商帳號](https://paddle.com)。在你的應用程式投入生產環境之前，Paddle 需要核准你的應用程式網域。

<a name="configuration"></a>
## 設定 (Configuration)

<a name="billable-model"></a>
### Billable 模型 (Billable Model)

在使用 Cashier 之前，你必須將 `Billable` trait 新增到你的使用者模型定義中。這個 trait 提供了各種方法，讓你執行常見的計費任務，例如建立訂閱和更新付款方式資訊：

```php
use Laravel\Paddle\Billable;

class User extends Authenticatable
{
    use Billable;
}
```

如果你有非使用者的計費實體，你也可以將該 trait 新增到這些類別中：

```php
use Illuminate\Database\Eloquent\Model;
use Laravel\Paddle\Billable;

class Team extends Model
{
    use Billable;
}
```

<a name="api-keys"></a>
### API Keys

接下來，你應該在應用程式的 `.env` 檔案中設定你的 Paddle 金鑰。你可以從 Paddle 控制面板取得你的 Paddle API 金鑰：

```ini
PADDLE_CLIENT_SIDE_TOKEN=your-paddle-client-side-token
PADDLE_API_KEY=your-paddle-api-key
PADDLE_RETAIN_KEY=your-paddle-retain-key
PADDLE_WEBHOOK_SECRET="your-paddle-webhook-secret"
PADDLE_SANDBOX=true
```

當你使用 [Paddle 的 Sandbox 環境](#paddle-sandbox) 時，`PADDLE_SANDBOX` 環境變數應設定為 `true`。如果你將應用程式部署到生產環境並使用 Paddle 的即時供應商環境，則 `PADDLE_SANDBOX` 變數應設定為 `false`。

`PADDLE_RETAIN_KEY` 是選用的，只有在你使用 Paddle 與 [Retain](https://developer.paddle.com/concepts/retain/overview) 時才需要設定。

<a name="paddle-js"></a>
### Paddle JS

Paddle 依賴其自己的 JavaScript 函式庫來啟動 Paddle 結帳小工具。你可以透過將 `@paddleJS` Blade 指令放置在應用程式版面配置的結束 `</head>` 標籤之前來載入 JavaScript 函式庫：

```blade
<head>
    ...

    @paddleJS
</head>
```

<a name="currency-configuration"></a>
### 貨幣設定 (Currency Configuration)

你可以指定一個語系，用於在發票上顯示貨幣值時進行格式化。Cashier 內部使用 [PHP 的 `NumberFormatter` 類別](https://www.php.net/manual/en/class.numberformatter.php) 來設定貨幣語系：

```ini
CASHIER_CURRENCY_LOCALE=nl_BE
```

> [!WARNING]
> 為了使用 `en` 以外的語系，請確保你的伺服器上已安裝並設定 `ext-intl` PHP 擴充功能。

<a name="overriding-default-models"></a>
### 覆寫預設模型 (Overriding Default Models)

你可以自由擴充 Cashier 內部使用的模型，方法是定義你自己的模型並擴充相應的 Cashier 模型：

```php
use Laravel\Paddle\Subscription as CashierSubscription;

class Subscription extends CashierSubscription
{
    // ...
}
```

定義模型後，你可以透過 `Laravel\Paddle\Cashier` 類別指示 Cashier 使用你的自訂模型。通常，你應該在應用程式的 `App\Providers\AppServiceProvider` 類別的 `boot` 方法中通知 Cashier 關於你的自訂模型：

```php
use App\Models\Cashier\Subscription;
use App\Models\Cashier\Transaction;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Cashier::useSubscriptionModel(Subscription::class);
    Cashier::useTransactionModel(Transaction::class);
}
```

<a name="quickstart"></a>
## 快速開始 (Quickstart)

<a name="quickstart-selling-products"></a>
### 銷售產品 (Selling Products)

> [!NOTE]
> 在使用 Paddle Checkout 之前，你應該在 Paddle 儀表板中定義具有固定價格的產品。此外，你應該 [設定 Paddle 的 Webhook 處理](#handling-paddle-webhooks)。

透過你的應用程式提供產品和訂閱計費可能會令人望而生畏。然而，感謝 Cashier 和 [Paddle 的 Checkout Overlay](https://developer.paddle.com/concepts/sell/overlay-checkout)，你可以輕鬆建立現代化、強大的付款整合。

為了向客戶收取非經常性、單次收費產品的費用，我們將利用 Cashier 透過 Paddle 的 Checkout Overlay 向客戶收費，他們將在其中提供付款詳細資訊並確認購買。透過 Checkout Overlay 完成付款後，客戶將被重新導向到你在應用程式中選擇的成功 URL：

```php
use Illuminate\Http\Request;

Route::get('/buy', function (Request $request) {
    $checkout = $request->user()->checkout('pri_deluxe_album')
        ->returnTo(route('dashboard'));

    return view('buy', ['checkout' => $checkout]);
})->name('checkout');
```

如上例所示，我們將利用 Cashier 提供的 `checkout` 方法來建立一個 checkout 物件，以便為給定的「價格識別碼」向客戶顯示 Paddle Checkout Overlay。使用 Paddle 時，「價格」是指 [特定產品的定義價格](https://developer.paddle.com/build/products/create-products-prices)。

如有必要，`checkout` 方法將自動在 Paddle 中建立一個客戶，並將該 Paddle 客戶記錄連接到你應用程式資料庫中的相應使用者。完成結帳 session 後，客戶將被重新導向到專用的成功頁面，你可以在該頁面向客戶顯示資訊訊息。

在 `buy` 視圖中，我們將包含一個按鈕來顯示 Checkout Overlay。Cashier Paddle 包含 `paddle-button` Blade 元件；但是，你也可以 [手動渲染 overlay checkout](#manually-rendering-an-overlay-checkout)：

```html
<x-paddle-button :checkout="$checkout" className="px-8 py-4">
  Buy Product
</x-paddle-button>
```

<a name="providing-meta-data-to-paddle-checkout"></a>
#### 提供 Meta Data 給 Paddle Checkout (Providing Meta Data To Paddle Checkout)

銷售產品時，通常會透過應用程式定義的 `Cart` 和 `Order` 模型來追蹤已完成的訂單和購買的產品。當將客戶重新導向到 Paddle 的 Checkout Overlay 以完成購買時，你可能需要提供現有的訂單識別碼，以便在客戶被重新導向回你的應用程式時，將已完成的購買與相應的訂單關聯起來。

為此，你可以向 `checkout` 方法提供一個自訂資料陣列。讓我們想像一下，當使用者開始結帳流程時，我們的應用程式中會建立一個待處理的 `Order`。請記住，此範例中的 `Cart` 和 `Order` 模型僅供說明，並非由 Cashier 提供。你可以根據自己應用程式的需求自由實作這些概念：

```php
use App\Models\Cart;
use App\Models\Order;
use Illuminate\Http\Request;

Route::get('/cart/{cart}/checkout', function (Request $request, Cart $cart) {
    $order = Order::create([
        'cart_id' => $cart->id,
        'price_ids' => $cart->price_ids,
        'status' => 'incomplete',
    ]);

    $checkout = $request->user()->checkout($order->price_ids)
        ->customData(['order_id' => $order->id]);

    return view('billing', ['checkout' => $checkout]);
})->name('checkout');
```

如上例所示，當使用者開始結帳流程時，我們將向 `checkout` 方法提供所有購物車 / 訂單相關的 Paddle 價格識別碼。當然，你的應用程式負責在客戶新增項目時將這些項目與「購物車」或訂單關聯起來。我們還透過 `customData` 方法將訂單 ID 提供給 Paddle Checkout Overlay。

當然，一旦客戶完成結帳流程，你可能會希望將訂單標記為「已完成」。為此，你可以監聽 Paddle 發送的 webhook 並由 Cashier 透過事件引發，以將訂單資訊儲存在你的資料庫中。

首先，監聽 Cashier 發送的 `TransactionCompleted` 事件。通常，你應該在應用程式的 `AppServiceProvider` 的 `boot` 方法中註冊事件監聽器：

```php
use App\Listeners\CompleteOrder;
use Illuminate\Support\Facades\Event;
use Laravel\Paddle\Events\TransactionCompleted;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Event::listen(TransactionCompleted::class, CompleteOrder::class);
}
```

在此範例中，`CompleteOrder` 監聽器可能如下所示：

```php
namespace App\Listeners;

use App\Models\Order;
use Laravel\Paddle\Cashier;
use Laravel\Paddle\Events\TransactionCompleted;

class CompleteOrder
{
    /**
     * Handle the incoming Cashier webhook event.
     */
    public function handle(TransactionCompleted $event): void
    {
        $orderId = $event->payload['data']['custom_data']['order_id'] ?? null;

        $order = Order::findOrFail($orderId);

        $order->update(['status' => 'completed']);
    }
}
```

有關 [`transaction.completed` 事件包含的資料](https://developer.paddle.com/webhooks/transactions/transaction-completed) 的更多資訊，請參閱 Paddle 的文件。

<a name="quickstart-selling-subscriptions"></a>
### 銷售訂閱 (Selling Subscriptions)

> [!NOTE]
> 在使用 Paddle Checkout 之前，你應該在 Paddle 儀表板中定義具有固定價格的產品。此外，你應該 [設定 Paddle 的 Webhook 處理](#handling-paddle-webhooks)。

透過你的應用程式提供產品和訂閱計費可能會令人望而生畏。然而，感謝 Cashier 和 [Paddle 的 Checkout Overlay](https://developer.paddle.com/concepts/sell/overlay-checkout)，你可以輕鬆建立現代化、強大的付款整合。

要學習如何使用 Cashier 和 Paddle 的 Checkout Overlay 銷售訂閱，讓我們考慮一個簡單的訂閱服務情境，其中包含基本的月繳 (`price_basic_monthly`) 和年繳 (`price_basic_yearly`) 方案。這兩個價格可以在我們的 Paddle 儀表板中歸類為「Basic」產品 (`pro_basic`)。此外，我們的訂閱服務可能提供「Expert」方案作為 `pro_expert`。

首先，讓我們了解客戶如何訂閱我們的服務。當然，你可以想像客戶可能會點擊我們應用程式定價頁面上 Basic 方案的「訂閱」按鈕。此按鈕將為他們選擇的方案呼叫 Paddle Checkout Overlay。首先，讓我們透過 `checkout` 方法啟動一個結帳 session：

```php
use Illuminate\Http\Request;

Route::get('/subscribe', function (Request $request) {
    $checkout = $request->user()->checkout('price_basic_monthly')
        ->returnTo(route('dashboard'));

    return view('subscribe', ['checkout' => $checkout]);
})->name('subscribe');
```

在 `subscribe` 視圖中，我們將包含一個按鈕來顯示 Checkout Overlay。Cashier Paddle 包含 `paddle-button` Blade 元件；但是，你也可以 [手動渲染 overlay checkout](#manually-rendering-an-overlay-checkout)：

```html
<x-paddle-button :checkout="$checkout" className="px-8 py-4">
  Subscribe
</x-paddle-button>
```

現在，當點擊訂閱按鈕時，客戶將能夠輸入他們的付款詳細資訊並啟動他們的訂閱。要知道他們的訂閱何時實際開始（因為某些付款方式需要幾秒鐘來處理），你還應該 [設定 Cashier 的 Webhook 處理](#handling-paddle-webhooks)。

既然客戶可以開始訂閱，我們需要限制應用程式的某些部分，以便只有訂閱的使用者才能存取它們。當然，我們始終可以透過 Cashier 的 `Billable` trait 提供的 `subscribed` 方法來確定使用者的目前訂閱狀態：

```blade
@if ($user->subscribed())
    <p>You are subscribed.</p>
@endif
```

我們甚至可以輕鬆確定使用者是否訂閱了特定產品或價格：

```blade
@if ($user->subscribedToProduct('pro_basic'))
    <p>You are subscribed to our Basic product.</p>
@endif

@if ($user->subscribedToPrice('price_basic_monthly'))
    <p>You are subscribed to our monthly Basic plan.</p>
@endif
```

<a name="quickstart-building-a-subscribed-middleware"></a>
#### 建立訂閱 Middleware (Quickstart Building A Subscribed Middleware)

為了方便起見，你可能希望建立一個 [middleware](/docs/middleware) 來確定傳入的請求是否來自已訂閱的使用者。定義此 middleware 後，你可以輕鬆地將其指派給路由，以防止未訂閱的使用者存取該路由：

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class Subscribed
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (! $request->user()?->subscribed()) {
            // Redirect user to billing page and ask them to subscribe...
            return redirect('/subscribe');
        }

        return $next($request);
    }
}
```

定義 middleware 後，你可以將其指派給路由：

```php
use App\Http\Middleware\Subscribed;

Route::get('/dashboard', function () {
    // ...
})->middleware([Subscribed::class]);
```

<a name="quickstart-allowing-customers-to-manage-their-billing-plan"></a>
#### 允許客戶管理他們的計費方案 (Quickstart Allowing Customers To Manage Their Billing Plan)

當然，客戶可能希望將其訂閱方案變更為其他產品或「層級」。在上面的範例中，我們希望允許客戶將其方案從月繳訂閱變更為年繳訂閱。為此，你需要實作類似按鈕的東西，該按鈕導向以下路由：

```php
use Illuminate\Http\Request;

Route::put('/subscription/{price}/swap', function (Request $request, $price) {
    $user->subscription()->swap($price); // With "$price" being "price_basic_yearly" for this example.

    return redirect()->route('dashboard');
})->name('subscription.swap');
```

除了更換方案外，你還需要允許客戶取消訂閱。與更換方案一樣，提供一個導向以下路由的按鈕：

```php
use Illuminate\Http\Request;

Route::put('/subscription/cancel', function (Request $request, $price) {
    $user->subscription()->cancel();

    return redirect()->route('dashboard');
})->name('subscription.cancel');
```

現在，你的訂閱將在其計費週期結束時取消。

> [!NOTE]
> 只要你已設定 Cashier 的 Webhook 處理，Cashier 將透過檢查來自 Paddle 的傳入 Webhook 自動保持應用程式的 Cashier 相關資料庫資料表同步。因此，例如，當你透過 Paddle 的儀表板取消客戶的訂閱時，Cashier 將收到相應的 Webhook 並將應用程式資料庫中的訂閱標記為「已取消」。

<a name="checkout-sessions"></a>
## 結帳 Session (Checkout Sessions)

大多數向客戶收費的操作都是透過 Paddle 的 [Checkout Overlay 小工具](https://developer.paddle.com/build/checkout/build-overlay-checkout) 或利用 [inline checkout](https://developer.paddle.com/build/checkout/build-branded-inline-checkout) 使用「checkouts」執行的。

在使用 Paddle 處理結帳付款之前，你應該在 Paddle 結帳設定儀表板中定義應用程式的 [預設付款連結](https://developer.paddle.com/build/transactions/default-payment-link#set-default-link)。

<a name="overlay-checkout"></a>
### Overlay 結帳 (Overlay Checkout)

在顯示 Checkout Overlay 小工具之前，你必須使用 Cashier 產生一個結帳 session。結帳 session 將通知結帳小工具應執行的計費操作：

```php
use Illuminate\Http\Request;

Route::get('/buy', function (Request $request) {
    $checkout = $user->checkout('pri_34567')
        ->returnTo(route('dashboard'));

    return view('billing', ['checkout' => $checkout]);
});
```

Cashier 包含一個 `paddle-button` [Blade 元件](/docs/blade#components)。你可以將結帳 session 作為「prop」傳遞給此元件。然後，當點擊此按鈕時，將顯示 Paddle 的結帳小工具：

```html
<x-paddle-button :checkout="$checkout" className="px-8 py-4">
  Subscribe
</x-paddle-button>
```

預設情況下，這將使用 Paddle 的預設樣式顯示小工具。你可以透過將 [Paddle 支援的屬性](https://developer.paddle.com/paddlejs/html-data-attributes)（如 `data-theme='light'` 屬性）新增到元件來自訂小工具：

```html
<x-paddle-button :checkout="$checkout" className="px-8 py-4" data-theme="light">
  Subscribe
</x-paddle-button>
```

Paddle 結帳小工具是非同步的。一旦使用者在小工具中建立訂閱，Paddle 將向你的應用程式發送一個 webhook，以便你可以正確更新應用程式資料庫中的訂閱狀態。因此，正確 [設定 webhook](#handling-paddle-webhooks) 以適應 Paddle 的狀態變更非常重要。

> [!WARNING]
> 訂閱狀態變更後，接收相應 webhook 的延遲通常很短，但你應該在應用程式中考慮到這一點，即使用者的訂閱可能不會在完成結帳後立即生效。

<a name="manually-rendering-an-overlay-checkout"></a>
#### 手動渲染 Overlay Checkout (Manually Rendering An Overlay Checkout)

你也可以手動渲染 overlay checkout，而不使用 Laravel 內建的 Blade 元件。首先，[如前面的範例所示](#overlay-checkout) 產生結帳 session：

```php
use Illuminate\Http\Request;

Route::get('/buy', function (Request $request) {
    $checkout = $user->checkout('pri_34567')
        ->returnTo(route('dashboard'));

    return view('billing', ['checkout' => $checkout]);
});
```

接下來，你可以使用 Paddle.js 初始化結帳。在此範例中，我們將建立一個分配了 `paddle_button` 類別的連結。Paddle.js 將偵測此類別並在點擊連結時顯示 overlay checkout：

```blade
<?php
$items = $checkout->getItems();
$customer = $checkout->getCustomer();
$custom = $checkout->getCustomData();
?>

<a
    href='#!'
    className='paddle_button'
    data-items='{!! json_encode($items) !!}'
    @if ($customer) data-customer-id='{{ $customer->paddle_id }}' @endif
    @if ($custom) data-custom-data='{{ json_encode($custom) }}' @endif
    @if ($returnUrl = $checkout->getReturnUrl()) data-success-url='{{ $returnUrl }}' @endif
>
    Buy Product
</a>
```

<a name="inline-checkout"></a>
### Inline 結帳 (Inline Checkout)

如果你不想使用 Paddle 的「overlay」樣式結帳小工具，Paddle 也提供了內嵌顯示小工具的選項。雖然這種方法不允許你調整任何結帳的 HTML 欄位，但它允許你將小工具嵌入到你的應用程式中。

為了讓你輕鬆開始使用 inline checkout，Cashier 包含一個 `paddle-checkout` Blade 元件。首先，你應該 [產生一個結帳 session](#overlay-checkout)：

```php
use Illuminate\Http\Request;

Route::get('/buy', function (Request $request) {
    $checkout = $user->checkout('pri_34567')
        ->returnTo(route('dashboard'));

    return view('billing', ['checkout' => $checkout]);
});
```

然後，你可以將結帳 session 傳遞給元件的 `checkout` 屬性：

```blade
<x-paddle-checkout :checkout="$checkout" className="w-full" />
```

要調整 inline checkout 元件的高度，你可以將 `height` 屬性傳遞給 Blade 元件：

```blade
<x-paddle-checkout :checkout="$checkout" className="w-full" height="500" />
```

有關 inline checkout 自訂選項的更多詳細資訊，請參閱 Paddle 的 [Inline Checkout 指南](https://developer.paddle.com/build/checkout/build-branded-inline-checkout) 和 [可用的結帳設定](https://developer.paddle.com/build/checkout/set-up-checkout-default-settings)。

<a name="manually-rendering-an-inline-checkout"></a>
#### 手動渲染 Inline Checkout (Manually Rendering An Inline Checkout)

你也可以手動渲染 inline checkout，而不使用 Laravel 內建的 Blade 元件。首先，[如前面的範例所示](#inline-checkout) 產生結帳 session：

```php
use Illuminate\Http\Request;

Route::get('/buy', function (Request $request) {
    $checkout = $user->checkout('pri_34567')
        ->returnTo(route('dashboard'));

    return view('billing', ['checkout' => $checkout]);
});
```

接下來，你可以使用 Paddle.js 初始化結帳。在此範例中，我們將使用 [Alpine.js](https://github.com/alpinejs/alpine) 進行示範；但是，你可以根據自己的前端堆疊自由修改此範例：

```blade
<?php
$options = $checkout->options();

$options['settings']['frameTarget'] = 'paddle-checkout';
$options['settings']['frameInitialHeight'] = 366;
?>

<div className="paddle-checkout" x-data="{}" x-init="
    Paddle.Checkout.open(@json($options));
">
</div>
```

<a name="guest-checkouts"></a>
### 訪客結帳 (Guest Checkouts)

有時，你可能需要為不需要應用程式帳號的使用者建立結帳 session。為此，你可以使用 `guest` 方法：

```php
use Illuminate\Http\Request;
use Laravel\Paddle\Checkout;

Route::get('/buy', function (Request $request) {
    $checkout = Checkout::guest(['pri_34567'])
        ->returnTo(route('home'));

    return view('billing', ['checkout' => $checkout]);
});
```

然後，你可以將結帳 session 提供給 [Paddle 按鈕](#overlay-checkout) 或 [inline checkout](#inline-checkout) Blade 元件。

<a name="price-previews"></a>
## 價格預覽 (Price Previews)

Paddle 允許你自訂每種貨幣的價格，基本上允許你為不同國家/地區設定不同的價格。Cashier Paddle 允許你使用 `previewPrices` 方法取得所有這些價格。此方法接受你希望取得價格的價格 ID：

```php
use Laravel\Paddle\Cashier;

$prices = Cashier::previewPrices(['pri_123', 'pri_456']);
```

貨幣將根據請求的 IP 位址決定；但是，你可以選擇性地提供特定國家/地區以取得價格：

```php
use Laravel\Paddle\Cashier;

$prices = Cashier::previewPrices(['pri_123', 'pri_456'], ['address' => [
    'country_code' => 'BE',
    'postal_code' => '1234',
]]);
```

取得價格後，你可以隨意顯示它們：

```blade
<ul>
    @foreach ($prices as $price)
        <li>{{ $price->product['name'] }} - {{ $price->total() }}</li>
    @endforeach
</ul>
```

你也可以分別顯示小計價格和稅額：

```blade
<ul>
    @foreach ($prices as $price)
        <li>{{ $price->product['name'] }} - {{ $price->subtotal() }} (+ {{ $price->tax() }} tax)</li>
    @endforeach
</ul>
```

有關更多資訊，請 [查看 Paddle 關於價格預覽的 API 文件](https://developer.paddle.com/api-reference/pricing-preview/preview-prices)。

<a name="customer-price-previews"></a>
### 客戶價格預覽 (Customer Price Previews)

如果使用者已經是客戶，並且你想顯示適用於該客戶的價格，你可以直接從客戶實例取得價格：

```php
use App\Models\User;

$prices = User::find(1)->previewPrices(['pri_123', 'pri_456']);
```

Cashier 內部將使用使用者的客戶 ID 來取得其貨幣的價格。因此，例如，居住在美國的使用者將看到以美元為單位的價格，而居住在比利時的使用者將看到以歐元為單位的價格。如果找不到相符的貨幣，將使用產品的預設貨幣。你可以在 Paddle 控制面板中自訂產品或訂閱方案的所有價格。

<a name="price-discounts"></a>
### 折扣 (Discounts)

你也可以選擇顯示折扣後的價格。呼叫 `previewPrices` 方法時，透過 `discount_id` 選項提供折扣 ID：

```php
use Laravel\Paddle\Cashier;

$prices = Cashier::previewPrices(['pri_123', 'pri_456'], [
    'discount_id' => 'dsc_123'
]);
```

然後，顯示計算出的價格：

```blade
<ul>
    @foreach ($prices as $price)
        <li>{{ $price->product['name'] }} - {{ $price->total() }}</li>
    @endforeach
</ul>
```

<a name="customers"></a>
## 客戶 (Customers)

<a name="customer-defaults"></a>
### 客戶預設值 (Customer Defaults)

Cashier 允許你在建立結帳 session 時為客戶定義一些有用的預設值。設定這些預設值允許你預先填寫客戶的電子郵件地址和姓名，以便他們可以立即進入結帳小工具的付款部分。你可以透過覆寫 billable 模型上的以下方法來設定這些預設值：

```php
/**
 * Get the customer's name to associate with Paddle.
 */
public function paddleName(): string|null
{
    return $this->name;
}

/**
 * Get the customer's email address to associate with Paddle.
 */
public function paddleEmail(): string|null
{
    return $this->email;
}
```

這些預設值將用於 Cashier 中產生 [結帳 session](#checkout-sessions) 的每個操作。

<a name="retrieving-customers"></a>
### 取得客戶 (Retrieving Customers)

你可以使用 `Cashier::findBillable` 方法透過 Paddle 客戶 ID 取得客戶。此方法將回傳 billable 模型的實例：

```php
use Laravel\Paddle\Cashier;

$user = Cashier::findBillable($customerId);
```

<a name="creating-customers"></a>
### 建立客戶 (Creating Customers)

有時，你可能希望建立一個 Paddle 客戶而不開始訂閱。你可以使用 `createAsCustomer` 方法來完成此操作：

```php
$customer = $user->createAsCustomer();
```

將回傳 `Laravel\Paddle\Customer` 的實例。一旦在 Paddle 中建立了客戶，你可以在以後開始訂閱。你可以提供一個選用的 `$options` 陣列來傳入 [Paddle API 支援的任何其他客戶建立參數](https://developer.paddle.com/api-reference/customers/create-customer)：

```php
$customer = $user->createAsCustomer($options);
```

<a name="subscriptions"></a>
## 訂閱 (Subscriptions)

<a name="creating-subscriptions"></a>
### 建立訂閱 (Creating Subscriptions)

要建立訂閱，首先從資料庫中取得 billable 模型的實例，通常是 `App\Models\User` 的實例。取得模型實例後，你可以使用 `subscribe` 方法來建立模型的結帳 session：

```php
use Illuminate\Http\Request;

Route::get('/user/subscribe', function (Request $request) {
    $checkout = $request->user()->subscribe($premium = 'pri_123', 'default')
        ->returnTo(route('home'));

    return view('billing', ['checkout' => $checkout]);
});
```

提供給 `subscribe` 方法的第一個參數是使用者訂閱的特定價格。此值應對應於 Paddle 中的價格識別碼。`returnTo` 方法接受一個 URL，使用者在成功完成結帳後將被重新導向到該 URL。傳遞給 `subscribe` 方法的第二個參數應該是訂閱的內部「類型」。如果你的應用程式僅提供單一訂閱，你可以將其稱為 `default` 或 `primary`。此訂閱類型僅供內部應用程式使用，不適合向使用者顯示。此外，它不應包含空格，並且在建立訂閱後絕不應更改。

你也可以使用 `customData` 方法提供有關訂閱的自訂中繼資料陣列：

```php
$checkout = $request->user()->subscribe($premium = 'pri_123', 'default')
    ->customData(['key' => 'value'])
    ->returnTo(route('home'));
```

建立訂閱結帳 session 後，可以將結帳 session 提供給 Cashier Paddle 包含的 `paddle-button` [Blade 元件](#overlay-checkout)：

```blade
<x-paddle-button :checkout="$checkout" className="px-8 py-4">
    Subscribe
</x-paddle-button>
```

使用者完成結帳後，Paddle 將發送 `subscription_created` webhook。Cashier 將接收此 webhook 並為你的客戶設定訂閱。為了確保應用程式正確接收和處理所有 webhook，請確保你已正確 [設定 webhook 處理](#handling-paddle-webhooks)。

<a name="checking-subscription-status"></a>
### 檢查訂閱狀態 (Checking Subscription Status)

一旦使用者訂閱了你的應用程式，你可以使用各種方便的方法檢查他們的訂閱狀態。首先，`subscribed` 方法在使用者擁有有效訂閱時回傳 `true`，即使訂閱目前處於試用期內：

```php
if ($user->subscribed()) {
    // ...
}
```

如果你的應用程式提供多個訂閱，你可以在呼叫 `subscribed` 方法時指定訂閱：

```php
if ($user->subscribed('default')) {
    // ...
}
```

`subscribed` 方法也非常適合作為 [路由 middleware](/docs/middleware)，允許你根據使用者的訂閱狀態過濾對路由和控制器的存取：

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class EnsureUserIsSubscribed
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if ($request->user() && ! $request->user()->subscribed()) {
            // This user is not a paying customer...
            return redirect('/billing');
        }

        return $next($request);
    }
}
```

如果你想確定使用者是否仍在試用期內，可以使用 `onTrial` 方法。此方法對於確定是否應向使用者顯示他們仍在試用期內的警告很有用：

```php
if ($user->subscription()->onTrial()) {
    // ...
}
```

`subscribedToPrice` 方法可用於根據給定的 Paddle 價格 ID 確定使用者是否訂閱了給定的方案。在此範例中，我們將確定使用者的 `default` 訂閱是否主動訂閱了月繳價格：

```php
if ($user->subscribedToPrice($monthly = 'pri_123', 'default')) {
    // ...
}
```

`recurring` 方法可用於確定使用者目前是否處於有效訂閱中，並且不再處於試用期或寬限期內：

```php
if ($user->subscription()->recurring()) {
    // ...
}
```

<a name="canceled-subscription-status"></a>
#### 已取消訂閱狀態 (Canceled Subscription Status)

要確定使用者是否曾經是活躍訂閱者但已取消訂閱，可以使用 `canceled` 方法：

```php
if ($user->subscription()->canceled()) {
    // ...
}
```

你也可以確定使用者是否已取消訂閱，但仍處於「寬限期」，直到訂閱完全過期。例如，如果使用者在 3 月 5 日取消了原定於 3 月 10 日過期的訂閱，則使用者在 3 月 10 日之前處於「寬限期」。此外，在此期間 `subscribed` 方法仍將回傳 `true`：

```php
if ($user->subscription()->onGracePeriod()) {
    // ...
}
```

<a name="past-due-status"></a>
#### 逾期狀態 (Past Due Status)

如果訂閱付款失敗，它將被標記為 `past_due`。當你的訂閱處於此狀態時，直到客戶更新其付款資訊之前，它將不會處於啟用狀態。你可以使用訂閱實例上的 `pastDue` 方法確定訂閱是否逾期：

```php
if ($user->subscription()->pastDue()) {
    // ...
}
```

當訂閱逾期時，你應該指示使用者 [更新他們的付款資訊](#updating-payment-information)。

If you would like subscriptions to still be considered valid when they are `past_due`, you may use the `keepPastDueSubscriptionsActive` method provided by Cashier. Typically, this method should be called in the `register` method of your `AppServiceProvider`:

```php
use Laravel\Paddle\Cashier;

/**
 * Register any application services.
 */
public function register(): void
{
    Cashier::keepPastDueSubscriptionsActive();
}
```

> [!WARNING]
> When a subscription is in a `past_due` state it cannot be changed until payment information has been updated. Therefore, the `swap` and `updateQuantity` methods will throw an exception when the subscription is in a `past_due` state.

<a name="subscription-scopes"></a>
#### Subscription Scopes

Most subscription states are also available as query scopes so that you may easily query your database for subscriptions that are in a given state:

```php
// Get all valid subscriptions...
$subscriptions = Subscription::query()->valid()->get();

// Get all of the canceled subscriptions for a user...
$subscriptions = $user->subscriptions()->canceled()->get();
```

A complete list of available scopes is available below:

```php
Subscription::query()->valid();
Subscription::query()->onTrial();
Subscription::query()->expiredTrial();
Subscription::query()->notOnTrial();
Subscription::query()->active();
Subscription::query()->recurring();
Subscription::query()->pastDue();
Subscription::query()->paused();
Subscription::query()->notPaused();
Subscription::query()->onPausedGracePeriod();
Subscription::query()->notOnPausedGracePeriod();
Subscription::query()->canceled();
Subscription::query()->notCanceled();
Subscription::query()->onGracePeriod();
Subscription::query()->notOnGracePeriod();
```

<a name="subscription-single-charges"></a>
### Subscription Single Charges (Subscription Single Charges)

Subscription single charges allow you to charge subscribers with a one-time charge on top of their subscriptions. You must provide one or multiple price ID's when invoking the `charge` method:

```php
// Charge a single price...
$response = $user->subscription()->charge('pri_123');

// Charge multiple prices at once...
$response = $user->subscription()->charge(['pri_123', 'pri_456']);
```

The `charge` method will not actually charge the customer until the next billing interval of their subscription. If you would like to bill the customer immediately, you may use the `chargeAndInvoice` method instead:

```php
$response = $user->subscription()->chargeAndInvoice('pri_123');
```

<a name="updating-payment-information"></a>
### Updating Payment Information (Updating Payment Information)

Paddle always saves a payment method per subscription. If you want to update the default payment method for a subscription, you should redirect your customer to Paddle's hosted payment method update page using the `redirectToUpdatePaymentMethod` method on the subscription model:

```php
use Illuminate\Http\Request;

Route::get('/update-payment-method', function (Request $request) {
    $user = $request->user();

    return $user->subscription()->redirectToUpdatePaymentMethod();
});
```

When a user has finished updating their information, a `subscription_updated` webhook will be dispatched by Paddle and the subscription details will be updated in your application's database.

<a name="changing-plans"></a>
### Changing Plans (Changing Plans)

After a user has subscribed to your application, they may occasionally want to change to a new subscription plan. To update the subscription plan for a user, you should pass the Paddle price's identifier to the subscription's `swap` method:

```php
use App\Models\User;

$user = User::find(1);

$user->subscription()->swap($premium = 'pri_456');
```

If you would like to swap plans and immediately invoice the user instead of waiting for their next billing cycle, you may use the `swapAndInvoice` method:

```php
$user = User::find(1);

$user->subscription()->swapAndInvoice($premium = 'pri_456');
```

<a name="prorations"></a>
#### Prorations

By default, Paddle prorates charges when swapping between plans. The `noProrate` method may be used to update the subscriptions without prorating the charges:

```php
$user->subscription('default')->noProrate()->swap($premium = 'pri_456');
```

If you would like to disable proration and invoice customers immediately, you may use the `swapAndInvoice` method in combination with `noProrate`:

```php
$user->subscription('default')->noProrate()->swapAndInvoice($premium = 'pri_456');
```

Or, to not bill your customer for a subscription change, you may utilize the `doNotBill` method:

```php
$user->subscription('default')->doNotBill()->swap($premium = 'pri_456');
```

For more information on Paddle's proration policies, please consult Paddle's [proration documentation](https://developer.paddle.com/concepts/subscriptions/proration).

<a name="subscription-quantity"></a>
### Subscription Quantity (Subscription Quantity)

Sometimes subscriptions are affected by "quantity". For example, a project management application might charge $10 per month per project. To easily increment or decrement your subscription's quantity, use the `incrementQuantity` and `decrementQuantity` methods:

```php
$user = User::find(1);

$user->subscription()->incrementQuantity();

// Add five to the subscription's current quantity...
$user->subscription()->incrementQuantity(5);

$user->subscription()->decrementQuantity();

// Subtract five from the subscription's current quantity...
$user->subscription()->decrementQuantity(5);
```

Alternatively, you may set a specific quantity using the `updateQuantity` method:

```php
$user->subscription()->updateQuantity(10);
```

The `noProrate` method may be used to update the subscription's quantity without prorating the charges:

```php
$user->subscription()->noProrate()->updateQuantity(10);
```

<a name="quantities-for-subscription-with-multiple-products"></a>
#### Quantities for Subscriptions With Multiple Products

If your subscription is a [subscription with multiple products](#subscriptions-with-multiple-products), you should pass the ID of the price whose quantity you wish to increment or decrement as the second argument to the increment / decrement methods:

```php
$user->subscription()->incrementQuantity(1, 'price_chat');
```

<a name="subscriptions-with-multiple-products"></a>
### Subscriptions With Multiple Products (Subscriptions With Multiple Products)

[Subscription with multiple products](https://developer.paddle.com/build/subscriptions/add-remove-products-prices-addons) allow you to assign multiple billing products to a single subscription. For example, imagine you are building a customer service "helpdesk" application that has a base subscription price of $10 per month but offers a live chat add-on product for an additional $15 per month.

When creating subscription checkout sessions, you may specify multiple products for a given subscription by passing an array of prices as the first argument to the `subscribe` method:

```php
use Illuminate\Http\Request;

Route::post('/user/subscribe', function (Request $request) {
    $checkout = $request->user()->subscribe([
        'price_monthly',
        'price_chat',
    ]);

    return view('billing', ['checkout' => $checkout]);
});
```

In the example above, the customer will have two prices attached to their `default` subscription. Both prices will be charged on their respective billing intervals. If necessary, you may pass an associative array of key / value pairs to indicate a specific quantity for each price:

```php
$user = User::find(1);

$checkout = $user->subscribe('default', ['price_monthly', 'price_chat' => 5]);
```

If you would like to add another price to an existing subscription, you must use the subscription's `swap` method. When invoking the `swap` method, you should also include the subscription's current prices and quantities as well:

```php
$user = User::find(1);

$user->subscription()->swap(['price_chat', 'price_original' => 2]);
```

The example above will add the new price, but the customer will not be billed for it until their next billing cycle. If you would like to bill the customer immediately you may use the `swapAndInvoice` method:

```php
$user->subscription()->swapAndInvoice(['price_chat', 'price_original' => 2]);
```

You may remove prices from subscriptions using the `swap` method and omitting the price you want to remove:

```php
$user->subscription()->swap(['price_original' => 2]);
```

> [!WARNING]
> You may not remove the last price on a subscription. Instead, you should simply cancel the subscription.

<a name="multiple-subscriptions"></a>
### Multiple Subscriptions (Multiple Subscriptions)

Paddle allows your customers to have multiple subscriptions simultaneously. For example, you may run a gym that offers a swimming subscription and a weight-lifting subscription, and each subscription may have different pricing. Of course, customers should be able to subscribe to either or both plans.

When your application creates subscriptions, you may provide the type of the subscription to the `subscribe` method as the second argument. The type may be any string that represents the type of subscription the user is initiating:

```php
use Illuminate\Http\Request;

Route::post('/swimming/subscribe', function (Request $request) {
    $checkout = $request->user()->subscribe($swimmingMonthly = 'pri_123', 'swimming');

    return view('billing', ['checkout' => $checkout]);
});
```

In this example, we initiated a monthly swimming subscription for the customer. However, they may want to swap to a yearly subscription at a later time. When adjusting the customer's subscription, we can simply swap the price on the `swimming` subscription:

```php
$user->subscription('swimming')->swap($swimmingYearly = 'pri_456');
```

Of course, you may also cancel the subscription entirely:

```php
$user->subscription('swimming')->cancel();
```

<a name="pausing-subscriptions"></a>
### Pausing Subscriptions (Pausing Subscriptions)

To pause a subscription, call the `pause` method on the user's subscription:

```php
$user->subscription()->pause();
```

When a subscription is paused, Cashier will automatically set the `paused_at` column in your database. This column is used to determine when the `paused` method should begin returning `true`. For example, if a customer pauses a subscription on March 1st, but the subscription was not scheduled to recur until March 5th, the `paused` method will continue to return `false` until March 5th. This is because a user is typically allowed to continue using an application until the end of their billing cycle.

By default, pausing happens at the next billing interval so the customer can use the remainder of the period they paid for. If you want to pause a subscription immediately, you may use the `pauseNow` method:

```php
$user->subscription()->pauseNow();
```

Using the `pauseUntil` method, you can pause the subscription until a specific moment in time:

```php
$user->subscription()->pauseUntil(now()->addMonth());
```

Or, you may use the `pauseNowUntil` method to immediately pause the subscription until a given point in time:

```php
$user->subscription()->pauseNowUntil(now()->addMonth());
```

You may determine if a user has paused their subscription but are still on their "grace period" using the `onPausedGracePeriod` method:

```php
if ($user->subscription()->onPausedGracePeriod()) {
    // ...
}
```

To resume a paused subscription, you may invoke the `resume` method on the subscription:

```php
$user->subscription()->resume();
```

> [!WARNING]
> A subscription cannot be modified while it is paused. If you want to swap to a different plan or update quantities you must resume the subscription first.

<a name="canceling-subscriptions"></a>
### Canceling Subscriptions (Canceling Subscriptions)

To cancel a subscription, call the `cancel` method on the user's subscription:

```php
$user->subscription()->cancel();
```

When a subscription is canceled, Cashier will automatically set the `ends_at` column in your database. This column is used to determine when the `subscribed` method should begin returning `false`. For example, if a customer cancels a subscription on March 1st, but the subscription was not scheduled to end until March 5th, the `subscribed` method will continue to return `true` until March 5th. This is done because a user is typically allowed to continue using an application until the end of their billing cycle.

You may determine if a user has canceled their subscription but are still on their "grace period" using the `onGracePeriod` method:

```php
if ($user->subscription()->onGracePeriod()) {
    // ...
}
```

If you wish to cancel a subscription immediately, you may call the `cancelNow` method on the subscription:

```php
$user->subscription()->cancelNow();
```

To stop a subscription on its grace period from canceling, you may invoke the `stopCancelation` method:

```php
$user->subscription()->stopCancelation();
```

> [!WARNING]
> Paddle's subscriptions cannot be resumed after cancelation. If your customer wishes to resume their subscription, they will have to create a new subscription.

<a name="subscription-trials"></a>
## Subscription Trials (Subscription Trials)

<a name="with-payment-method-up-front"></a>
### With Payment Method Up Front (With Payment Method Up Front)

If you would like to offer trial periods to your customers while still collecting payment method information up front, you should use set a trial time in the Paddle dashboard on the price your customer is subscribing to. Then, initiate the checkout session as normal:

```php
use Illuminate\Http\Request;

Route::get('/user/subscribe', function (Request $request) {
    $checkout = $request->user()
        ->subscribe('pri_monthly')
        ->returnTo(route('home'));

    return view('billing', ['checkout' => $checkout]);
});
```

When your application receives the `subscription_created` event, Cashier will set the trial period ending date on the subscription record within your application's database as well as instruct Paddle to not begin billing the customer until after this date.

> [!WARNING]
> If the customer's subscription is not canceled before the trial ending date they will be charged as soon as the trial expires, so you should be sure to notify your users of their trial ending date.

You may determine if the user is within their trial period using either the `onTrial` method of the user instance:

```php
if ($user->onTrial()) {
    // ...
}
```

To determine if an existing trial has expired, you may use the `hasExpiredTrial` methods:

```php
if ($user->hasExpiredTrial()) {
    // ...
}
```

To determine if a user is on trial for a specific subscription type, you may provide the type to the `onTrial` or `hasExpiredTrial` methods:

```php
if ($user->onTrial('default')) {
    // ...
}

if ($user->hasExpiredTrial('default')) {
    // ...
}
```

<a name="without-payment-method-up-front"></a>
### Without Payment Method Up Front (Without Payment Method Up Front)

If you would like to offer trial periods without collecting the user's payment method information up front, you may set the `trial_ends_at` column on the customer record attached to your user to your desired trial ending date. This is typically done during user registration:

```php
use App\Models\User;

$user = User::create([
    // ...
]);

$user->createAsCustomer([
    'trial_ends_at' => now()->addDays(10)
]);
```

Cashier refers to this type of trial as a "generic trial", since it is not attached to any existing subscription. The `onTrial` method on the `User` instance will return `true` if the current date is not past the value of `trial_ends_at`:

```php
if ($user->onTrial()) {
    // User is within their trial period...
}
```

Once you are ready to create an actual subscription for the user, you may use the `subscribe` method as usual:

```php
use Illuminate\Http\Request;

Route::get('/user/subscribe', function (Request $request) {
    $checkout = $request->user()
        ->subscribe('pri_monthly')
        ->returnTo(route('home'));

    return view('billing', ['checkout' => $checkout]);
});
```

To retrieve the user's trial ending date, you may use the `trialEndsAt` method. This method will return a Carbon date instance if a user is on a trial or `null` if they aren't. You may also pass an optional subscription type parameter if you would like to get the trial ending date for a specific subscription other than the default one:

```php
if ($user->onTrial('default')) {
    $trialEndsAt = $user->trialEndsAt();
}
```

You may use the `onGenericTrial` method if you wish to know specifically that the user is within their "generic" trial period and has not created an actual subscription yet:

```php
if ($user->onGenericTrial()) {
    // User is within their "generic" trial period...
}
```

<a name="extend-or-activate-a-trial"></a>
### Extend or Activate a Trial (Extend or Activate a Trial)

You can extend an existing trial period on a subscription by invoking the `extendTrial` method and specifying the moment in time that the trial should end:

```php
$user->subscription()->extendTrial(now()->addDays(5));
```

Or, you may immediately activate a subscription by ending its trial by calling the `activate` method on the subscription:

```php
$user->subscription()->activate();
```

<a name="handling-paddle-webhooks"></a>
## Handling Paddle Webhooks (Handling Paddle Webhooks)

Paddle can notify your application of a variety of events via webhooks. By default, a route that points to Cashier's webhook controller is registered by the Cashier service provider. This controller will handle all incoming webhook requests.

By default, this controller will automatically handle canceling subscriptions that have too many failed charges, subscription updates, and payment method changes; however, as we'll soon discover, you can extend this controller to handle any Paddle webhook event you like.

To ensure your application can handle Paddle webhooks, be sure to [configure the webhook URL in the Paddle control panel](https://vendors.paddle.com/notifications-v2). By default, Cashier's webhook controller responds to the `/paddle/webhook` URL path. The full list of all webhooks you should enable in the Paddle control panel are:

- Customer Updated
- Transaction Completed
- Transaction Updated
- Subscription Created
- Subscription Updated
- Subscription Paused
- Subscription Canceled

> [!WARNING]
> Make sure you protect incoming requests with Cashier's included [webhook signature verification](/docs/cashier-paddle#verifying-webhook-signatures) middleware.

<a name="webhooks-csrf-protection"></a>
#### Webhooks and CSRF Protection

Since Paddle webhooks need to bypass Laravel's [CSRF protection](/docs/csrf), you should ensure that Laravel does not attempt to verify the CSRF token for incoming Paddle webhooks. To accomplish this, you should exclude `paddle/*` from CSRF protection in your application's `bootstrap/app.php` file:

```php
->withMiddleware(function (Middleware $middleware): void {
    $middleware->validateCsrfTokens(except: [
        'paddle/*',
    ]);
})
```

<a name="webhooks-local-development"></a>
#### Webhooks and Local Development

For Paddle to be able to send your application webhooks during local development, you will need to expose your application via a site sharing service such as [Ngrok](https://ngrok.com/) or [Expose](https://expose.dev/docs/introduction). If you are developing your application locally using [Laravel Sail](/docs/sail), you may use Sail's [site sharing command](/docs/sail#sharing-your-site).

<a name="defining-webhook-event-handlers"></a>
### Defining Webhook Event Handlers (Defining Webhook Event Handlers)

Cashier automatically handles subscription cancelation on failed charges and other common Paddle webhooks. However, if you have additional webhook events you would like to handle, you may do so by listening to the following events that are dispatched by Cashier:

- `Laravel\Paddle\Events\WebhookReceived`
- `Laravel\Paddle\Events\WebhookHandled`

Both events contain the full payload of the Paddle webhook. For example, if you wish to handle the `transaction.billed` webhook, you may register a [listener](/docs/events#defining-listeners) that will handle the event:

```php
<?php

namespace App\Listeners;

use Laravel\Paddle\Events\WebhookReceived;

class PaddleEventListener
{
    /**
     * Handle received Paddle webhooks.
     */
    public function handle(WebhookReceived $event): void
    {
        if ($event->payload['event_type'] === 'transaction.billed') {
            // Handle the incoming event...
        }
    }
}
```

Cashier also emit events dedicated to the type of the received webhook. In addition to the full payload from Paddle, they also contain the relevant models that were used to process the webhook such as the billable model, the subscription, or the receipt:

<div className="content-list" markdown="1">

- `Laravel\Paddle\Events\CustomerUpdated`
- `Laravel\Paddle\Events\TransactionCompleted`
- `Laravel\Paddle\Events\TransactionUpdated`
- `Laravel\Paddle\Events\SubscriptionCreated`
- `Laravel\Paddle\Events\SubscriptionUpdated`
- `Laravel\Paddle\Events\SubscriptionPaused`
- `Laravel\Paddle\Events\SubscriptionCanceled`

</div>

You can also override the default, built-in webhook route by defining the `CASHIER_WEBHOOK` environment variable in your application's `.env` file. This value should be the full URL to your webhook route and needs to match the URL set in your Paddle control panel:

```ini
CASHIER_WEBHOOK=https://example.com/my-paddle-webhook-url
```

<a name="verifying-webhook-signatures"></a>
### Verifying Webhook Signatures (Verifying Webhook Signatures)

To secure your webhooks, you may use [Paddle's webhook signatures](https://developer.paddle.com/webhooks/signature-verification). For convenience, Cashier automatically includes a middleware which validates that the incoming Paddle webhook request is valid.

To enable webhook verification, ensure that the `PADDLE_WEBHOOK_SECRET` environment variable is defined in your application's `.env` file. The webhook secret may be retrieved from your Paddle account dashboard.

<a name="single-charges"></a>
## Single Charges (Single Charges)

<a name="charging-for-products"></a>
### Charging for Products (Charging for Products)

If you would like to initiate a product purchase for a customer, you may use the `checkout` method on a billable model instance to generate a checkout session for the purchase. The `checkout` method accepts one or multiple price ID's. If necessary, an associative array may be used to provide the quantity of the product that is being purchased:

```php
use Illuminate\Http\Request;

Route::get('/buy', function (Request $request) {
    $checkout = $request->user()->checkout(['pri_tshirt', 'pri_socks' => 5]);

    return view('buy', ['checkout' => $checkout]);
});
```

After generating the checkout session, you may use Cashier's provided `paddle-button` [Blade component](#overlay-checkout) to allow the user to view the Paddle checkout widget and complete the purchase:

```blade
<x-paddle-button :checkout="$checkout" className="px-8 py-4">
    Buy
</x-paddle-button>
```

A checkout session has a `customData` method, allowing you to pass any custom data you wish to the underlying transaction creation. Please consult [the Paddle documentation](https://developer.paddle.com/build/transactions/custom-data) to learn more about the options available to you when passing custom data:

```php
$checkout = $user->checkout('pri_tshirt')
    ->customData([
        'custom_option' => $value,
    ]);
```

<a name="refunding-transactions"></a>
### Refunding Transactions (Refunding Transactions)

Refunding transactions will return the refunded amount to your customer's payment method that was used at the time of purchase. If you need to refund a Paddle purchase, you may use the `refund` method on a `Cashier\Paddle\Transaction` model. This method accepts a reason as the first argument, one or more price ID's to refund with optional amounts as an associative array. You may retrieve the transactions for a given billable model using the `transactions` method.

For example, imagine we want to refund a specific transaction for prices `pri_123` and `pri_456`. We want to fully refund `pri_123`, but only refund two dollars for `pri_456`:

```php
use App\Models\User;

$user = User::find(1);

$transaction = $user->transactions()->first();

$response = $transaction->refund('Accidental charge', [
    'pri_123', // Fully refund this price...
    'pri_456' => 200, // Only partially refund this price...
]);
```

The example above refunds specific line items in a transaction. If you want to refund the entire transaction, simply provide a reason:

```php
$response = $transaction->refund('Accidental charge');
```

For more information on refunds, please consult [Paddle's refund documentation](https://developer.paddle.com/build/transactions/create-transaction-adjustments).

> [!WARNING]
> Refunds must always be approved by Paddle before fully processing.

<a name="crediting-transactions"></a>
### Crediting Transactions (Crediting Transactions)

Just like refunding, you can also credit transactions. Crediting transactions will add the funds to the customer's balance so it may be used for future purchases. Crediting transactions can only be done for manually-collected transactions and not for automatically-collected transactions (like subscriptions) since Paddle handles subscription credits automatically:

```php
$transaction = $user->transactions()->first();

// Credit a specific line item fully...
$response = $transaction->credit('Compensation', 'pri_123');
```

For more info, [see Paddle's documentation on crediting](https://developer.paddle.com/build/transactions/create-transaction-adjustments).

> [!WARNING]
> Credits can only be applied for manually-collected transactions. Automatically-collected transactions are credited by Paddle themselves.

<a name="transactions"></a>
## Transactions (Transactions)

You may easily retrieve an array of a billable model's transactions via the `transactions` property:

```php
use App\Models\User;

$user = User::find(1);

$transactions = $user->transactions;
```

Transactions represent payments for your products and purchases and are accompanied by invoices. Only completed transactions are stored in your application's database.

When listing the transactions for a customer, you may use the transaction instance's methods to display the relevant payment information. For example, you may wish to list every transaction in a table, allowing the user to easily download any of the invoices:

```html
<table>
  @foreach ($transactions as $transaction)
  <tr>
    <td>{{ $transaction->billed_at->toFormattedDateString() }}</td>
    <td>{{ $transaction->total() }}</td>
    <td>{{ $transaction->tax() }}</td>
    <td>
      <a
        href="{{ route('download-invoice', $transaction->id) }}"
        target="_blank"
        >Download</a
      >
    </td>
  </tr>
  @endforeach
</table>
```

The `download-invoice` route may look like the following:

```php
use Illuminate\Http\Request;
use Laravel\Paddle\Transaction;

Route::get('/download-invoice/{transaction}', function (Request $request, Transaction $transaction) {
    return $transaction->redirectToInvoicePdf();
})->name('download-invoice');
```

<a name="past-and-upcoming-payments"></a>
### Past and Upcoming Payments (Past and Upcoming Payments)

You may use the `lastPayment` and `nextPayment` methods to retrieve and display a customer's past or upcoming payments for recurring subscriptions:

```php
use App\Models\User;

$user = User::find(1);

$subscription = $user->subscription();

$lastPayment = $subscription->lastPayment();
$nextPayment = $subscription->nextPayment();
```

Both of these methods will return an instance of `Laravel\Paddle\Payment`; however, `lastPayment` will return `null` when transactions have not been synced by webhooks yet, while `nextPayment` will return `null` when the billing cycle has ended (such as when a subscription has been canceled):

```blade
Next payment: {{ $nextPayment->amount() }} due on {{ $nextPayment->date()->format('d/m/Y') }}
```

<a name="testing"></a>
## Testing (Testing)

While testing, you should manually test your billing flow to make sure your integration works as expected.

For automated tests, including those executed within a CI environment, you may use [Laravel's HTTP Client](/docs/http-client#testing) to fake HTTP calls made to Paddle. Although this does not test the actual responses from Paddle, it does provide a way to test your application without actually calling Paddle's API.
