---
title: "Artisan 命令列 (Artisan Console)"
description: Artisan 是 Laravel 內建的命令列介面
---

- [簡介](#introduction)
  - [Tinker (REPL)](#tinker)
- [撰寫指令](#writing-commands)
  - [生成指令](#generating-commands)
  - [指令結構](#command-structure)
  - [Closure 指令](#closure-commands)
  - [可隔離指令](#isolatable-commands)
- [定義輸入期望](#defining-input-expectations)
  - [參數](#arguments)
  - [選項](#options)
  - [輸入陣列](#input-arrays)
  - [輸入描述](#input-descriptions)
  - [提示缺少輸入](#prompting-for-missing-input)
- [指令 I/O](#command-io)
  - [檢索輸入](#retrieving-input)
  - [提示輸入](#prompting-for-input)
  - [寫入輸出](#writing-output)
- [註冊指令](#registering-commands)
- [程式化執行指令](#programmatically-executing-commands)
  - [從其他指令呼叫指令](#calling-commands-from-other-commands)
- [訊號處理](#signal-handling)
- [Stub 自訂](#stub-customization)
- [事件](#events)

<a name="introduction"></a>
## 簡介

Artisan 是 Laravel 隨附的命令列介面。Artisan 作為 `artisan` 腳本存在於應用程式的根目錄中，並提供了許多有用的指令，可協助你建立應用程式。要查看所有可用的 Artisan 指令列表，可以使用 `list` 指令：

```shell
php artisan list
```

每個指令還包含一個「help」畫面，顯示並描述指令可用的參數和選項。要查看說明畫面，請在指令名稱前加上 `help`：

```shell
php artisan help migrate
```

<a name="laravel-sail"></a>
#### Laravel Sail

如果你使用 [Laravel Sail](/docs/sail) 作為本機開發環境，請記得使用 `sail` 命令列來呼叫 Artisan 指令。Sail 將在應用程式的 Docker 容器中執行你的 Artisan 指令：

```shell
./vendor/bin/sail artisan list
```

<a name="tinker"></a>
### Tinker (REPL)

[Laravel Tinker](https://github.com/laravel/tinker) 是一個強大的 Laravel 框架 REPL，由 [PsySH](https://github.com/bobthecow/psysh) 套件提供支援。

<a name="installation"></a>
#### 安裝

所有 Laravel 應用程式預設都包含 Tinker。但是，如果你之前已將其從應用程式中移除，則可以使用 Composer 安裝 Tinker：

```shell
composer require laravel/tinker
```

> [!NOTE]
> 正在尋找與 Laravel 應用程式互動時的熱重載、多行程式碼編輯和自動完成功能嗎？請查看 [Tinkerwell](https://tinkerwell.app)！

<a name="usage"></a>
#### 用法

Tinker 允許你在命令列上與整個 Laravel 應用程式互動，包括你的 Eloquent Model、Job、Event 等。要進入 Tinker 環境，請執行 `tinker` Artisan 指令：

```shell
php artisan tinker
```

你可以使用 `vendor:publish` 指令發布 Tinker 的設定檔：

```shell
php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"
```

> [!WARNING] > `dispatch` 輔助函式和 `Dispatchable` 類別上的 `dispatch` 方法依賴垃圾回收將 Job 放入 Queue 中。因此，使用 tinker 時，你應該使用 `Bus::dispatch` 或 `Queue::push` 來調度 Job。

<a name="command-allow-list"></a>
#### 指令允許列表

Tinker 利用「允許」列表來決定哪些 Artisan 指令可以在其 Shell 中執行。預設情況下，你可以執行 `clear-compiled`、`down`、`env`、`inspire`、`migrate`、`migrate:install`、`up` 和 `optimize` 指令。如果你想允許更多指令，可以將它們新增到 `tinker.php` 設定檔中的 `commands` 陣列：

```php
'commands' => [
    // App\Console\Commands\ExampleCommand::class,
],
```

<a name="classes-that-should-not-be-aliased"></a>
#### 不應被別名的類別

通常，當你在 Tinker 中與類別互動時，Tinker 會自動為類別建立別名。但是，你可能希望永遠不要為某些類別建立別名。你可以透過在 `tinker.php` 設定檔的 `dont_alias` 陣列中列出這些類別來達成此目的：

```php
'dont_alias' => [
    App\Models\User::class,
],
```

<a name="writing-commands"></a>
## 撰寫指令

除了 Artisan 提供的指令外，你還可以建立自己的自訂指令。指令通常儲存在 `app/Console/Commands` 目錄中；但是，只要你指示 Laravel [掃描其他目錄以尋找 Artisan 指令](#registering-commands)，你就可以自由選擇自己的儲存位置。

<a name="generating-commands"></a>
### 生成指令

要建立新指令，可以使用 `make:command` Artisan 指令。此指令將在 `app/Console/Commands` 目錄中建立一個新的指令類別。如果你的應用程式中不存在此目錄，請不要擔心 - 它將在你第一次執行 `make:command` Artisan 指令時建立：

```shell
php artisan make:command SendEmails
```

<a name="command-structure"></a>
### 指令結構

生成指令後，你應該為類別的 `signature` 和 `description` 屬性定義適當的值。這些屬性將用於在 `list` 畫面上顯示你的指令。`signature` 屬性還允許你定義 [指令的輸入期望](#defining-input-expectations)。`handle` 方法將在執行指令時被呼叫。你可以將指令邏輯放置在此方法中。

讓我們看一個範例指令。請注意，我們可以透過指令的 `handle` 方法請求我們需要的任何依賴項目。Laravel [服務容器](/docs/container) 將自動注入此方法簽章中型別提示的所有依賴項目：

```php
<?php

namespace App\Console\Commands;

use App\Models\User;
use App\Support\DripEmailer;
use Illuminate\Console\Command;

class SendEmails extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'mail:send {user}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Send a marketing email to a user';

    /**
     * Execute the console command.
     */
    public function handle(DripEmailer $drip): void
    {
        $drip->send(User::find($this->argument('user')));
    }
}
```

> [!NOTE]
> 為了提高程式碼的重複使用性，最好保持 Console 指令輕量，並讓它們延遲到應用程式服務來完成任務。在上面的範例中，請注意我們注入了一個服務類別來執行發送電子郵件的「繁重工作」。

<a name="exit-codes"></a>
#### 退出代碼

如果 `handle` 方法沒有回傳任何內容且指令執行成功，則指令將以 `0` 退出代碼退出，表示成功。但是，`handle` 方法可以選擇回傳一個整數來手動指定指令的退出代碼：

```php
$this->error('Something went wrong.');

return 1;
```

如果你想從指令中的任何方法「失敗」指令，可以使用 `fail` 方法。`fail` 方法將立即終止指令的執行並回傳退出代碼 `1`：

```php
$this->fail('Something went wrong.');
```

<a name="closure-commands"></a>
### Closure 指令

基於 Closure 的指令提供了一種將 Console 指令定義為類別的替代方案。就像路由 Closure 是控制器的替代方案一樣，可以將指令 Closure 視為指令類別的替代方案。

即使 `routes/console.php` 檔案沒有定義 HTTP 路由，它也定義了進入應用程式的基於 Console 的入口點（路由）。在此檔案中，你可以使用 `Artisan::command` 方法定義所有基於 Closure 的 Console 指令。`command` 方法接受兩個參數：[指令簽章](#defining-input-expectations) 和一個接收指令參數和選項的 Closure：

```php
Artisan::command('mail:send {user}', function (string $user) {
    $this->info("Sending email to: {$user}!");
});
```

Closure 綁定到底層指令實例，因此你可以完全存取通常可以在完整指令類別上存取的所有輔助方法。

<a name="type-hinting-dependencies"></a>
#### 型別提示依賴

除了接收指令的參數和選項外，指令 Closure 還可以型別提示你希望從 [服務容器](/docs/container) 解析的其他依賴項目：

```php
use App\Models\User;
use App\Support\DripEmailer;
use Illuminate\Support\Facades\Artisan;

Artisan::command('mail:send {user}', function (DripEmailer $drip, string $user) {
    $drip->send(User::find($user));
});
```

<a name="closure-command-descriptions"></a>
#### Closure 指令描述

定義基於 Closure 的指令時，可以使用 `purpose` 方法為指令新增描述。當你執行 `php artisan list` 或 `php artisan help` 指令時，將顯示此描述：

```php
Artisan::command('mail:send {user}', function (string $user) {
    // ...
})->purpose('Send a marketing email to a user');
```

<a name="isolatable-commands"></a>
### 可隔離指令

> [!WARNING]
> 要使用此功能，你的應用程式必須使用 `memcached`、`redis`、`dynamodb`、`database`、`file` 或 `array` 快取驅動程式作為應用程式的預設快取驅動程式。此外，所有伺服器必須與同一個中央快取伺服器通訊。

有時你可能希望確保一次只能執行一個指令實例。為達成此目的，你可以在指令類別上實作 `Illuminate\Contracts\Console\Isolatable` 介面：

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Contracts\Console\Isolatable;

class SendEmails extends Command implements Isolatable
{
    // ...
}
```

當你將指令標記為 `Isolatable` 時，Laravel 會自動為指令提供 `--isolated` 選項，而無需在指令選項中明確定義它。當使用該選項呼叫指令時，Laravel 將確保沒有其他該指令的實例正在執行。Laravel 透過使用應用程式的預設快取驅動程式嘗試獲取原子鎖來達成此目的。如果其他指令實例正在執行，則該指令將不會執行；但是，指令仍將以成功的退出狀態代碼退出：

```shell
php artisan mail:send 1 --isolated
```

如果你想指定指令在無法執行時應回傳的退出狀態代碼，可以透過 `isolated` 選項提供所需的狀態代碼：

```shell
php artisan mail:send 1 --isolated=12
```

<a name="lock-id"></a>
#### 鎖定 ID

預設情況下，Laravel 將使用指令名稱生成用於在應用程式快取中獲取原子鎖的字串鍵。但是，你可以透過在 Artisan 指令類別上定義 `isolatableId` 方法來自訂此鍵，允許你將指令的參數或選項整合到鍵中：

```php
#
 * Get the isolatable ID for the command.
 */
public function isolatableId(): string
{
    return $this->argument('user');
}
```

<a name="lock-expiration-time"></a>
#### 鎖定過期時間

預設情況下，隔離鎖在指令完成後過期。或者，如果指令中斷且無法完成，鎖將在一小時後過期。但是，你可以透過在指令上定義 `isolationLockExpiresAt` 方法來調整鎖定過期時間：

```php
use DateTimeInterface;
use DateInterval;

/**
 * Determine when an isolation lock expires for the command.
 */
public function isolationLockExpiresAt(): DateTimeInterface|DateInterval
{
    return now()->addMinutes(5);
}
```

<a name="defining-input-expectations"></a>
## 定義輸入期望

撰寫 Console 指令時，通常會透過參數或選項從使用者收集輸入。Laravel 讓你可以使用指令上的 `signature` 屬性非常方便地定義你期望從使用者獲得的輸入。`signature` 屬性允許你以單一、表達性強、類似路由的語法定義指令的名稱、參數和選項。

<a name="arguments"></a>
### 參數

所有使用者提供的參數和選項都包在花括號中。在以下範例中，指令定義了一個必要的參數：`user`：

```php
/**
 * The name and signature of the console command.
 *
 * @var string
 */
protected $signature = 'mail:send {user}';
```

你也可以將參數設為可選或為參數定義預設值：

```php
// Optional argument...
'mail:send {user?}'

// Optional argument with default value...
'mail:send {user=foo}'
```

<a name="options"></a>
### 選項

選項，就像參數一樣，是使用者輸入的另一種形式。當透過命令列提供選項時，選項以兩個連字號 (`--`) 為前綴。有兩種類型的選項：接收值的選項和不接收值的選項。不接收值的選項作為布林「開關」。讓我們看一個這種類型選項的範例：

```php
/**
 * The name and signature of the console command.
 *
 * @var string
 */
protected $signature = 'mail:send {user} {--queue}';
```

在此範例中，可以在呼叫 Artisan 指令時指定 `--queue` 開關。如果傳遞了 `--queue` 開關，則選項的值將為 `true`。否則，值將為 `false`：

```shell
php artisan mail:send 1 --queue
```

<a name="options-with-values"></a>
#### 帶有值的選項

接下來，讓我們看一個期望值的選項。如果使用者必須為選項指定值，你應該在選項名稱後加上 `=` 符號：

```php
/**
 * The name and signature of the console command.
 *
 * @var string
 */
protected $signature = 'mail:send {user} {--queue=}';
```

在此範例中，使用者可以像這樣為選項傳遞值。如果在呼叫指令時未指定選項，其值將為 `null`：

```shell
php artisan mail:send 1 --queue=default
```

你可以透過在選項名稱後指定預設值來為選項分配預設值。如果使用者未傳遞選項值，將使用預設值：

```php
'mail:send {user} {--queue=default}'
```

<a name="option-shortcuts"></a>
#### 選項捷徑

要在定義選項時分配捷徑，你可以在選項名稱前指定它，並使用 `|` 字元作為分隔符號將捷徑與完整選項名稱分開：

```php
'mail:send {user} {--Q|queue=}'
```

在終端機上呼叫指令時，選項捷徑應以單個連字號為前綴，並且在為選項指定值時不應包含 `=` 字元：

```shell
php artisan mail:send 1 -Qdefault
```

<a name="input-arrays"></a>
### 輸入陣列

如果你想定義參數或選項以期望多個輸入值，可以使用 `*` 字元。首先，讓我們看一個指定此類參數的範例：

```php
'mail:send {user*}'
```

執行此指令時，可以按順序將 `user` 參數傳遞給命令列。例如，以下指令將 `user` 的值設定為包含 `1` 和 `2` 作為其值的陣列：

```shell
php artisan mail:send 1 2
```

此 `*` 字元可以與可選參數定義結合使用，以允許零個或多個參數實例：

```php
'mail:send {user?*}'
```

<a name="option-arrays"></a>
#### 選項陣列

定義期望多個輸入值的選項時，傳遞給指令的每個選項值都應以選項名稱為前綴：

```php
'mail:send {--id=*}'
```

可以透過傳遞多個 `--id` 參數來呼叫此類指令：

```shell
php artisan mail:send --id=1 --id=2
```

<a name="input-descriptions"></a>
### 輸入描述

你可以透過使用冒號將參數名稱與描述分開來為輸入參數和選項分配描述。如果你需要一點額外的空間來定義指令，請隨意將定義分佈在多行中：

```php
/**
 * The name and signature of the console command.
 *
 * @var string
 */
protected $signature = 'mail:send
                        {user : The ID of the user}
                        {--queue : Whether the job should be queued}';
```

<a name="prompting-for-missing-input"></a>
### 提示缺少輸入

如果你的指令包含必要的參數，當使用者未提供這些參數時，他們將收到錯誤訊息。或者，你可以透過實作 `PromptsForMissingInput` 介面來設定指令，以便在缺少必要參數時自動提示使用者：

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Contracts\Console\PromptsForMissingInput;

class SendEmails extends Command implements PromptsForMissingInput
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'mail:send {user}';

    // ...
}
```

如果 Laravel 需要從使用者收集必要的參數，它將自動詢問使用者該參數，並使用參數名稱或描述智慧地表達問題。如果你希望自訂用於收集必要參數的問題，可以實作 `promptForMissingArgumentsUsing` 方法，回傳以參數名稱為鍵的問題陣列：

```php
/**
 * Prompt for missing input arguments using the returned questions.
 *
 * @return array<string, string>
 */
protected function promptForMissingArgumentsUsing(): array
{
    return [
        'user' => 'Which user ID should receive the mail?',
    ];
}
```

你也可以透過使用包含問題和預留位置的 Tuple 來提供預留位置文字：

```php
return [
    'user' => ['Which user ID should receive the mail?', 'E.g. 123'],
];
```

如果你想要完全控制提示，可以提供一個 Closure，該 Closure 應提示使用者並回傳他們的答案：

```php
use App\Models\User;
use function Laravel\Prompts\search;

// ...

return [
    'user' => fn () => search(
        label: 'Search for a user:',
        placeholder: 'E.g. Taylor Otwell',
        options: fn ($value) => strlen($value) > 0
            ? User::whereLike('name', "%{$value}%")->pluck('name', 'id')->all()
            : []
    ),
];
```

> [!NOTE]
> 完整的 [Laravel Prompts](/docs/prompts) 文件包含有關可用提示及其用法的更多資訊。

如果你希望提示使用者選擇或輸入 [選項](#options)，可以在指令的 `handle` 方法中包含提示。但是，如果你只希望在使用者也被自動提示缺少參數時才提示使用者，則可以實作 `afterPromptingForMissingArguments` 方法：

```php
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use function Laravel\Prompts\confirm;

// ...

/**
 * Perform actions after the user was prompted for missing arguments.
 */
protected function afterPromptingForMissingArguments(InputInterface $input, OutputInterface $output): void
{
    $input->setOption('queue', confirm(
        label: 'Would you like to queue the mail?',
        default: $this->option('queue')
    ));
}
```

<a name="command-io"></a>
## 指令 I/O

<a name="retrieving-input"></a>
### 檢索輸入

當你的指令正在執行時，你可能需要存取指令接受的參數和選項的值。為此，你可以使用 `argument` 和 `option` 方法。如果參數或選項不存在，將回傳 `null`：

```php
/**
 * Execute the console command.
 */
public function handle(): void
{
    $userId = $this->argument('user');
}
```

如果你需要以 `array` 形式檢索所有參數，請呼叫 `arguments` 方法：

```php
$arguments = $this->arguments();
```

選項可以像參數一樣輕鬆地使用 `option` 方法檢索。要以陣列形式檢索所有選項，請呼叫 `options` 方法：

```php
// Retrieve a specific option...
$queueName = $this->option('queue');

// Retrieve all options as an array...
$options = $this->options();
```

<a name="prompting-for-input"></a>
### 提示輸入

> [!NOTE] > [Laravel Prompts](/docs/prompts) 是一個 PHP 套件，用於為你的命令列應用程式新增美觀且使用者友善的表單，具有類似瀏覽器的功能，包括預留位置文字和驗證。

除了顯示輸出外，你還可以在指令執行期間要求使用者提供輸入。`ask` 方法將提示使用者給定的問題，接受他們的輸入，然後將使用者的輸入回傳給你的指令：

```php
/**
 * Execute the console command.
 */
public function handle(): void
{
    $name = $this->ask('What is your name?');

    // ...
}
```

`ask` 方法還接受一個可選的第二個參數，該參數指定如果未提供使用者輸入應回傳的預設值：

```php
$name = $this->ask('What is your name?', 'Taylor');
```

`secret` 方法類似於 `ask`，但使用者在控制台中輸入時，其輸入將不可見。此方法在詢問密碼等敏感資訊時很有用：

```php
$password = $this->secret('What is the password?');
```

<a name="asking-for-confirmation"></a>
#### 詢問確認

如果你需要詢問使用者一個簡單的「是或否」確認，可以使用 `confirm` 方法。預設情況下，此方法將回傳 `false`。但是，如果使用者在提示時輸入 `y` 或 `yes`，該方法將回傳 `true`。

```php
if ($this->confirm('Do you wish to continue?')) {
    // ...
}
```

如有必要，你可以透過將 `true` 作為第二個參數傳遞給 `confirm` 方法，來指定確認提示預設應回傳 `true`：

```php
if ($this->confirm('Do you wish to continue?', true)) {
    // ...
}
```

<a name="auto-completion"></a>
#### 自動完成

`anticipate` 方法可用於為可能的選擇提供自動完成功能。無論自動完成提示如何，使用者仍然可以提供任何答案：

```php
$name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']);
```

或者，你可以將 Closure 作為第二個參數傳遞給 `anticipate` 方法。每當使用者輸入字元時，都會呼叫 Closure。Closure 應接受包含使用者目前輸入的字串參數，並回傳自動完成選項的陣列：

```php
use App\Models\Address;

$name = $this->anticipate('What is your address?', function (string $input) {
    return Address::whereLike('name', "{$input}%")
        ->limit(5)
        ->pluck('name')
        ->all();
});
```

<a name="multiple-choice-questions"></a>
#### 多選題

如果你需要在提問時給使用者一組預定義的選擇，可以使用 `choice` 方法。你可以透過將索引作為第三個參數傳遞給方法，來設定如果未選擇任何選項時要回傳的預設值的陣列索引：

```php
$name = $this->choice(
    'What is your name?',
    ['Taylor', 'Dayle'],
    $defaultIndex
);
```

此外，`choice` 方法接受可選的第四個和第五個參數，用於確定選擇有效回應的最大嘗試次數以及是否允許多選：

```php
$name = $this->choice(
    'What is your name?',
    ['Taylor', 'Dayle'],
    $defaultIndex,
    $maxAttempts = null,
    $allowMultipleSelections = false
);
```

<a name="writing-output"></a>
### 寫入輸出

要將輸出傳送到控制台，可以使用 `line`、`newLine`、`info`、`comment`、`question`、`warn`、`alert` 和 `error` 方法。這些方法中的每一個都將使用適當的 ANSI 顏色來達到其目的。例如，讓我們向使用者顯示一些一般資訊。通常，`info` 方法將在控制台中顯示為綠色文字：

```php
/**
 * Execute the console command.
 */
public function handle(): void
{
    // ...

    $this->info('The command was successful!');
}
```

要顯示錯誤訊息，請使用 `error` 方法。錯誤訊息文字通常顯示為紅色：

```php
$this->error('Something went wrong!');
```

你可以使用 `line` 方法顯示純文字、無顏色文字：

```php
$this->line('Display this on the screen');
```

你可以使用 `newLine` 方法顯示空白行：

```php
// Write a single blank line...
$this->newLine();

// Write three blank lines...
$this->newLine(3);
```

<a name="tables"></a>
#### 表格

`table` 方法使得正確格式化多行/列資料變得容易。你只需要提供列名稱和表格資料，Laravel 就會自動為你計算表格的適當寬度和高度：

```php
use App\Models\User;

$this->table(
    ['Name', 'Email'],
    User::all(['name', 'email'])->toArray()
);
```

<a name="progress-bars"></a>
#### 進度條

對於長時間執行的任務，顯示進度條來通知使用者任務完成度會很有幫助。使用 `withProgressBar` 方法，Laravel 將顯示一個進度條，並在給定可迭代值的每次迭代中推進其進度：

```php
use App\Models\User;

$users = $this->withProgressBar(User::all(), function (User $user) {
    $this->performTask($user);
});
```

有時，你可能需要對進度條的推進方式進行更多手動控制。首先，定義流程將迭代的總步驟數。然後，在處理每個項目後推進進度條：

```php
$users = App\Models\User::all();

$bar = $this->output->createProgressBar(count($users));

$bar->start();

foreach ($users as $user) {
    $this->performTask($user);

    $bar->advance();
}

$bar->finish();
```

> [!NOTE]
> 有關更多進階選項，請查看 [Symfony Progress Bar 元件文件](https://symfony.com/doc/current/components/console/helpers/progressbar.html)。

<a name="registering-commands"></a>
## 註冊指令

預設情況下，Laravel 會自動註冊 `app/Console/Commands` 目錄中的所有指令。但是，你可以使用應用程式 `bootstrap/app.php` 檔案中的 `withCommands` 方法指示 Laravel 掃描其他目錄以尋找 Artisan 指令：

```php
->withCommands([
    __DIR__.'/../app/Domain/Orders/Commands',
])
```

如有必要，你也可以透過將指令的類別名稱提供給 `withCommands` 方法來手動註冊指令：

```php
use App\Domain\Orders\Commands\SendEmails;

->withCommands([
    SendEmails::class,
])
```

當 Artisan 啟動時，應用程式中的所有指令都將由 [服務容器](/docs/container) 解析並向 Artisan 註冊。

<a name="programmatically-executing-commands"></a>
## 程式化執行指令

有時你可能希望在 CLI 之外執行 Artisan 指令。例如，你可能希望從路由或控制器執行 Artisan 指令。你可以使用 `Artisan` facade 上的 `call` 方法來實現此目的。`call` 方法接受指令的簽章名稱或類別名稱作為其第一個參數，並接受指令參數陣列作為第二個參數。將回傳退出代碼：

```php
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Route;

Route::post('/user/{user}/mail', function (string $user) {
    $exitCode = Artisan::call('mail:send', [
        'user' => $user, '--queue' => 'default'
    ]);

    // ...
});
```

或者，你可以將整個 Artisan 指令作為字串傳遞給 `call` 方法：

```php
Artisan::call('mail:send 1 --queue=default');
```

<a name="passing-array-values"></a>
#### 傳遞陣列值

如果你的指令定義了一個接受陣列的選項，你可以將值陣列傳遞給該選項：

```php
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Route;

Route::post('/mail', function () {
    $exitCode = Artisan::call('mail:send', [
        '--id' => [5, 13]
    ]);
});
```

<a name="passing-boolean-values"></a>
#### 傳遞布林值

如果你需要指定不接受字串值的選項的值，例如 `migrate:refresh` 指令上的 `--force` 旗標，你應該傳遞 `true` 或 `false` 作為選項的值：

```php
$exitCode = Artisan::call('migrate:refresh', [
    '--force' => true,
]);
```

<a name="queueing-artisan-commands"></a>
#### 佇列 Artisan 指令

使用 `Artisan` facade 上的 `queue` 方法，你甚至可以將 Artisan 指令排入佇列，以便由你的 [佇列工作者](/docs/queues) 在背景處理。在使用此方法之前，請確保你已設定佇列並正在執行佇列監聽器：

```php
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Route;

Route::post('/user/{user}/mail', function (string $user) {
    Artisan::queue('mail:send', [
        'user' => $user, '--queue' => 'default'
    ]);

    // ...
});
```

使用 `onConnection` 和 `onQueue` 方法，你可以指定 Artisan 指令應分派到的連線或佇列：

```php
Artisan::queue('mail:send', [
    'user' => 1, '--queue' => 'default'
])->onConnection('redis')->onQueue('commands');
```

<a name="calling-commands-from-other-commands"></a>
### 從其他指令呼叫指令

有時你可能希望從現有的 Artisan 指令呼叫其他指令。你可以使用 `call` 方法來執行此操作。此 `call` 方法接受指令名稱和指令參數/選項陣列：

```php
/**
 * Execute the console command.
 */
public function handle(): void
{
    $this->call('mail:send', [
        'user' => 1, '--queue' => 'default'
    ]);

    // ...
}
```

如果你想呼叫另一個控制台指令並抑制其所有輸出，可以使用 `callSilently` 方法。`callSilently` 方法與 `call` 方法具有相同的簽章：

```php
$this->callSilently('mail:send', [
    'user' => 1, '--queue' => 'default'
]);
```

<a name="signal-handling"></a>
## 訊號處理

正如你所知，作業系統允許將訊號傳送到正在執行的程序。例如，`SIGTERM` 訊號是作業系統要求程式終止的方式。如果你希望在 Artisan 控制台指令中監聽訊號並在發生訊號時執行程式碼，可以使用 `trap` 方法：

```php
/**
 * Execute the console command.
 */
public function handle(): void
{
    $this->trap(SIGTERM, fn () => $this->shouldKeepRunning = false);

    while ($this->shouldKeepRunning) {
        // ...
    }
}
```

要一次監聽多個訊號，可以將訊號陣列提供給 `trap` 方法：

```php
$this->trap([SIGTERM, SIGQUIT], function (int $signal) {
    $this->shouldKeepRunning = false;

    dump($signal); // SIGTERM / SIGQUIT
});
```

<a name="stub-customization"></a>
## Stub 自訂

Artisan 控制台的 `make` 指令用於建立各種各樣的類別，例如控制器、任務、遷移和測試。這些類別是使用「Stub」檔案產生的，這些檔案會根據你的輸入填入值。但是，你可能想要對 Artisan 產生的檔案進行小幅更改。為此，你可以使用 `stub:publish` 指令將最常見的 Stub 發佈到你的應用程式，以便你可以自訂它們：

```shell
php artisan stub:publish
```

發佈的 Stub 將位於應用程式根目錄下的 `stubs` 目錄中。當你使用 Artisan 的 `make` 指令產生相應的類別時，你對這些 Stub 所做的任何更改都將反映出來。

<a name="events"></a>
## 事件

Artisan 在執行指令時會分派三個事件：`Illuminate\Console\Events\ArtisanStarting`、`Illuminate\Console\Events\CommandStarting` 和 `Illuminate\Console\Events\CommandFinished`。`ArtisanStarting` 事件在 Artisan 開始執行時立即分派。接下來，`CommandStarting` 事件在指令執行之前立即分派。最後，`CommandFinished` 事件在指令完成執行後分派。
