---
title: HTTP Client
description: Laravel 提供表達性且最小化的 API 來發送 HTTP 請求
---

# HTTP Client

- [簡介](#introduction)
- [發送請求](#making-requests)
    - [請求資料](#request-data)
    - [標頭](#headers)
    - [認證](#authentication)
    - [逾時](#timeout)
    - [重試](#retries)
    - [錯誤處理](#error-handling)
    - [Guzzle Middleware](#guzzle-middleware)
    - [Guzzle 選項](#guzzle-options)
- [並發請求](#concurrent-requests)
    - [請求池](#request-pooling)
    - [請求批次處理](#request-batching)
- [巨集](#macros)
- [測試](#testing)
    - [偽造回應](#faking-responses)
    - [檢查請求](#inspecting-requests)
    - [防止意外請求](#preventing-stray-requests)
- [事件](#events)

<a name="introduction"></a>
## 簡介

Laravel 為 [Guzzle HTTP client](http://docs.guzzlephp.org/en/stable/) 提供了一套表達性強且簡潔的 API，讓你能夠快速發送 HTTP 請求與其他 Web 應用程式進行通訊。Laravel 對 Guzzle 的封裝專注於其最常見的使用案例，並提供極佳的開發者體驗。

<a name="making-requests"></a>
## 發送請求

要發送請求，你可以使用 `Http` facade 提供的 `head`, `get`, `post`, `put`, `patch`, 和 `delete` 方法。首先，讓我們看看如何發送一個基本的 `GET` 請求到另一個 URL：

```php
use Illuminate\Support\Facades\Http;

$response = Http::get('http://example.com');
```

`get` 方法回傳一個 `Illuminate\Http\Client\Response` 實例，該實例提供了多種方法來檢查回應：

```php
$response->body() : string;
$response->json($key = null, $default = null) : mixed;
$response->object() : object;
$response->collect($key = null) : Illuminate\Support\Collection;
$response->resource() : resource;
$response->status() : int;
$response->successful() : bool;
$response->redirect(): bool;
$response->failed() : bool;
$response->clientError() : bool;
$response->header($header) : string;
$response->headers() : array;
```

`Illuminate\Http\Client\Response` 物件也實作了 PHP 的 `ArrayAccess` 介面，允許你直接存取回應中的 JSON 資料：

```php
return Http::get('http://example.com/users/1')['name'];
```

除了上述的回應方法外，還可以使用以下方法來判斷回應是否具有特定的狀態碼：

```php
$response->ok() : bool;                  // 200 OK
$response->created() : bool;             // 201 Created
$response->accepted() : bool;            // 202 Accepted
$response->noContent() : bool;           // 204 No Content
$response->movedPermanently() : bool;    // 301 Moved Permanently
$response->found() : bool;               // 302 Found
$response->badRequest() : bool;          // 400 Bad Request
$response->unauthorized() : bool;        // 401 Unauthorized
$response->paymentRequired() : bool;     // 402 Payment Required
$response->forbidden() : bool;           // 403 Forbidden
$response->notFound() : bool;            // 404 Not Found
$response->requestTimeout() : bool;      // 408 Request Timeout
$response->conflict() : bool;            // 409 Conflict
$response->unprocessableEntity() : bool; // 422 Unprocessable Entity
$response->tooManyRequests() : bool;     // 429 Too Many Requests
$response->serverError() : bool;         // 500 Internal Server Error
```

<a name="uri-templates"></a>
#### URI 模板

HTTP Client 也允許你使用 [URI 模板規範](https://www.rfc-editor.org/rfc/rfc6570) 來建構請求 URL。要定義可由 URI 模板擴展的 URL 參數，你可以使用 `withUrlParameters` 方法：

```php
Http::withUrlParameters([
    'endpoint' => 'https://laravel.com',
    'page' => 'docs',
    'version' => '12.x',
    'topic' => 'validation',
])->get('{+endpoint}/{page}/{version}/{topic}');
```

<a name="dumping-requests"></a>
#### 傾印請求

如果你想在發送請求之前傾印 (dump) 輸出的請求實例並終止腳本執行，你可以在請求定義的開頭加上 `dd` 方法：

```php
return Http::dd()->get('http://example.com');
```

<a name="request-data"></a>
### 請求資料

當然，在發送 `POST`, `PUT`, 和 `PATCH` 請求時，通常會隨請求發送額外的資料，因此這些方法接受一個資料陣列作為第二個參數。預設情況下，資料將使用 `application/json` 內容類型發送：

```php
use Illuminate\Support\Facades\Http;

$response = Http::post('http://example.com/users', [
    'name' => 'Steve',
    'role' => 'Network Administrator',
]);
```

<a name="get-request-query-parameters"></a>
#### GET 請求查詢參數

在發送 `GET` 請求時，你可以直接將查詢字串附加到 URL，或是將鍵/值對陣列作為第二個參數傳遞給 `get` 方法：

```php
$response = Http::get('http://example.com/users', [
    'name' => 'Taylor',
    'page' => 1,
]);
```

或者，也可以使用 `withQueryParameters` 方法：

```php
Http::retry(3, 100)->withQueryParameters([
    'name' => 'Taylor',
    'page' => 1,
])->get('http://example.com/users');
```

<a name="sending-form-url-encoded-requests"></a>
#### 發送 Form URL Encoded 請求

如果你想使用 `application/x-www-form-urlencoded` 內容類型發送資料，你應該在發送請求之前呼叫 `asForm` 方法：

```php
$response = Http::asForm()->post('http://example.com/users', [
    'name' => 'Sara',
    'role' => 'Privacy Consultant',
]);
```

<a name="sending-a-raw-request-body"></a>
#### 發送原始請求內容 (Raw Request Body)

如果你想在發送請求時提供原始請求內容，可以使用 `withBody` 方法。內容類型可以透過該方法的第二個參數提供：

```php
$response = Http::withBody(
    base64_encode($photo), 'image/jpeg'
)->post('http://example.com/photo');
```

<a name="multi-part-requests"></a>
#### Multi-Part 請求

如果你想將檔案作為 multi-part 請求發送，你應該在發送請求之前呼叫 `attach` 方法。此方法接受檔案名稱及其內容。如果需要，你可以提供第三個參數作為檔案的檔名，而第四個參數可用於提供與該檔案相關的標頭：

```php
$response = Http::attach(
    'attachment', file_get_contents('photo.jpg'), 'photo.jpg', ['Content-Type' => 'image/jpeg']
)->post('http://example.com/attachments');
```

除了傳遞檔案的原始內容，你也可以傳遞一個 stream resource：

```php
$photo = fopen('photo.jpg', 'r');

$response = Http::attach(
    'attachment', $photo, 'photo.jpg'
)->post('http://example.com/attachments');
```

<a name="headers"></a>
### 標頭

可以使用 `withHeaders` 方法將標頭添加到請求中。此 `withHeaders` 方法接受一個鍵/值對陣列：

```php
$response = Http::withHeaders([
    'X-First' => 'foo',
    'X-Second' => 'bar'
])->post('http://example.com/users', [
    'name' => 'Taylor',
]);
```

你可以使用 `accept` 方法指定你的應用程式期望回應的內容類型：

```php
$response = Http::accept('application/json')->get('http://example.com/users');
```

為了方便起見，你可以使用 `acceptJson` 方法快速指定你的應用程式期望回應 `application/json` 內容類型：

```php
$response = Http::acceptJson()->get('http://example.com/users');
```

`withHeaders` 方法會將新的標頭合併到請求現有的標頭中。如果需要，你可以使用 `replaceHeaders` 方法完全替換所有標頭：

```php
$response = Http::withHeaders([
    'X-Original' => 'foo',
])->replaceHeaders([
    'X-Replacement' => 'bar',
])->post('http://example.com/users', [
    'name' => 'Taylor',
]);
```

<a name="authentication"></a>
### 認證

你可以分別使用 `withBasicAuth` 和 `withDigestAuth` 方法指定 Basic 和 Digest 認證憑證：

```php
// Basic authentication...
$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(/* ... */);

// Digest authentication...
$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(/* ... */);
```

<a name="bearer-tokens"></a>
#### Bearer Tokens

如果你想快速將 Bearer token 添加到請求的 `Authorization` 標頭，可以使用 `withToken` 方法：

```php
$response = Http::withToken('token')->post(/* ... */);
```

<a name="timeout"></a>
### 逾時

`timeout` 方法可用於指定等待回應的最大秒數。預設情況下，HTTP client 將在 30 秒後逾時：

```php
$response = Http::timeout(3)->get(/* ... */);
```

如果超過給定的逾時時間，將會拋出 `Illuminate\Http\Client\ConnectionException` 實例。

你可以使用 `connectTimeout` 方法指定嘗試連線到伺服器的最大等待秒數。預設為 10 秒：

```php
$response = Http::connectTimeout(3)->get(/* ... */);
```

<a name="retries"></a>
### 重試

如果你希望 HTTP client 在發生客戶端或伺服器錯誤時自動重試請求，可以使用 `retry` 方法。`retry` 方法接受請求應嘗試的最大次數以及 Laravel 在兩次嘗試之間應等待的毫秒數：

```php
$response = Http::retry(3, 100)->post(/* ... */);
```

如果你想手動計算嘗試之間休眠的毫秒數，可以傳遞一個閉包作為 `retry` 方法的第二個參數：

```php
use Exception;

$response = Http::retry(3, function (int $attempt, Exception $exception) {
    return $attempt * 100;
})->post(/* ... */);
```

為了方便起見，你也可以提供一個陣列作為 `retry` 方法的第一個參數。此陣列將用於確定在後續嘗試之間休眠多少毫秒：

```php
$response = Http::retry([100, 200])->post(/* ... */);
```

如果需要，你可以傳遞第三個參數給 `retry` 方法。第三個參數應該是一個 callable，用於確定是否應該實際嘗試重試。例如，你可能只想在初始請求遇到 `ConnectionException` 時重試請求：

```php
use Exception;
use Illuminate\Http\Client\PendingRequest;

$response = Http::retry(3, 100, function (Exception $exception, PendingRequest $request) {
    return $exception instanceof ConnectionException;
})->post(/* ... */);
```

如果請求嘗試失敗，你可能希望在進行新的嘗試之前更改請求。你可以透過修改提供給 `retry` 方法的 callable 的 request 參數來實現這一點。例如，如果第一次嘗試返回了身份驗證錯誤，你可能希望使用新的授權 token 重試請求：

```php
use Exception;
use Illuminate\Http\Client\PendingRequest;
use Illuminate\Http\Client\RequestException;

$response = Http::withToken($this->getToken())->retry(2, 0, function (Exception $exception, PendingRequest $request) {
    if (! $exception instanceof RequestException || $exception->response->status() !== 401) {
        return false;
    }

    $request->withToken($this->getNewToken());

    return true;
})->post(/* ... */);
```

如果所有請求都失敗，將拋出 `Illuminate\Http\Client\RequestException` 實例。如果你想禁用此行為，可以提供一個值為 `false` 的 `throw` 參數。禁用時，在所有重試都嘗試過後，將回傳客戶端收到的最後一個回應：

```php
$response = Http::retry(3, 100, throw: false)->post(/* ... */);
```

> [!WARNING]
> 如果所有請求都因為連線問題而失敗，即使 `throw` 參數設定為 `false`，仍然會拋出 `Illuminate\Http\Client\ConnectionException`。

<a name="error-handling"></a>
### 錯誤處理

與 Guzzle 的預設行為不同，Laravel 的 HTTP client 封裝器不會在客戶端或伺服器錯誤（來自伺服器的 `400` 和 `500` 級別回應）時拋出異常。你可以使用 `successful`, `clientError`, 或 `serverError` 方法來判斷是否返回了這些錯誤之一：

```php
// Determine if the status code is >= 200 and < 300...
$response->successful();

// Determine if the status code is >= 400...
$response->failed();

// Determine if the response has a 400 level status code...
$response->clientError();

// Determine if the response has a 500 level status code...
$response->serverError();

// Immediately execute the given callback if there was a client or server error...
$response->onError(callable $callback);
```

<a name="throwing-exceptions"></a>
#### 拋出異常

如果你有一個回應實例，並且希望在回應狀態碼指示客戶端或伺服器錯誤時拋出 `Illuminate\Http\Client\RequestException` 實例，你可以使用 `throw` 或 `throwIf` 方法：

```php
use Illuminate\Http\Client\Response;

$response = Http::post(/* ... */);

// Throw an exception if a client or server error occurred...
$response->throw();

// Throw an exception if an error occurred and the given condition is true...
$response->throwIf($condition);

// Throw an exception if an error occurred and the given closure resolves to true...
$response->throwIf(fn (Response $response) => true);

// Throw an exception if an error occurred and the given condition is false...
$response->throwUnless($condition);

// Throw an exception if an error occurred and the given closure resolves to false...
$response->throwUnless(fn (Response $response) => false);

// Throw an exception if the response has a specific status code...
$response->throwIfStatus(403);

// Throw an exception unless the response has a specific status code...
$response->throwUnlessStatus(200);

return $response['user']['id'];
```

`Illuminate\Http\Client\RequestException` 實例有一個公開的 `$response` 屬性，允許你檢查返回的回應。

如果沒有發生錯誤，`throw` 方法將回傳回應實例，允許你將其他操作鏈接到 `throw` 方法上：

```php
return Http::post(/* ... */)->throw()->json();
```

如果你想在拋出異常之前執行一些額外的邏輯，你可以將一個閉包傳遞給 `throw` 方法。異常將在閉包被調用後自動拋出，因此你不需要在閉包內重新拋出異常：

```php
use Illuminate\Http\Client\Response;
use Illuminate\Http\Client\RequestException;

return Http::post(/* ... */)->throw(function (Response $response, RequestException $e) {
    // ...
})->json();
```

預設情況下，`RequestException` 訊息在記錄或報告時會被截斷為 120 個字元。要自定義或禁用此行為，你可以在 `bootstrap/app.php` 檔案中配置應用程式的註冊行為時使用 `truncateAt` 和 `dontTruncate` 方法：

```php
use Illuminate\Http\Client\RequestException;

->registered(function (): void {
    // Truncate request exception messages to 240 characters...
    RequestException::truncateAt(240);

    // Disable request exception message truncation...
    RequestException::dontTruncate();
})
```

或者，你可以使用 `truncateExceptionsAt` 方法自定義每個請求的異常截斷行為：

```php
return Http::truncateExceptionsAt(240)->post(/* ... */);
```

<a name="guzzle-middleware"></a>
### Guzzle Middleware

由於 Laravel 的 HTTP client 是由 Guzzle 驅動的，你可以利用 [Guzzle Middleware](https://docs.guzzlephp.org/en/stable/handlers-and-middleware.html) 來操作輸出的請求或檢查輸入的回應。要操作輸出的請求，請透過 `withRequestMiddleware` 方法註冊 Guzzle middleware：

```php
use Illuminate\Support\Facades\Http;
use Psr\Http\Message\RequestInterface;

$response = Http::withRequestMiddleware(
    function (RequestInterface $request) {
        return $request->withHeader('X-Example', 'Value');
    }
)->get('http://example.com');
```

同樣地，你可以透過 `withResponseMiddleware` 方法註冊 middleware 來檢查輸入的 HTTP 回應：

```php
use Illuminate\Support\Facades\Http;
use Psr\Http\Message\ResponseInterface;

$response = Http::withResponseMiddleware(
    function (ResponseInterface $response) {
        $header = $response->getHeader('X-Example');

        // ...

        return $response;
    }
)->get('http://example.com');
```

<a name="global-middleware"></a>
#### 全域 Middleware

有時，你可能希望註冊一個適用於每個輸出請求和輸入回應的 middleware。要實現這一點，你可以使用 `globalRequestMiddleware` 和 `globalResponseMiddleware` 方法。通常，這些方法應該在應用程式的 `AppServiceProvider` 的 `boot` 方法中調用：

```php
use Illuminate\Support\Facades\Http;

Http::globalRequestMiddleware(fn ($request) => $request->withHeader(
    'User-Agent', 'Example Application/1.0'
));

Http::globalResponseMiddleware(fn ($response) => $response->withHeader(
    'X-Finished-At', now()->toDateTimeString()
));
```

<a name="guzzle-options"></a>
### Guzzle 選項

你可以使用 `withOptions` 方法為輸出請求指定額外的 [Guzzle 請求選項](http://docs.guzzlephp.org/en/stable/request-options.html)。`withOptions` 方法接受一個鍵/值對陣列：

```php
$response = Http::withOptions([
    'debug' => true,
])->get('http://example.com/users');
```

<a name="global-options"></a>
#### 全域選項

要為每個輸出請求配置預設選項，你可以利用 `globalOptions` 方法。通常，此方法應該從應用程式的 `AppServiceProvider` 的 `boot` 方法中調用：

```php
use Illuminate\Support\Facades\Http;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Http::globalOptions([
        'allow_redirects' => false,
    ]);
}
```

<a name="concurrent-requests"></a>
## 並發請求

有時，你可能希望並發發送多個 HTTP 請求。換句話說，你希望同時發送多個請求，而不是按順序發送請求。這在與緩慢的 HTTP API 互動時可以顯著提高效能。

<a name="request-pooling"></a>
### 請求池

幸運的是，你可以使用 `pool` 方法來實現這一點。`pool` 方法接受一個閉包，該閉包接收一個 `Illuminate\Http\Client\Pool` 實例，允許你輕鬆地將請求添加到請求池中以進行調度：

```php
use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;

$responses = Http::pool(fn (Pool $pool) => [
    $pool->get('http://localhost/first'),
    $pool->get('http://localhost/second'),
    $pool->get('http://localhost/third'),
]);

return $responses[0]->ok() &&
       $responses[1]->ok() &&
       $responses[2]->ok();
```

如你所見，每個回應實例都可以根據它被添加到池中的順序來存取。如果你願意，你可以使用 `as` 方法為請求命名，這允許你按名稱存取相應的回應：

```php
use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;

$responses = Http::pool(fn (Pool $pool) => [
    $pool->as('first')->get('http://localhost/first'),
    $pool->as('second')->get('http://localhost/second'),
    $pool->as('third')->get('http://localhost/third'),
]);

return $responses['first']->ok();
```

請求池的最大並發數可以透過向 `pool` 方法提供 `concurrency` 參數來控制。此值決定了在處理請求池時可以同時進行的最大 HTTP 請求數量：

```php
$responses = Http::pool(fn (Pool $pool) => [
    // ...
], concurrency: 5);
```

<a name="customizing-concurrent-requests"></a>
#### 自定義並發請求

`pool` 方法不能與其他 HTTP client 方法（如 `withHeaders` 或 `middleware` 方法）鏈接。如果你想將自定義標頭或 middleware 應用於池中的請求，你應該在池中的每個請求上配置這些選項：

```php
use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;

$headers = [
    'X-Example' => 'example',
];

$responses = Http::pool(fn (Pool $pool) => [
    $pool->withHeaders($headers)->get('http://laravel.test/test'),
    $pool->withHeaders($headers)->get('http://laravel.test/test'),
    $pool->withHeaders($headers)->get('http://laravel.test/test'),
]);
```

<a name="request-batching"></a>
### 請求批次處理

在 Laravel 中處理並發請求的另一種方法是使用 `batch` 方法。與 `pool` 方法一樣，它接受一個閉包，該閉包接收一個 `Illuminate\Http\Client\Batch` 實例，允許你輕鬆地將請求添加到請求池中以進行調度，但它也允許你定義完成回呼：

```php
use Illuminate\Http\Client\Batch;
use Illuminate\Http\Client\ConnectionException;
use Illuminate\Http\Client\RequestException;
use Illuminate\Http\Client\Response;
use Illuminate\Support\Facades\Http;

$responses = Http::batch(fn (Batch $batch) => [
    $batch->get('http://localhost/first'),
    $batch->get('http://localhost/second'),
    $batch->get('http://localhost/third'),
])->before(function (Batch $batch) {
    // The batch has been created but no requests have been initialized...
})->progress(function (Batch $batch, int|string $key, Response $response) {
    // An individual request has completed successfully...
})->then(function (Batch $batch, array $results) {
    // All requests completed successfully...
})->catch(function (Batch $batch, int|string $key, Response|RequestException|ConnectionException $response) {
    // First batch request failure detected...
})->finally(function (Batch $batch, array $results) {
    // The batch has finished executing...
})->send();
```

與 `pool` 方法一樣，你可以使用 `as` 方法為你的請求命名：

```php
$responses = Http::batch(fn (Batch $batch) => [
    $batch->as('first')->get('http://localhost/first'),
    $batch->as('second')->get('http://localhost/second'),
    $batch->as('third')->get('http://localhost/third'),
])->send();
```

在呼叫 `send` 方法啟動 `batch` 後，你不能向其添加新請求。嘗試這樣做將導致拋出 `Illuminate\Http\Client\BatchInProgressException` 異常。

請求批次處理的最大並發數可以透過 `concurrency` 方法控制。此值決定了在處理請求批次處理時可以同時進行的最大 HTTP 請求數量：

```php
$responses = Http::batch(fn (Batch $batch) => [
    // ...
])->concurrency(5)->send();
```

<a name="inspecting-batches"></a>
#### 檢查批次處理

提供給批次處理完成回呼的 `Illuminate\Http\Client\Batch` 實例具有各種屬性和方法，可協助你與給定的請求批次處理進行互動和檢查：

```php
// The number of requests assigned to the batch...
$batch->totalRequests;
 
// The number of requests that have not been processed yet...
$batch->pendingRequests;
 
// The number of requests that have failed...
$batch->failedRequests;

// The number of requests that have been processed thus far...
$batch->processedRequests();

// Indicates if the batch has finished executing...
$batch->finished();

// Indicates if the batch has request failures...
$batch->hasFailures();
```
<a name="deferring-batches"></a>
#### 延遲批次處理

當呼叫 `defer` 方法時，請求批次處理不會立即執行。相反，Laravel 將在當前應用程式請求的 HTTP 回應發送給使用者後執行批次處理，讓你的應用程式感覺快速且反應靈敏：

```php
use Illuminate\Http\Client\Batch;
use Illuminate\Support\Facades\Http;

$responses = Http::batch(fn (Batch $batch) => [
    $batch->get('http://localhost/first'),
    $batch->get('http://localhost/second'),
    $batch->get('http://localhost/third'),
])->then(function (Batch $batch, array $results) {
    // All requests completed successfully...
})->defer();
```

<a name="macros"></a>
## 巨集

Laravel HTTP client 允許你定義「巨集 (macros)」，這可以作為一種流暢、表達性強的機制，在與應用程式中的服務互動時配置常見的請求路徑和標頭。要開始使用，你可以在應用程式的 `App\Providers\AppServiceProvider` 類別的 `boot` 方法中定義巨集：

```php
use Illuminate\Support\Facades\Http;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Http::macro('github', function () {
        return Http::withHeaders([
            'X-Example' => 'example',
        ])->baseUrl('https://github.com');
    });
}
```

配置好巨集後，你可以從應用程式的任何位置調用它，以建立具有指定配置的待處理請求：

```php
$response = Http::github()->get('/');
```

<a name="testing"></a>
## 測試

許多 Laravel 服務提供功能來幫助你輕鬆且表達性地編寫測試，Laravel 的 HTTP client 也不例外。`Http` facade 的 `fake` 方法允許你指示 HTTP client 在發出請求時返回 stubbed / dummy 回應。

<a name="faking-responses"></a>
### 偽造回應

例如，要指示 HTTP client 為每個請求返回空的 `200` 狀態碼回應，你可以不帶參數呼叫 `fake` 方法：

```php
use Illuminate\Support\Facades\Http;

Http::fake();

$response = Http::post(/* ... */);
```

<a name="faking-specific-urls"></a>
#### 偽造特定 URL

或者，你可以將一個陣列傳遞給 `fake` 方法。陣列的鍵應該代表你希望偽造的 URL 模式及其關聯的回應。`*` 字元可用作萬用字元。你可以使用 `Http` facade 的 `response` 方法為這些端點建構 stub / fake 回應：

```php
Http::fake([
    // Stub a JSON response for GitHub endpoints...
    'github.com/*' => Http::response(['foo' => 'bar'], 200, $headers),

    // Stub a string response for Google endpoints...
    'google.com/*' => Http::response('Hello World', 200, $headers),
]);
```

任何向未被偽造的 URL 發出的請求都將實際執行。如果你想指定一個 fallback URL 模式來 stub 所有未匹配的 URL，你可以使用單個 `*` 字元：

```php
Http::fake([
    // Stub a JSON response for GitHub endpoints...
    'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),

    // Stub a string response for all other endpoints...
    '*' => Http::response('Hello World', 200, ['Headers']),
]);
```

為了方便起見，可以透過提供字串、陣列或整數作為回應來生成簡單的字串、JSON 和空回應：

```php
Http::fake([
    'google.com/*' => 'Hello World',
    'github.com/*' => ['foo' => 'bar'],
    'chatgpt.com/*' => 200,
]);
```

<a name="faking-connection-exceptions"></a>
#### 偽造異常

有時你可能需要測試你的應用程式在 HTTP client 嘗試發出請求時遇到 `Illuminate\Http\Client\ConnectionException` 的行為。你可以使用 `failedConnection` 方法指示 HTTP client 拋出連線異常：

```php
Http::fake([
    'github.com/*' => Http::failedConnection(),
]);
```

要測試你的應用程式在拋出 `Illuminate\Http\Client\RequestException` 時的行為，你可以使用 `failedRequest` 方法：

```php
Http::fake([
    'github.com/*' => Http::failedRequest(['code' => 'not_found'], 404),
]);
```

<a name="faking-response-sequences"></a>
#### 偽造回應序列

有時你可能需要指定單個 URL 應按特定順序返回一系列偽造回應。你可以使用 `Http::sequence` 方法來建構回應：

```php
Http::fake([
    // Stub a series of responses for GitHub endpoints...
    'github.com/*' => Http::sequence()
        ->push('Hello World', 200)
        ->push(['foo' => 'bar'], 200)
        ->pushStatus(404),
]);
```

當回應序列中的所有回應都被消耗後，任何進一步的請求都將導致回應序列拋出異常。如果你想指定當序列為空時應返回的預設回應，可以使用 `whenEmpty` 方法：

```php
Http::fake([
    // Stub a series of responses for GitHub endpoints...
    'github.com/*' => Http::sequence()
        ->push('Hello World', 200)
        ->push(['foo' => 'bar'], 200)
        ->whenEmpty(Http::response()),
]);
```

如果你想偽造一系列回應，但不需要指定應偽造的特定 URL 模式，可以使用 `Http::fakeSequence` 方法：

```php
Http::fakeSequence()
    ->push('Hello World', 200)
    ->whenEmpty(Http::response());
```

<a name="fake-callback"></a>
#### Fake Callback

如果你需要更複雜的邏輯來確定為某些端點返回什麼回應，你可以將一個閉包傳遞給 `fake` 方法。此閉包將接收一個 `Illuminate\Http\Client\Request` 實例，並應返回一個回應實例。在你的閉包中，你可以執行任何必要的邏輯來確定要返回什麼類型的回應：

```php
use Illuminate\Http\Client\Request;

Http::fake(function (Request $request) {
    return Http::response('Hello World', 200);
});
```

<a name="inspecting-requests"></a>
### 檢查請求

在偽造回應時，你可能偶爾希望檢查客戶端收到的請求，以確保你的應用程式發送了正確的資料或標頭。你可以在呼叫 `Http::fake` 之後呼叫 `Http::assertSent` 方法來實現這一點。

`assertSent` 方法接受一個閉包，該閉包將接收一個 `Illuminate\Http\Client\Request` 實例，並應返回一個布林值，指示請求是否符合你的期望。為了使測試通過，必須至少發出一個符合給定期望的請求：

```php
use Illuminate\Http\Client\Request;
use Illuminate\Support\Facades\Http;

Http::fake();

Http::withHeaders([
    'X-First' => 'foo',
])->post('http://example.com/users', [
    'name' => 'Taylor',
    'role' => 'Developer',
]);

Http::assertSent(function (Request $request) {
    return $request->hasHeader('X-First', 'foo') &&
           $request->url() == 'http://example.com/users' &&
           $request['name'] == 'Taylor' &&
           $request['role'] == 'Developer';
});
```

如果需要，你可以使用 `assertNotSent` 方法斷言未發送特定請求：

```php
use Illuminate\Http\Client\Request;
use Illuminate\Support\Facades\Http;

Http::fake();

Http::post('http://example.com/users', [
    'name' => 'Taylor',
    'role' => 'Developer',
]);

Http::assertNotSent(function (Request $request) {
    return $request->url() === 'http://example.com/posts';
});
```

你可以使用 `assertSentCount` 方法斷言在測試期間「發送」了多少個請求：

```php
Http::fake();

Http::assertSentCount(5);
```

或者，你可以使用 `assertNothingSent` 方法斷言在測試期間沒有發送任何請求：

```php
Http::fake();

Http::assertNothingSent();
```

<a name="recording-requests-and-responses"></a>
#### 記錄請求 / 回應

你可以使用 `recorded` 方法收集所有請求及其相應的回應。`recorded` 方法返回一個包含 `Illuminate\Http\Client\Request` 和 `Illuminate\Http\Client\Response` 實例的陣列集合：

```php
Http::fake([
    'https://laravel.com' => Http::response(status: 500),
    'https://nova.laravel.com/' => Http::response(),
]);

Http::get('https://laravel.com');
Http::get('https://nova.laravel.com/');

$recorded = Http::recorded();

[$request, $response] = $recorded[0];
```

此外，`recorded` 方法接受一個閉包，該閉包將接收 `Illuminate\Http\Client\Request` 和 `Illuminate\Http\Client\Response` 實例，並可用於根據你的期望過濾請求 / 回應對：

```php
use Illuminate\Http\Client\Request;
use Illuminate\Http\Client\Response;

Http::fake([
    'https://laravel.com' => Http::response(status: 500),
    'https://nova.laravel.com/' => Http::response(),
]);

Http::get('https://laravel.com');
Http::get('https://nova.laravel.com/');

$recorded = Http::recorded(function (Request $request, Response $response) {
    return $request->url() !== 'https://laravel.com' &&
           $response->successful();
});
```

<a name="preventing-stray-requests"></a>
### 防止意外請求

如果你想確保在整個單個測試或完整測試套件中透過 HTTP client 發送的所有請求都已被偽造，你可以呼叫 `preventStrayRequests` 方法。呼叫此方法後，任何沒有相應偽造回應的請求都將拋出異常，而不是發出實際的 HTTP 請求：

```php
use Illuminate\Support\Facades\Http;

Http::preventStrayRequests();

Http::fake([
    'github.com/*' => Http::response('ok'),
]);

// An "ok" response is returned...
Http::get('https://github.com/laravel/framework');

// An exception is thrown...
Http::get('https://laravel.com');
```

有時，你可能希望防止大多數意外請求，但仍允許執行特定請求。要實現這一點，你可以將 URL 模式陣列傳遞給 `allowStrayRequests` 方法。任何匹配給定模式之一的請求都將被允許，而所有其他請求將繼續拋出異常：

```php
use Illuminate\Support\Facades\Http;

Http::preventStrayRequests();

Http::allowStrayRequests([
    'http://127.0.0.1:5000/*',
]);

// This request is executed...
Http::get('http://127.0.0.1:5000/generate');

// An exception is thrown...
Http::get('https://laravel.com');
```

<a name="events"></a>
## 事件

Laravel 在發送 HTTP 請求的過程中會觸發三個事件。`RequestSending` 事件在發送請求之前觸發，而 `ResponseReceived` 事件在收到給定請求的回應後觸發。如果未收到給定請求的回應，則會觸發 `ConnectionFailed` 事件。

`RequestSending` 和 `ConnectionFailed` 事件都包含一個公開的 `$request` 屬性，你可以使用它來檢查 `Illuminate\Http\Client\Request` 實例。同樣地，`ResponseReceived` 事件包含一個 `$request` 屬性以及一個 `$response` 屬性，可用於檢查 `Illuminate\Http\Client\Response` 實例。你可以在應用程式中為這些事件建立 [event listeners](/docs/events)：

```php
use Illuminate\Http\Client\Events\RequestSending;

class LogRequest
{
    /**
     * Handle the event.
     */
    public function handle(RequestSending $event): void
    {
        // $event->request ...
    }
}
```
