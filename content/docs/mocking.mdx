---
title: "Mocking"
---

- [介紹](#introduction)
- [Mocking 物件](#mocking-objects)
- [Mocking Facades](#mocking-facades)
  - [Facade Spies](#facade-spies)
- [與時間互動](#interacting-with-time)

<a name="introduction"></a>
## 介紹

在測試 Laravel 應用程式時，你可能希望「模擬」應用程式的某些部分，以便它們在特定測試期間不會真正被執行。例如，在測試一個會派發事件的控制器時，你可能希望模擬事件監聽器，這樣它們在測試期間就不會真正被執行。這讓你可以只測試控制器的 HTTP 回應，而不用擔心事件監聽器的執行，因為事件監聽器可以在它們自己的測試案例中進行測試。

Laravel 提供了開箱即用的實用方法來模擬事件、任務和其他 facades。這些輔助方法主要提供了一個 Mockery 的便利層，因此你不必手動進行複雜的 Mockery 方法調用。

<a name="mocking-objects"></a>
## Mocking 物件

當模擬一個將透過 Laravel [service container](/docs/{{version}}/container) 注入到你的應用程式的物件時，你需要將你模擬的實例作為 `instance` 綁定到容器中。這會指示容器使用你模擬的物件實例，而不是自己建構該物件：

```php tab=Pest
use App\Service;
use Mockery;
use Mockery\MockInterface;

test('something can be mocked', function () {
    $this->instance(
        Service::class,
        Mockery::mock(Service::class, function (MockInterface $mock) {
            $mock->expects('process');
        })
    );
});
```

```php tab=PHPUnit
use App\Service;
use Mockery;
use Mockery\MockInterface;

public function test_something_can_be_mocked(): void
{
    $this->instance(
        Service::class,
        Mockery::mock(Service::class, function (MockInterface $mock) {
            $mock->expects('process');
        })
    );
}
```

為了讓這更加方便，你可以使用 Laravel 基礎測試案例類別提供的 `mock` 方法。例如，以下範例與上面的範例是等效的：

```php
use App\Service;
use Mockery\MockInterface;

$mock = $this->mock(Service::class, function (MockInterface $mock) {
    $mock->expects('process');
});
```

當你只需要模擬物件的幾個方法時，你可以使用 `partialMock` 方法。未被模擬的方法在被呼叫時會正常執行：

```php
use App\Service;
use Mockery\MockInterface;

$mock = $this->partialMock(Service::class, function (MockInterface $mock) {
    $mock->expects('process');
});
```

同樣地，如果你想要[監視](http://docs.mockery.io/en/latest/reference/spies.html)一個物件，Laravel 的基礎測試案例類別提供了一個 `spy` 方法作為 `Mockery::spy` 方法的便利包裝器。Spies 類似於 mocks；然而，spies 會記錄 spy 與被測試程式碼之間的任何互動，讓你可以在程式碼執行後進行斷言：

```php
use App\Service;

$spy = $this->spy(Service::class);

// ...

$spy->shouldHaveReceived('process');
```

<a name="mocking-facades"></a>
## Mocking Facades

與傳統的靜態方法調用不同，[facades](/docs/{{version}}/facades)（包括[即時 facades](/docs/{{version}}/facades#real-time-facades)）可以被模擬。這提供了相對於傳統靜態方法的巨大優勢，並賦予你與使用傳統依賴注入相同的可測試性。在測試時，你可能經常想要模擬在你的控制器中發生的 Laravel facade 調用。例如，考慮以下控制器動作：

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Support\Facades\Cache;

class UserController extends Controller
{
    /**
     * Retrieve a list of all users of the application.
     */
    public function index(): array
    {
        $value = Cache::get('key');

        return [
            // ...
        ];
    }
}
```

我們可以使用 `expects` 方法來模擬對 `Cache` facade 的調用，這會回傳一個 [Mockery](https://github.com/padraic/mockery) mock 的實例。由於 facades 實際上是由 Laravel [service container](/docs/{{version}}/container) 解析和管理的，它們比典型的靜態類別具有更高的可測試性。例如，讓我們模擬對 `Cache` facade 的 `get` 方法的調用：

```php tab=Pest
<?php

use Illuminate\Support\Facades\Cache;

test('get index', function () {
    Cache::expects('get')
        ->with('key')
        ->andReturn('value');

    $response = $this->get('/users');

    // ...
});
```

```php tab=PHPUnit
<?php

namespace Tests\Feature;

use Illuminate\Support\Facades\Cache;
use Tests\TestCase;

class UserControllerTest extends TestCase
{
    public function test_get_index(): void
    {
        Cache::expects('get')
            ->with('key')
            ->andReturn('value');

        $response = $this->get('/users');

        // ...
    }
}
```

> [!WARNING]
> 你不應該模擬 `Request` facade。相反地，在執行測試時，將你想要的輸入傳遞給 [HTTP 測試方法](/docs/{{version}}/http-tests)，如 `get` 和 `post`。同樣地，與其模擬 `Config` facade，不如在測試中調用 `Config::set` 方法。

<a name="facade-spies"></a>
### Facade Spies

如果你想要[監視](http://docs.mockery.io/en/latest/reference/spies.html)一個 facade，你可以在對應的 facade 上調用 `spy` 方法。Spies 類似於 mocks；然而，spies 會記錄 spy 與被測試程式碼之間的任何互動，讓你可以在程式碼執行後進行斷言：

```php tab=Pest
<?php

use Illuminate\Support\Facades\Cache;

test('values are stored in cache', function () {
    Cache::spy();

    $response = $this->get('/');

    $response->assertStatus(200);

    Cache::shouldHaveReceived('put')->with('name', 'Taylor', 10);
});
```

```php tab=PHPUnit
use Illuminate\Support\Facades\Cache;

public function test_values_are_stored_in_cache(): void
{
    Cache::spy();

    $response = $this->get('/');

    $response->assertStatus(200);

    Cache::shouldHaveReceived('put')->with('name', 'Taylor', 10);
}
```

<a name="interacting-with-time"></a>
## 與時間互動

在測試時，你可能偶爾需要修改像 `now` 或 `Illuminate\Support\Carbon::now()` 這類輔助函式回傳的時間。幸運的是，Laravel 的基礎功能測試類別包含了讓你能夠操作當前時間的輔助方法：

```php tab=Pest
test('time can be manipulated', function () {
    // Travel into the future...
    $this->travel(5)->milliseconds();
    $this->travel(5)->seconds();
    $this->travel(5)->minutes();
    $this->travel(5)->hours();
    $this->travel(5)->days();
    $this->travel(5)->weeks();
    $this->travel(5)->years();

    // Travel into the past...
    $this->travel(-5)->hours();

    // Travel to an explicit time...
    $this->travelTo(now()->subHours(6));

    // Return back to the present time...
    $this->travelBack();
});
```

```php tab=PHPUnit
public function test_time_can_be_manipulated(): void
{
    // Travel into the future...
    $this->travel(5)->milliseconds();
    $this->travel(5)->seconds();
    $this->travel(5)->minutes();
    $this->travel(5)->hours();
    $this->travel(5)->days();
    $this->travel(5)->weeks();
    $this->travel(5)->years();

    // Travel into the past...
    $this->travel(-5)->hours();

    // Travel to an explicit time...
    $this->travelTo(now()->subHours(6));

    // Return back to the present time...
    $this->travelBack();
}
```

你也可以提供一個閉包給各種時間穿梭方法。閉包將在時間凍結於指定時間時被調用。一旦閉包執行完成，時間將恢復正常：

```php
$this->travel(5)->days(function () {
    // Test something five days into the future...
});

$this->travelTo(now()->subDays(10), function () {
    // Test something during a given moment...
});
```

`freezeTime` 方法可用於凍結當前時間。同樣地，`freezeSecond` 方法會凍結當前時間，但是是在當前秒的開始：

```php
use Illuminate\Support\Carbon;

// Freeze time and resume normal time after executing closure...
$this->freezeTime(function (Carbon $time) {
    // ...
});

// Freeze time at the current second and resume normal time after executing closure...
$this->freezeSecond(function (Carbon $time) {
    // ...
})
```

如你所料，上面討論的所有方法主要用於測試對時間敏感的應用程式行為，例如鎖定討論論壇上的非活躍貼文：

```php tab=Pest
use App\Models\Thread;

test('forum threads lock after one week of inactivity', function () {
    $thread = Thread::factory()->create();

    $this->travel(1)->week();

    expect($thread->isLockedByInactivity())->toBeTrue();
});
```

```php tab=PHPUnit
use App\Models\Thread;

public function test_forum_threads_lock_after_one_week_of_inactivity()
{
    $thread = Thread::factory()->create();

    $this->travel(1)->week();

    $this->assertTrue($thread->isLockedByInactivity());
}
```
