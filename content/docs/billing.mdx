---
title: Laravel Cashier (Stripe)
description: Laravel Cashier Stripe 提供了訂閱計費服務的流暢介面
---


<a name="introduction"></a>
## 簡介 (Introduction)

[Laravel Cashier Stripe](https://github.com/laravel/cashier-stripe) 為 [Stripe](https://stripe.com) 的訂閱計費服務提供了一個語意化且流暢的介面。它幾乎處理了所有你害怕編寫的訂閱計費樣板程式碼。除了基本的訂閱管理之外，Cashier 還可以處理折價券、交換訂閱、訂閱「數量」、取消寬限期，甚至產生發票 PDF。

<a name="upgrading-cashier"></a>
## 升級 Cashier (Upgrading Cashier)

當升級到新版本的 Cashier 時，仔細閱讀 [升級指南](https://github.com/laravel/cashier-stripe/blob/master/UPGRADE.md) 非常重要。

> [!WARNING]
> 為了防止破壞性變更，Cashier 使用固定的 Stripe API 版本。Cashier 16 使用 Stripe API 版本 `2025-06-30.basil`。Stripe API 版本將在次要版本發布時更新，以利用新的 Stripe 功能和改進。

<a name="installation"></a>
## 安裝 (Installation)

首先，使用 Composer 套件管理器安裝 Stripe 的 Cashier 套件：

```shell
composer require laravel/cashier
```

安裝套件後，使用 `vendor:publish` Artisan 指令發布 Cashier 的 Migration：

```shell
php artisan vendor:publish --tag="cashier-migrations"
```

然後，遷移你的資料庫：

```shell
php artisan migrate
```

Cashier 的 Migration 將向你的 `users` 資料表新增幾個欄位。它們還將建立一個新的 `subscriptions` 資料表來保存你所有客戶的訂閱，以及一個用於具有多個價格的訂閱的 `subscription_items` 資料表。

如果你願意，也可以使用 `vendor:publish` Artisan 指令發布 Cashier 的設定檔：

```shell
php artisan vendor:publish --tag="cashier-config"
```

最後，為了確保 Cashier 正確處理所有 Stripe 事件，請記得 [設定 Cashier 的 Webhook 處理](#handling-stripe-webhooks)。

> [!WARNING]
> Stripe 建議任何用於儲存 Stripe 識別碼的欄位都應區分大小寫。因此，當使用 MySQL 時，你應該確保 `stripe_id` 欄位的校對設定 (Collation) 為 `utf8_bin`。有關此內容的更多資訊，請參閱 [Stripe 文件](https://stripe.com/docs/upgrades#what-changes-does-stripe-consider-to-be-backwards-compatible)。

<a name="configuration"></a>
## 設定 (Configuration)

<a name="billable-model"></a>
### 可計費模型 (Billable Model)

在使用 Cashier 之前，請將 `Billable` Trait 新增到你的可計費模型定義中。通常，這將是 `App\Models\User` 模型。此 Trait 提供了各種方法，允許你執行常見的計費任務，例如建立訂閱、套用折價券和更新付款方式資訊：

```php
use Laravel\Cashier\Billable;

class User extends Authenticatable
{
    use Billable;
}
```

Cashier 假設你的可計費模型將是 Laravel 隨附的 `App\Models\User` 類別。如果你想更改此設定，可以透過 `useCustomerModel` 方法指定不同的模型。此方法通常應在 `AppServiceProvider` 類別的 `boot` 方法中呼叫：

```php
use App\Models\Cashier\User;
use Laravel\Cashier\Cashier;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Cashier::useCustomerModel(User::class);
}
```

> [!WARNING]
> 如果你使用的是 Laravel 提供的 `App\Models\User` 模型以外的模型，你需要發布並修改提供的 [Cashier Migration](#installation)，以符合你的替代模型的資料表名稱。

<a name="api-keys"></a>
### API 金鑰 (API Keys)

接下來，你應該在應用程式的 `.env` 檔案中設定你的 Stripe API 金鑰。你可以從 Stripe 控制面板檢索你的 Stripe API 金鑰：

```ini
STRIPE_KEY=your-stripe-key
STRIPE_SECRET=your-stripe-secret
STRIPE_WEBHOOK_SECRET=your-stripe-webhook-secret
```

> [!WARNING]
> 你應該確保應用程式的 `.env` 檔案中定義了 `STRIPE_WEBHOOK_SECRET` 環境變數，因為此變數用於確保傳入的 Webhook 實際上來自 Stripe。

<a name="currency-configuration"></a>
### 貨幣設定 (Currency Configuration)

預設的 Cashier 貨幣是美元 (USD)。你可以透過在應用程式的 `.env` 檔案中設定 `CASHIER_CURRENCY` 環境變數來更改預設貨幣：

```ini
CASHIER_CURRENCY=eur
```

除了設定 Cashier 的貨幣之外，你還可以指定在發票上顯示貨幣值時使用的區域設定。在內部，Cashier 利用 [PHP 的 `NumberFormatter` 類別](https://www.php.net/manual/en/class.numberformatter.php) 來設定貨幣區域設定：

```ini
CASHIER_CURRENCY_LOCALE=nl_BE
```

> [!WARNING]
> 為了使用 `en` 以外的區域設定，請確保你的伺服器上安裝並設定了 `ext-intl` PHP 擴充功能。

<a name="tax-configuration"></a>
### 稅務設定 (Tax Configuration)

感謝 [Stripe Tax](https://stripe.com/tax)，可以自動計算 Stripe 產生的所有發票的稅款。你可以透過在應用程式的 `App\Providers\AppServiceProvider` 類別的 `boot` 方法中呼叫 `calculateTaxes` 方法來啟用自動稅款計算：

```php
use Laravel\Cashier\Cashier;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Cashier::calculateTaxes();
}
```

啟用稅款計算後，任何新訂閱和產生的任何一次性發票都將自動計算稅款。

為了使此功能正常運作，你的客戶的帳單詳細資訊（例如客戶的姓名、地址和稅務 ID）需要同步到 Stripe。你可以使用 Cashier 提供的 [客戶資料同步](#syncing-customer-data-with-stripe) 和 [稅務 ID](#tax-ids) 方法來完成此操作。

<a name="logging"></a>
### 日誌 (Logging)

Cashier 允許你指定在記錄致命 Stripe 錯誤時使用的日誌通道。你可以透過在應用程式的 `.env` 檔案中定義 `CASHIER_LOGGER` 環境變數來指定日誌通道：

```ini
CASHIER_LOGGER=stack
```

由 Stripe API 呼叫產生的異常將透過應用程式的預設日誌通道進行記錄。

<a name="using-custom-models"></a>
### 使用自訂模型 (Using Custom Models)

你可以透過定義自己的模型並繼承相應的 Cashier 模型來自由擴充 Cashier 內部使用的模型：

```php
use Laravel\Cashier\Subscription as CashierSubscription;

class Subscription extends CashierSubscription
{
    // ...
}
```

定義模型後，你可以透過 `Laravel\Cashier\Cashier` 類別指示 Cashier 使用你的自訂模型。通常，你應該在應用程式的 `App\Providers\AppServiceProvider` 類別的 `boot` 方法中通知 Cashier 你的自訂模型：

```php
use App\Models\Cashier\Subscription;
use App\Models\Cashier\SubscriptionItem;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Cashier::useSubscriptionModel(Subscription::class);
    Cashier::useSubscriptionItemModel(SubscriptionItem::class);
}
```

<a name="quickstart"></a>
## 快速入門 (Quickstart)

<a name="quickstart-selling-products"></a>
### 銷售產品 (Selling Products)

> [!NOTE]
> 在使用 Stripe Checkout 之前，你應該在 Stripe 儀表板中定義具有固定價格的產品。此外，你應該 [設定 Cashier 的 Webhook 處理](#handling-stripe-webhooks)。

透過應用程式提供產品和訂閱計費可能會讓人感到畏懼。然而，感謝 Cashier 和 [Stripe Checkout](https://stripe.com/payments/checkout)，你可以輕鬆建立現代、強大的支付整合。

為了向客戶收取非經常性、單次收費產品的費用，我們將利用 Cashier 引導客戶前往 Stripe Checkout，他們將在那裡提供付款詳細資訊並確認購買。透過 Checkout 完成付款後，客戶將被重新導向到你在應用程式中選擇的成功 URL：

```php
use Illuminate\Http\Request;

Route::get('/checkout', function (Request $request) {
    $stripePriceId = 'price_deluxe_album';

    $quantity = 1;

    return $request->user()->checkout([$stripePriceId => $quantity], [
        'success_url' => route('checkout-success'),
        'cancel_url' => route('checkout-cancel'),
    ]);
})->name('checkout');

Route::view('/checkout/success', 'checkout.success')->name('checkout-success');
Route::view('/checkout/cancel', 'checkout.cancel')->name('checkout-cancel');
```

如你在上面的範例中所見，我們將利用 Cashier 提供的 `checkout` 方法將客戶重新導向到 Stripe Checkout 以進行給定的「價格識別碼」交易。當使用 Stripe 時，「價格」指的是 [特定產品的定義價格](https://stripe.com/docs/products-prices/how-products-and-prices-work)。

如果有必要，`checkout` 方法將自動在 Stripe 中建立客戶，並將該 Stripe 客戶記錄連接到應用程式資料庫中的相應使用者。完成結帳 Session 後，客戶將被重新導向到專用的成功或取消頁面，你可以在其中向客戶顯示資訊性訊息。

<a name="providing-meta-data-to-stripe-checkout"></a>
#### 提供中繼資料給 Stripe Checkout (Providing Meta Data To Stripe Checkout)

銷售產品時，通常會透過應用程式定義的 `Cart` 和 `Order` 模型來追蹤已完成的訂單和購買的產品。當將客戶重新導向到 Stripe Checkout 以完成購買時，你可能需要提供現有的訂單識別碼，以便在客戶被重新導向回你的應用程式時，將已完成的購買與相應的訂單關聯起來。

為此，你可以向 `checkout` 方法提供一個 `metadata` 陣列。讓我們想像一下，當使用者開始結帳流程時，我們的應用程式中會建立一個待處理的 `Order`。請記住，此範例中的 `Cart` 和 `Order` 模型僅供說明，並非由 Cashier 提供。你可以根據自己應用程式的需求自由實作這些概念：

```php
use App\Models\Cart;
use App\Models\Order;
use Illuminate\Http\Request;

Route::get('/cart/{cart}/checkout', function (Request $request, Cart $cart) {
    $order = Order::create([
        'cart_id' => $cart->id,
        'price_ids' => $cart->price_ids,
        'status' => 'incomplete',
    ]);

    return $request->user()->checkout($order->price_ids, [
        'success_url' => route('checkout-success').'?session_id={CHECKOUT_SESSION_ID}',
        'cancel_url' => route('checkout-cancel'),
        'metadata' => ['order_id' => $order->id],
    ]);
})->name('checkout');
```

如你在上面的範例中所見，當使用者開始結帳流程時，我們將提供所有購物車 / 訂單相關的 Stripe 價格識別碼給 `checkout` 方法。當然，當客戶新增這些項目時，你的應用程式負責將這些項目與「購物車」或訂單關聯起來。我們還透過 `metadata` 陣列將訂單 ID 提供給 Stripe Checkout Session。最後，我們將 `CHECKOUT_SESSION_ID` 樣板變數新增到 Checkout 成功路由中。當 Stripe 將客戶重新導向回你的應用程式時，此樣板變數將自動填入 Checkout Session ID。

接下來，讓我們建立 Checkout 成功路由。這是使用者在透過 Stripe Checkout 完成購買後將被重新導向到的路由。在此路由中，我們可以檢索 Stripe Checkout Session ID 和相關的 Stripe Checkout 實例，以便存取我們提供的中繼資料並相應地更新客戶的訂單：

```php
use App\Models\Order;
use Illuminate\Http\Request;
use Laravel\Cashier\Cashier;

Route::get('/checkout/success', function (Request $request) {
    $sessionId = $request->get('session_id');

    if ($sessionId === null) {
        return;
    }

    $session = Cashier::stripe()->checkout->sessions->retrieve($sessionId);

    if ($session->payment_status !== 'paid') {
        return;
    }

    $orderId = $session['metadata']['order_id'] ?? null;

    $order = Order::findOrFail($orderId);

    $order->update(['status' => 'completed']);

    return view('checkout-success', ['order' => $order]);
})->name('checkout-success');
```

請參閱 Stripe 的文件以獲取有關 [Checkout Session 物件包含的資料](https://stripe.com/docs/api/checkout/sessions/object) 的更多資訊。

<a name="quickstart-selling-subscriptions"></a>
### 銷售訂閱 (Selling Subscriptions)

> [!NOTE]
> 在使用 Stripe Checkout 之前，你應該在 Stripe 儀表板中定義具有固定價格的產品。此外，你應該 [設定 Cashier 的 Webhook 處理](#handling-stripe-webhooks)。

透過應用程式提供產品和訂閱計費可能會讓人感到畏懼。然而，感謝 Cashier 和 [Stripe Checkout](https://stripe.com/payments/checkout)，你可以輕鬆建立現代、強大的支付整合。

要學習如何使用 Cashier 和 Stripe Checkout 銷售訂閱，讓我們考慮一個簡單的訂閱服務場景，其中包含基本月繳 (`price_basic_monthly`) 和年繳 (`price_basic_yearly`) 方案。這兩個價格可以在我們的 Stripe 儀表板中歸類為「Basic」產品 (`pro_basic`)。此外，我們的訂閱服務可能會提供一個 Expert 方案作為 `pro_expert`。

首先，讓我們了解客戶如何訂閱我們的服務。當然，你可以想像客戶可能會點擊我們應用程式定價頁面上 Basic 方案的「訂閱」按鈕。此按鈕或連結應將使用者引導至 Laravel 路由，該路由將為他們選擇的方案建立 Stripe Checkout Session：

```php
use Illuminate\Http\Request;

Route::get('/subscription-checkout', function (Request $request) {
    return $request->user()
        ->newSubscription('default', 'price_basic_monthly')
        ->trialDays(5)
        ->allowPromotionCodes()
        ->checkout([
            'success_url' => route('your-success-route'),
            'cancel_url' => route('your-cancel-route'),
        ]);
});
```

如你在上面的範例中所見，我們將客戶重新導向到 Stripe Checkout Session，這將允許他們訂閱我們的 Basic 方案。成功結帳或取消後，客戶將被重新導向回我們提供給 `checkout` 方法的 URL。要知道他們的訂閱何時實際開始（因為某些付款方式需要幾秒鐘來處理），我們還需要 [設定 Cashier 的 Webhook 處理](#handling-stripe-webhooks)。

現在客戶可以開始訂閱了，我們需要限制應用程式的某些部分，以便只有已訂閱的使用者才能存取它們。當然，我們始終可以透過 Cashier 的 `Billable` Trait 提供的 `subscribed` 方法來確定使用者的當前訂閱狀態：

```blade
@if ($user->subscribed())
    <p>你已訂閱。</p>
@endif
```

我們甚至可以輕鬆確定使用者是否訂閱了特定產品或價格：

```blade
@if ($user->subscribedToProduct('pro_basic'))
    <p>你已訂閱我們的 Basic 產品。</p>
@endif

@if ($user->subscribedToPrice('price_basic_monthly'))
    <p>你已訂閱我們的月繳 Basic 方案。</p>
@endif
```

<a name="quickstart-building-a-subscribed-middleware"></a>
#### 建立已訂閱 Middleware (Quickstart Building A Subscribed Middleware)

為了方便起見，你可能希望建立一個 [Middleware](/docs/middleware) 來確定傳入的請求是否來自已訂閱的使用者。定義此 Middleware 後，你可以輕鬆地將其分配給路由，以防止未訂閱的使用者存取該路由：

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class Subscribed
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (! $request->user()?->subscribed()) {
            // Redirect user to billing page and ask them to subscribe...
            return redirect('/billing');
        }

        return $next($request);
    }
}
```

定義 Middleware 後，你可以將其分配給路由：

```php
use App\Http\Middleware\Subscribed;

Route::get('/dashboard', function () {
    // ...
})->middleware([Subscribed::class]);
```

<a name="quickstart-allowing-customers-to-manage-their-billing-plan"></a>
#### 允許客戶管理他們的計費方案 (Quickstart Allowing Customers To Manage Their Billing Plan)

當然，客戶可能希望將其訂閱方案更改為其他產品或「層級」。允許這樣做的最簡單方法是將客戶引導至 Stripe 的 [客戶計費入口網站](https://stripe.com/docs/no-code/customer-portal)，該入口網站提供了一個託管的使用者介面，允許客戶下載發票、更新付款方式和更改訂閱方案。

首先，在你的應用程式中定義一個連結或按鈕，將使用者引導至 Laravel 路由，我們將利用該路由來啟動計費入口網站 Session：

```blade
<a href="{{ route('billing') }}">
    Billing
</a>
```

接下來，讓我們定義啟動 Stripe 客戶計費入口網站 Session 並將使用者重新導向到入口網站的路由。`redirectToBillingPortal` 方法接受使用者在退出入口網站時應返回的 URL：

```php
use Illuminate\Http\Request;

Route::get('/billing', function (Request $request) {
    return $request->user()->redirectToBillingPortal(route('dashboard'));
})->middleware(['auth'])->name('billing');
```

> [!NOTE]
> 只要你已設定 Cashier 的 Webhook 處理，Cashier 將透過檢查來自 Stripe 的傳入 Webhook 自動保持應用程式的 Cashier 相關資料庫資料表同步。因此，例如，當使用者透過 Stripe 的客戶計費入口網站取消訂閱時，Cashier 將收到相應的 Webhook 並在應用程式資料庫中將訂閱標記為「已取消」。

<a name="customers"></a>
## 客戶 (Customers)

<a name="retrieving-customers"></a>
### 檢索客戶 (Retrieving Customers)

你可以使用 `Cashier::findBillable` 方法透過 Stripe ID 檢索客戶。此方法將回傳可計費模型的實例：

```php
use Laravel\Cashier\Cashier;

$user = Cashier::findBillable($stripeId);
```

<a name="creating-customers"></a>
### 建立客戶 (Creating Customers)

有時，你可能希望在不開始訂閱的情況下建立 Stripe 客戶。你可以使用 `createAsStripeCustomer` 方法來完成此操作：

```php
$stripeCustomer = $user->createAsStripeCustomer();
```

一旦在 Stripe 中建立了客戶，你就可以在以後的日期開始訂閱。你可以提供一個可選的 `$options` 陣列來傳入任何額外的 [Stripe API 支援的客戶建立參數](https://stripe.com/docs/api/customers/create)：

```php
$stripeCustomer = $user->createAsStripeCustomer($options);
```

如果你想回傳可計費模型的 Stripe 客戶物件，可以使用 `asStripeCustomer` 方法：

```php
$stripeCustomer = $user->asStripeCustomer();
```

如果你想檢索給定可計費模型的 Stripe 客戶物件，但不確定可計費模型是否已經是 Stripe 中的客戶，可以使用 `createOrGetStripeCustomer` 方法。如果 Stripe 中尚不存在客戶，此方法將建立一個新客戶：

```php
$stripeCustomer = $user->createOrGetStripeCustomer();
```

<a name="updating-customers"></a>
### 更新客戶 (Updating Customers)

有時，你可能希望直接使用其他資訊更新 Stripe 客戶。你可以使用 `updateStripeCustomer` 方法來完成此操作。此方法接受 [Stripe API 支援的客戶更新選項](https://stripe.com/docs/api/customers/update) 陣列：

```php
$stripeCustomer = $user->updateStripeCustomer($options);
```

<a name="balances"></a>
### 餘額 (Balances)

Stripe 允許你貸記或借記客戶的「餘額」。稍後，此餘額將在新的發票上貸記或借記。要檢查客戶的總餘額，你可以使用可計費模型上可用的 `balance` 方法。`balance` 方法將回傳客戶貨幣餘額的格式化字串表示形式：

```php
$balance = $user->balance();
```

要貸記客戶的餘額，你可以向 `creditBalance` 方法提供一個值。如果你願意，你也可以提供一個描述：

```php
$user->creditBalance(500, 'Premium customer top-up.');
```

向 `debitBalance` 方法提供一個值將借記客戶的餘額：

```php
$user->debitBalance(300, 'Bad usage penalty.');
```

`applyBalance` 方法將為客戶建立新的客戶餘額交易。你可以使用 `balanceTransactions` 方法檢索這些交易記錄，這對於提供貸記和借記日誌供客戶查看可能很有用：

```php
// 檢索所有交易...
$transactions = $user->balanceTransactions();

foreach ($transactions as $transaction) {
    // 交易金額...
    $amount = $transaction->amount(); // $2.31

    // 可用時檢索相關發票...
    $invoice = $transaction->invoice();
}
```

<a name="tax-ids"></a>
### 稅務 ID (Tax IDs)

Cashier 提供了一種簡單的方法來管理客戶的稅務 ID。例如，`taxIds` 方法可用於檢索分配給客戶的所有 [稅務 ID](https://stripe.com/docs/api/customer_tax_ids/object) 集合：

```php
$taxIds = $user->taxIds();
```

你也可以透過其識別碼檢索客戶的特定稅務 ID：

```php
$taxId = $user->findTaxId('txi_belgium');
```

你可以透過向 `createTaxId` 方法提供有效的 [類型](https://stripe.com/docs/api/customer_tax_ids/object#tax_id_object-type) 和值來建立新的稅務 ID：

```php
$taxId = $user->createTaxId('eu_vat', 'BE0123456789');
```

`createTaxId` 方法將立即將增值稅號新增到客戶的帳戶中。[增值稅號的驗證也由 Stripe 完成](https://stripe.com/docs/invoicing/customer/tax-ids#validation)；然而，這是一個非同步過程。你可以透過訂閱 `customer.tax_id.updated` Webhook 事件並檢查 [增值稅號 `verification` 參數](https://stripe.com/docs/api/customer_tax_ids/object#tax_id_object-verification) 來獲得驗證更新通知。有關處理 Webhook 的更多資訊，請參閱 [定義 Webhook 處理器的文件](#handling-stripe-webhooks)。

你可以使用 `deleteTaxId` 方法刪除稅務 ID：

```php
$user->deleteTaxId('txi_belgium');
```

<a name="syncing-customer-data-with-stripe"></a>
### 與 Stripe 同步客戶資料 (Syncing Customer Data With Stripe)

通常，當你的應用程式使用者更新他們的姓名、電子郵件地址或其他也儲存在 Stripe 中的資訊時，你應該通知 Stripe 這些更新。這樣做可以使 Stripe 的資訊副本與你的應用程式保持同步。

為了自動執行此操作，你可以在可計費模型上定義一個事件監聽器，以回應模型的 `updated` 事件。然後，在你的事件監聽器中，你可以呼叫模型上的 `syncStripeCustomerDetails` 方法：

```php
use App\Models\User;
use function Illuminate\Events\queueable;

/**
 * The "booted" method of the model.
 */
protected static function booted(): void
{
    static::updated(queueable(function (User $customer) {
        if ($customer->hasStripeId()) {
            $customer->syncStripeCustomerDetails();
        }
    }));
}
```

現在，每當你的客戶模型更新時，其資訊都會與 Stripe 同步。為了方便起見，Cashier 會在最初建立客戶時自動將你的客戶資訊與 Stripe 同步。

你可以透過覆寫 Cashier 提供的各種方法來自訂用於將客戶資訊同步到 Stripe 的欄位。例如，你可以覆寫 `stripeName` 方法來自訂 Cashier 將客戶資訊同步到 Stripe 時應被視為客戶「姓名」的屬性：

```php
/**
 * Get the customer name that should be synced to Stripe.
 */
public function stripeName(): string|null
{
    return $this->company_name;
}
```

同樣地，你可以覆寫 `stripeEmail`、`stripePhone`（最多 20 個字元）、`stripeAddress` 和 `stripePreferredLocales` 方法。當 [更新 Stripe 客戶物件](https://stripe.com/docs/api/customers/update) 時，這些方法將把資訊同步到其相應的客戶參數。如果你希望完全控制客戶資訊同步過程，你可以覆寫 `syncStripeCustomerDetails` 方法。

<a name="billing-portal"></a>
### 計費入口網站 (Billing Portal)

Stripe 提供了 [一種設定計費入口網站的簡單方法](https://stripe.com/docs/billing/subscriptions/customer-portal)，以便你的客戶可以管理他們的訂閱、付款方式並查看他們的計費記錄。你可以透過從控制器或路由呼叫可計費模型上的 `redirectToBillingPortal` 方法，將使用者重新導向到計費入口網站：

```php
use Illuminate\Http\Request;

Route::get('/billing-portal', function (Request $request) {
    return $request->user()->redirectToBillingPortal();
});
```

預設情況下，當使用者完成管理他們的訂閱時，他們將能夠透過 Stripe 計費入口網站內的連結返回應用程式的 `home` 路由。你可以透過將 URL 作為參數傳遞給 `redirectToBillingPortal` 方法來提供使用者應返回的自訂 URL：

```php
use Illuminate\Http\Request;

Route::get('/billing-portal', function (Request $request) {
    return $request->user()->redirectToBillingPortal(route('billing'));
});
```

如果你想產生計費入口網站的 URL 而不產生 HTTP 重新導向回應，你可以呼叫 `billingPortalUrl` 方法：

```php
$url = $request->user()->billingPortalUrl(route('billing'));
```

<a name="payment-methods"></a>
## 付款方式 (Payment Methods)

<a name="storing-payment-methods"></a>
### 儲存付款方式 (Storing Payment Methods)

為了使用 Stripe 建立訂閱或執行「一次性」收費，你需要儲存付款方式並從 Stripe 檢索其識別碼。用於完成此操作的方法取決於你打算將付款方式用於訂閱還是單次收費，因此我們將在下面檢查這兩種方法。

<a name="payment-methods-for-subscriptions"></a>
#### 訂閱的付款方式 (Payment Methods for Subscriptions)

當儲存客戶的信用卡資訊以供訂閱將來使用時，必須使用 Stripe "Setup Intents" API 來安全地收集客戶的付款方式詳細資訊。"Setup Intent" 向 Stripe 表明向客戶付款方式收費的意圖。Cashier 的 `Billable` Trait 包含 `createSetupIntent` 方法，可輕鬆建立新的 Setup Intent。你應該從呈現收集客戶付款方式詳細資訊的表單的路由或控制器呼叫此方法：

```php
return view('update-payment-method', [
    'intent' => $user->createSetupIntent()
]);
```

建立 Setup Intent 並將其傳遞給視圖後，你應該將其 secret 附加到將收集付款方式的元素上。例如，考慮這個「更新付款方式」表單：

```html
<input id="card-holder-name" type="text" />

<!-- Stripe Elements Placeholder -->
<div id="card-element"></div>

<button id="card-button" data-secret="{{ $intent->client_secret }}">
  Update Payment Method
</button>
```

接下來，可以使用 Stripe.js 函式庫將 [Stripe Element](https://stripe.com/docs/stripe-js) 附加到表單，並安全地收集客戶的付款詳細資訊：

```html
<script src="https://js.stripe.com/v3/"></script>

<script>
  const stripe = Stripe("stripe-public-key");

  const elements = stripe.elements();
  const cardElement = elements.create("card");

  cardElement.mount("#card-element");
</script>
```

接下來，可以使用 [Stripe 的 `confirmCardSetup` 方法](https://stripe.com/docs/js/setup_intents/confirm_card_setup) 驗證卡片並從 Stripe 檢索安全的「付款方式識別碼」：

```js
const cardHolderName = document.getElementById("card-holder-name");
const cardButton = document.getElementById("card-button");
const clientSecret = cardButton.dataset.secret;

cardButton.addEventListener("click", async (e) => {
  const { setupIntent, error } = await stripe.confirmCardSetup(clientSecret, {
    payment_method: {
      card: cardElement,
      billing_details: { name: cardHolderName.value },
    },
  });

  if (error) {
    // Display "error.message" to the user...
  } else {
    // The card has been verified successfully...
  }
});
```

卡片經 Stripe 驗證後，你可以將產生的 `setupIntent.payment_method` 識別碼傳遞給你的 Laravel 應用程式，在那裡它可以附加到客戶。付款方式可以 [新增為新付款方式](#adding-payment-methods) 或 [用於更新預設付款方式](#updating-the-default-payment-method)。你也可以立即使用付款方式識別碼 [建立新訂閱](#creating-subscriptions)。

> [!NOTE]
> 如果你想了解有關 Setup Intents 和收集客戶付款詳細資訊的更多資訊，請 [查看 Stripe 提供的此概述](https://stripe.com/docs/payments/save-and-reuse#php)。

<a name="payment-methods-for-single-charges"></a>
#### 單次收費的付款方式 (Payment Methods for Single Charges)

當然，當對客戶的付款方式進行單次收費時，我們只需要使用一次付款方式識別碼。由於 Stripe 的限制，你不能使用客戶儲存的預設付款方式進行單次收費。你必須允許客戶使用 Stripe.js 函式庫輸入他們的付款方式詳細資訊。例如，考慮以下表單：

```html
<input id="card-holder-name" type="text" />

<!-- Stripe Elements Placeholder -->
<div id="card-element"></div>

<button id="card-button">Process Payment</button>
```

定義此類表單後，可以使用 Stripe.js 函式庫將 [Stripe Element](https://stripe.com/docs/stripe-js) 附加到表單，並安全地收集客戶的付款詳細資訊：

```html
<script src="https://js.stripe.com/v3/"></script>

<script>
  const stripe = Stripe("stripe-public-key");

  const elements = stripe.elements();
  const cardElement = elements.create("card");

  cardElement.mount("#card-element");
</script>
```

接下來，可以使用 [Stripe 的 `createPaymentMethod` 方法](https://stripe.com/docs/stripe-js/reference#stripe-create-payment-method) 驗證卡片並從 Stripe 檢索安全的「付款方式識別碼」：

```js
const cardHolderName = document.getElementById("card-holder-name");
const cardButton = document.getElementById("card-button");

cardButton.addEventListener("click", async (e) => {
  const { paymentMethod, error } = await stripe.createPaymentMethod(
    "card",
    cardElement,
    {
      billing_details: { name: cardHolderName.value },
    }
  );

  if (error) {
    // Display "error.message" to the user...
  } else {
    // The card has been verified successfully...
  }
});
```

如果卡片驗證成功，你可以將 `paymentMethod.id` 傳遞給你的 Laravel 應用程式並處理 [單次收費](#simple-charge)。

<a name="retrieving-payment-methods"></a>
### 檢索付款方式 (Retrieving Payment Methods)

可計費模型實例上的 `paymentMethods` 方法回傳 `Laravel\Cashier\PaymentMethod` 實例的集合：

```php
$paymentMethods = $user->paymentMethods();
```

預設情況下，此方法將回傳所有類型的付款方式。要檢索特定類型的付款方式，你可以將 `type` 作為參數傳遞給該方法：

```php
$paymentMethods = $user->paymentMethods('sepa_debit');
```

要檢索客戶的預設付款方式，可以使用 `defaultPaymentMethod` 方法：

```php
$paymentMethod = $user->defaultPaymentMethod();
```

你可以使用 `findPaymentMethod` 方法檢索附加到可計費模型的特定付款方式：

```php
$paymentMethod = $user->findPaymentMethod($paymentMethodId);
```

<a name="payment-method-presence"></a>
### 付款方式存在性 (Payment Method Presence)

要確定可計費模型的帳戶是否附加了預設付款方式，請呼叫 `hasDefaultPaymentMethod` 方法：

```php
if ($user->hasDefaultPaymentMethod()) {
    // ...
}
```

你可以使用 `hasPaymentMethod` 方法來確定可計費模型的帳戶是否有至少一個付款方式：

```php
if ($user->hasPaymentMethod()) {
    // ...
}
```

此方法將確定可計費模型是否有任何付款方式。要確定模型是否存在特定類型的付款方式，你可以將 `type` 作為參數傳遞給該方法：

```php
if ($user->hasPaymentMethod('sepa_debit')) {
    // ...
}
```

<a name="updating-the-default-payment-method"></a>
### 更新預設付款方式 (Updating the Default Payment Method)

`updateDefaultPaymentMethod` 方法可用於更新客戶的預設付款方式資訊。此方法接受 Stripe 付款方式識別碼，並將新的付款方式分配為預設計費付款方式：

```php
$user->updateDefaultPaymentMethod($paymentMethod);
```

要將你的預設付款方式資訊與 Stripe 中客戶的預設付款方式資訊同步，你可以使用 `updateDefaultPaymentMethodFromStripe` 方法：

```php
$user->updateDefaultPaymentMethodFromStripe();
```

> [!WARNING]
> 客戶的預設付款方式只能用於開立發票和建立新訂閱。由於 Stripe 施加的限制，它可能無法用於單次收費。

<a name="adding-payment-methods"></a>
### 新增付款方式 (Adding Payment Methods)

要新增付款方式，你可以在可計費模型上呼叫 `addPaymentMethod` 方法，並傳遞付款方式識別碼：

```php
$user->addPaymentMethod($paymentMethod);
```

> [!NOTE]
> 要了解如何檢索付款方式識別碼，請查看 [付款方式儲存文件](#storing-payment-methods)。

<a name="deleting-payment-methods"></a>
### 刪除付款方式 (Deleting Payment Methods)

要刪除付款方式，你可以在希望刪除的 `Laravel\Cashier\PaymentMethod` 實例上呼叫 `delete` 方法：

```php
$paymentMethod->delete();
```

`deletePaymentMethod` 方法將從可計費模型中刪除特定的付款方式：

```php
$user->deletePaymentMethod('pm_visa');
```

`deletePaymentMethods` 方法將刪除可計費模型的所有付款方式資訊：

```php
$user->deletePaymentMethods();
```

預設情況下，此方法將刪除所有類型的付款方式。要刪除特定類型的付款方式，你可以將 `type` 作為參數傳遞給該方法：

```php
$user->deletePaymentMethods('sepa_debit');
```

> [!WARNING]
> 如果使用者有有效的訂閱，你的應用程式不應允許他們刪除預設付款方式。

<a name="subscriptions"></a>
## 訂閱 (Subscriptions)

訂閱提供了一種為客戶設定定期付款的方法。由 Cashier 管理的 Stripe 訂閱支援多種訂閱價格、訂閱數量、試用等。

<a name="creating-subscriptions"></a>
### 建立訂閱 (Creating Subscriptions)

要建立訂閱，首先檢索可計費模型的實例，通常是 `App\Models\User` 的實例。檢索到模型實例後，你可以使用 `newSubscription` 方法建立模型的訂閱：

```php
use Illuminate\Http\Request;

Route::post('/user/subscribe', function (Request $request) {
    $request->user()->newSubscription(
        'default', 'price_monthly'
    )->create($request->paymentMethodId);

    // ...
});
```

傳遞給 `newSubscription` 方法的第一個參數應該是訂閱的內部類型。如果你的應用程式只提供單個訂閱，你可以將其稱為 `default` 或 `primary`。此訂閱類型僅供內部應用程式使用，不旨在向使用者顯示。此外，它不應包含空格，並且在建立訂閱後絕不應更改。第二個參數是使用者訂閱的特定價格。此值應對應於 Stripe 中的價格識別碼。

`create` 方法接受 [Stripe 付款方式識別碼](#storing-payment-methods) 或 Stripe `PaymentMethod` 物件，將開始訂閱並使用可計費模型的 Stripe 客戶 ID 和其他相關計費資訊更新你的資料庫。

> [!WARNING]
> 將付款方式識別碼直接傳遞給 `create` 訂閱方法也會自動將其新增到使用者儲存的付款方式中。

<a name="collecting-recurring-payments-via-invoice-emails"></a>
#### 透過發票電子郵件收取定期付款 (Collecting Recurring Payments via Invoice Emails)

你可以指示 Stripe 在每次定期付款到期時向客戶發送發票電子郵件，而不是自動收取客戶的定期付款。然後，客戶在收到發票後可以手動支付發票。在透過發票收取定期付款時，客戶不需要預先提供付款方式：

```php
$user->newSubscription('default', 'price_monthly')->createAndSendInvoice();
```

客戶在訂閱被取消之前支付發票的時間由 `days_until_due` 選項決定。預設情況下，這是 30 天；但是，如果你願意，你可以為此選項提供特定值：

```php
$user->newSubscription('default', 'price_monthly')->createAndSendInvoice([], [
    'days_until_due' => 30
]);
```

<a name="subscription-quantities"></a>
#### 數量 (Quantities)

如果你想在建立訂閱時設定價格的特定 [數量](https://stripe.com/docs/billing/subscriptions/quantities)，你應該在建立訂閱之前呼叫訂閱建構器上的 `quantity` 方法：

```php
$user->newSubscription('default', 'price_monthly')
    ->quantity(5)
    ->create($paymentMethod);
```

<a name="additional-details"></a>
#### 額外詳細資訊 (Additional Details)

如果你想指定 Stripe 支援的額外 [客戶](https://stripe.com/docs/api/customers/create) 或 [訂閱](https://stripe.com/docs/api/subscriptions/create) 選項，你可以透過將它們作為第二個和第三個參數傳遞給 `create` 方法來實現：

```php
$user->newSubscription('default', 'price_monthly')->create($paymentMethod, [
    'email' => $email,
], [
    'metadata' => ['note' => 'Some extra information.'],
]);
```

<a name="coupons"></a>
#### 折價券 (Coupons)

如果你想在建立訂閱時套用折價券，可以使用 `withCoupon` 方法：

```php
$user->newSubscription('default', 'price_monthly')
    ->withCoupon('code')
    ->create($paymentMethod);
```

或者，如果你想套用 [Stripe 促銷代碼](https://stripe.com/docs/billing/subscriptions/discounts/codes)，可以使用 `withPromotionCode` 方法：

```php
$user->newSubscription('default', 'price_monthly')
    ->withPromotionCode('promo_code_id')
    ->create($paymentMethod);
```

給定的促銷代碼 ID 應該是分配給促銷代碼的 Stripe API ID，而不是面向客戶的促銷代碼。如果你需要根據給定的面向客戶的促銷代碼找到促銷代碼 ID，可以使用 `findPromotionCode` 方法：

```php
// 透過面向客戶的代碼尋找促銷代碼 ID...
$promotionCode = $user->findPromotionCode('SUMMERSALE');

// 透過面向客戶的代碼尋找有效的促銷代碼 ID...
$promotionCode = $user->findActivePromotionCode('SUMMERSALE');
```

在上面的範例中，回傳的 `$promotionCode` 物件是 `Laravel\Cashier\PromotionCode` 的實例。此類別裝飾了底層的 `Stripe\PromotionCode` 物件。你可以透過呼叫 `coupon` 方法來檢索與促銷代碼相關的折價券：

```php
$coupon = $user->findPromotionCode('SUMMERSALE')->coupon();
```

折價券實例允許你確定折扣金額以及折價券是代表固定折扣還是基於百分比的折扣：

```php
if ($coupon->isPercentage()) {
    return $coupon->percentOff().'%'; // 21.5%
} else {
    return $coupon->amountOff(); // $5.99
}
```

你也可以檢索目前套用於客戶或訂閱的折扣：

```php
$discount = $billable->discount();

$discount = $subscription->discount();
```

回傳的 `Laravel\Cashier\Discount` 實例裝飾了底層的 `Stripe\Discount` 物件實例。你可以透過呼叫 `coupon` 方法來檢索與此折扣相關的折價券：

```php
$coupon = $subscription->discount()->coupon();
```

如果你想將新的折價券或促銷代碼套用於客戶或訂閱，可以透過 `applyCoupon` 或 `applyPromotionCode` 方法來實現：

```php
$billable->applyCoupon('coupon_id');
$billable->applyPromotionCode('promotion_code_id');

$subscription->applyCoupon('coupon_id');
$subscription->applyPromotionCode('promotion_code_id');
```

請記住，你應該使用分配給促銷代碼的 Stripe API ID，而不是面向客戶的促銷代碼。在給定時間內，只能將一個折價券或促銷代碼套用於客戶或訂閱。

有關此主題的更多資訊，請參閱關於 [折價券](https://stripe.com/docs/billing/subscriptions/coupons) 和 [促銷代碼](https://stripe.com/docs/billing/subscriptions/coupons/codes) 的 Stripe 文件。

<a name="adding-subscriptions"></a>
#### 新增訂閱 (Adding Subscriptions)

如果你想為已經有預設付款方式的客戶新增訂閱，你可以在訂閱建構器上呼叫 `add` 方法：

```php
use App\Models\User;

$user = User::find(1);

$user->newSubscription('default', 'price_monthly')->add();
```

<a name="creating-subscriptions-from-the-stripe-dashboard"></a>
#### 從 Stripe 儀表板建立訂閱 (Creating Subscriptions From the Stripe Dashboard)

你也可以從 Stripe 儀表板本身建立訂閱。這樣做時，Cashier 將同步新新增的訂閱並為其分配 `default` 類型。要自訂分配給儀表板建立的訂閱的訂閱類型，請 [定義 Webhook 事件處理器](#defining-webhook-event-handlers)。

此外，你只能透過 Stripe 儀表板建立一種類型的訂閱。如果你的應用程式提供使用不同類型的多個訂閱，則只能透過 Stripe 儀表板新增一種類型的訂閱。

最後，你應該始終確保應用程式提供的每種訂閱類型只新增一個有效訂閱。如果客戶有兩個 `default` 訂閱，即使兩者都將與你的應用程式資料庫同步，Cashier 也只會使用最近新增的訂閱。

<a name="checking-subscription-status"></a>
### 檢查訂閱狀態 (Checking Subscription Status)

一旦客戶訂閱了你的應用程式，你可以使用各種方便的方法輕鬆檢查他們的訂閱狀態。首先，如果客戶有有效的訂閱，即使訂閱目前處於試用期，`subscribed` 方法也會回傳 `true`。`subscribed` 方法接受訂閱類型作為其第一個參數：

```php
if ($user->subscribed('default')) {
    // ...
}
```

`subscribed` 方法也是 [路由 Middleware](/docs/middleware) 的絕佳候選者，允許你根據使用者的訂閱狀態過濾對路由和控制器的存取：

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class EnsureUserIsSubscribed
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if ($request->user() && ! $request->user()->subscribed('default')) {
            // 這位使用者不是付費客戶...
            return redirect('/billing');
        }

        return $next($request);
    }
}
```

如果你想確定使用者是否仍處於試用期內，可以使用 `onTrial` 方法。此方法對於確定是否應向使用者顯示他們仍處於試用期內的警告很有用：

```php
if ($user->subscription('default')->onTrial()) {
    // ...
}
```

`subscribedToProduct` 方法可用於根據給定的 Stripe 產品識別碼確定使用者是否訂閱了給定產品。在 Stripe 中，產品是價格的集合。在此範例中，我們將確定使用者的 `default` 訂閱是否有效訂閱了應用程式的「premium」產品。給定的 Stripe 產品識別碼應對應於 Stripe 儀表板中的產品識別碼之一：

```php
if ($user->subscribedToProduct('prod_premium', 'default')) {
    // ...
}
```

透過將陣列傳遞給 `subscribedToProduct` 方法，你可以確定使用者的 `default` 訂閱是否有效訂閱了應用程式的「basic」或「premium」產品：

```php
if ($user->subscribedToProduct(['prod_basic', 'prod_premium'], 'default')) {
    // ...
}
```

`subscribedToPrice` 方法可用於確定客戶的訂閱是否對應於給定的價格 ID：

```php
if ($user->subscribedToPrice('price_basic_monthly', 'default')) {
    // ...
}
```

`recurring` 方法可用於確定使用者目前是否已訂閱且不再處於試用期內：

```php
if ($user->subscription('default')->recurring()) {
    // ...
}
```

> [!WARNING]
> 如果使用者有兩個相同類型的訂閱，`subscription` 方法將始終回傳最近的訂閱。例如，使用者可能有兩個類型為 `default` 的訂閱記錄；然而，其中一個訂閱可能是一個舊的、已過期的訂閱，而另一個是當前的、有效的訂閱。最近的訂閱將始終被回傳，而較舊的訂閱保留在資料庫中以供歷史審查。

<a name="cancelled-subscription-status"></a>
#### 已取消的訂閱狀態 (Canceled Subscription Status)

要確定使用者是否曾是有效訂閱者但已取消訂閱，可以使用 `canceled` 方法：

```php
if ($user->subscription('default')->canceled()) {
    // ...
}
```

你也可以確定使用者是否已取消訂閱，但仍處於「寬限期」，直到訂閱完全過期。例如，如果使用者在 3 月 5 日取消了原定於 3 月 10 日到期的訂閱，則使用者在 3 月 10 日之前處於「寬限期」。請注意，在此期間 `subscribed` 方法仍回傳 `true`：

```php
if ($user->subscription('default')->onGracePeriod()) {
    // ...
}
```

要確定使用者是否已取消訂閱且不再處於「寬限期」內，可以使用 `ended` 方法：

```php
if ($user->subscription('default')->ended()) {
    // ...
}
```

<a name="incomplete-and-past-due-status"></a>
#### 未完成和逾期狀態 (Incomplete and Past Due Status)

如果訂閱在建立後需要二次付款操作，訂閱將被標記為 `incomplete`。訂閱狀態儲存在 Cashier 的 `subscriptions` 資料庫資料表的 `stripe_status` 欄位中。

同樣地，如果在交換價格時需要二次付款操作，訂閱將被標記為 `past_due`。當你的訂閱處於這兩種狀態之一時，直到客戶確認付款之前，它將不會啟用。確定訂閱是否有未完成的付款可以使用可計費模型或訂閱實例上的 `hasIncompletePayment` 方法來完成：

```php
if ($user->hasIncompletePayment('default')) {
    // ...
}

if ($user->subscription('default')->hasIncompletePayment()) {
    // ...
}
```

當訂閱有未完成的付款時，你應該將使用者引導至 Cashier 的付款確認頁面，並傳遞 `latestPayment` 識別碼。你可以使用訂閱實例上可用的 `latestPayment` 方法來檢索此識別碼：

```html
<a href="{{ route('cashier.payment', $subscription->latestPayment()->id) }}">
  請確認你的付款。
</a>
```

如果你希望訂閱在 `past_due` 或 `incomplete` 狀態下仍被視為有效，你可以使用 Cashier 提供的 `keepPastDueSubscriptionsActive` 和 `keepIncompleteSubscriptionsActive` 方法。通常，這些方法應在 `App\Providers\AppServiceProvider` 的 `register` 方法中呼叫：

```php
use Laravel\Cashier\Cashier;

/**
 * Register any application services.
 */
public function register(): void
{
    Cashier::keepPastDueSubscriptionsActive();
    Cashier::keepIncompleteSubscriptionsActive();
}
```

> [!WARNING]
> 當訂閱處於 `incomplete` 狀態時，直到確認付款之前都無法更改。因此，當訂閱處於 `incomplete` 狀態時，`swap` 和 `updateQuantity` 方法將拋出例外。

<a name="subscription-scopes"></a>
#### 訂閱範圍 (Subscription Scopes)

大多數訂閱狀態也可用作查詢範圍，以便你可以輕鬆查詢資料庫中處於給定狀態的訂閱：

```php
// 獲取所有有效訂閱...
$subscriptions = Subscription::query()->active()->get();

// 獲取使用者的所有已取消訂閱...
$subscriptions = $user->subscriptions()->canceled()->get();
```

可用範圍的完整列表如下：

```php
Subscription::query()->active();
Subscription::query()->canceled();
Subscription::query()->ended();
Subscription::query()->incomplete();
Subscription::query()->notCanceled();
Subscription::query()->notOnGracePeriod();
Subscription::query()->notOnTrial();
Subscription::query()->onGracePeriod();
Subscription::query()->onTrial();
Subscription::query()->pastDue();
Subscription::query()->recurring();
```

<a name="changing-prices"></a>
### 更改價格 (Changing Prices)

客戶訂閱你的應用程式後，他們可能偶爾會想更改為新的訂閱價格。要將客戶交換到新價格，請將 Stripe 價格的識別碼傳遞給 `swap` 方法。交換價格時，假設使用者希望重新啟用他們的訂閱（如果之前已取消）。給定的價格識別碼應對應於 Stripe 儀表板中可用的 Stripe 價格識別碼：

```php
use App\Models\User;

$user = App\Models\User::find(1);

$user->subscription('default')->swap('price_yearly');
```

如果客戶處於試用期，試用期將被保留。此外，如果訂閱存在「數量」，該數量也將被保留。

如果你想交換價格並取消客戶目前所在的任何試用期，可以使用 `skipTrial` 方法：

```php
$user->subscription('default')
    ->skipTrial()
    ->swap('price_yearly');
```

如果你想交換價格並立即向客戶開立發票，而不是等待下一個計費週期，可以使用 `swapAndInvoice` 方法：

```php
$user = User::find(1);

$user->subscription('default')->swapAndInvoice('price_yearly');
```

<a name="prorations"></a>
#### 依比例計算 (Prorations)

預設情況下，Stripe 在交換價格時會依比例計算費用。`noProrate` 方法可用於在不依比例計算費用的情況下更新訂閱價格：

```php
$user->subscription('default')->noProrate()->swap('price_yearly');
```

有關訂閱依比例計算的更多資訊，請參閱 [Stripe 文件](https://stripe.com/docs/billing/subscriptions/prorations)。

> [!WARNING]
> 在 `swapAndInvoice` 方法之前執行 `noProrate` 方法對依比例計算沒有影響。將始終開立發票。

<a name="subscription-quantity"></a>
### 訂閱數量 (Subscription Quantity)

有時訂閱會受到「數量」的影響。例如，專案管理應用程式可能每月向每個專案收取 10 美元。你可以使用 `incrementQuantity` 和 `decrementQuantity` 方法輕鬆增加或減少訂閱數量：

```php
use App\Models\User;

$user = User::find(1);

$user->subscription('default')->incrementQuantity();

// Add five to the subscription's current quantity...
$user->subscription('default')->incrementQuantity(5);

$user->subscription('default')->decrementQuantity();

// Subtract five from the subscription's current quantity...
$user->subscription('default')->decrementQuantity(5);
```

Alternatively, you may set a specific quantity using the `updateQuantity` method:

```php
$user->subscription('default')->updateQuantity(10);
```

`noProrate` 方法可用於在不依比例計算費用的情況下更新訂閱數量：

```php
$user->subscription('default')->noProrate()->updateQuantity(10);
```

有關訂閱數量的更多資訊，請參閱 [Stripe 文件](https://stripe.com/docs/subscriptions/quantities)。

<a name="quantities-for-subscription-with-multiple-products"></a>
#### 具有多個產品的訂閱的數量 (Quantities for Subscriptions With Multiple Products)

如果你的訂閱是 [具有多個產品的訂閱](#subscriptions-with-multiple-products)，你應該將希望增加或減少數量的價格的 ID 作為第二個參數傳遞給增加 / 減少方法：

```php
$user->subscription('default')->incrementQuantity(1, 'price_chat');
```

<a name="subscriptions-with-multiple-products"></a>
### 具有多個產品的訂閱 (Subscriptions With Multiple Products)

[具有多個產品的訂閱](https://stripe.com/docs/billing/subscriptions/multiple-products) 允許你將多個計費產品分配給單個訂閱。例如，想像一下你正在建立一個客戶服務「幫助台」應用程式，其基本訂閱價格為每月 10 美元，但提供每月額外 15 美元的即時聊天附加產品。具有多個產品的訂閱資訊儲存在 Cashier 的 `subscription_items` 資料表中。

你可以透過將價格陣列作為第二個參數傳遞給 `newSubscription` 方法來為給定訂閱指定多個產品：

```php
use Illuminate\Http\Request;

Route::post('/user/subscribe', function (Request $request) {
    $request->user()->newSubscription('default', [
        'price_monthly',
        'price_chat',
    ])->create($request->paymentMethodId);

    // ...
});
```

在上面的範例中，客戶的 `default` 訂閱將附加兩個價格。這兩個價格都將按其各自的計費週期收費。如果有必要，你可以使用 `quantity` 方法來為每個價格指定特定數量：

```php
$user = User::find(1);

$user->newSubscription('default', ['price_monthly', 'price_chat'])
    ->quantity(5, 'price_chat')
    ->create($paymentMethod);
```

如果你想向現有訂閱新增另一個價格，可以呼叫訂閱的 `addPrice` 方法：

```php
$user = User::find(1);

$user->subscription('default')->addPrice('price_chat');
```

上面的範例將新增新價格，客戶將在下一個計費週期收到帳單。如果你想立即向客戶收費，可以使用 `addPriceAndInvoice` 方法：

```php
$user->subscription('default')->addPriceAndInvoice('price_chat');
```

如果你想新增具有特定數量的價格，可以將數量作為 `addPrice` 或 `addPriceAndInvoice` 方法的第二個參數傳遞：

```php
$user = User::find(1);

$user->subscription('default')->addPrice('price_chat', 5);
```

你可以使用 `removePrice` 方法從訂閱中移除價格：

```php
$user->subscription('default')->removePrice('price_chat');
```

> [!WARNING]
> 你不能移除訂閱的最後一個價格。相反，你應該簡單地取消訂閱。

<a name="swapping-prices"></a>
#### 交換價格 (Swapping Prices)

你也可以更改附加到具有多個產品的訂閱的價格。例如，想像一下客戶擁有帶有 `price_chat` 附加產品的 `price_basic` 訂閱，你想將客戶從 `price_basic` 升級到 `price_pro` 價格：

```php
use App\Models\User;

$user = User::find(1);

$user->subscription('default')->swap(['price_pro', 'price_chat']);
```

執行上面的範例時，帶有 `price_basic` 的底層訂閱項目將被刪除，而帶有 `price_chat` 的項目將被保留。此外，將為 `price_pro` 建立一個新的訂閱項目。

你也可以透過將鍵 / 值對陣列傳遞給 `swap` 方法來指定訂閱項目選項。例如，你可能需要指定訂閱價格數量：

```php
$user = User::find(1);

$user->subscription('default')->swap([
    'price_pro' => ['quantity' => 5],
    'price_chat'
]);
```

如果你想交換訂閱上的單個價格，可以在訂閱項目本身上使用 `swap` 方法。如果你想保留訂閱其他價格的所有現有中繼資料，此方法特別有用：

```php
$user = User::find(1);

$user->subscription('default')
    ->findItemOrFail('price_basic')
    ->swap('price_pro');
```

<a name="proration"></a>
#### 依比例計算 (Proration)

預設情況下，當從具有多個產品的訂閱中新增或移除價格時，Stripe 將依比例計算費用。如果你想在不依比例計算的情況下進行價格調整，你應該將 `noProrate` 方法串連到你的價格操作上：

```php
$user->subscription('default')->noProrate()->removePrice('price_chat');
```

<a name="swapping-quantities"></a>
#### 數量 (Quantities)

如果你想更新各個訂閱價格的數量，可以使用 [現有的數量方法](#subscription-quantity)，並將價格 ID 作為該方法的額外參數傳遞：

```php
$user = User::find(1);

$user->subscription('default')->incrementQuantity(5, 'price_chat');

$user->subscription('default')->decrementQuantity(3, 'price_chat');

$user->subscription('default')->updateQuantity(10, 'price_chat');
```

> [!WARNING]
> 當訂閱有多個價格時，`Subscription` 模型上的 `stripe_price` 和 `quantity` 屬性將為 `null`。要存取各個價格屬性，你應該使用 `Subscription` 模型上可用的 `items` 關聯。

<a name="subscription-items"></a>
#### 訂閱項目 (Subscription Items)

當訂閱有多個價格時，它將在資料庫的 `subscription_items` 資料表中擁有多個訂閱「項目」。你可以透過訂閱上的 `items` 關聯來存取這些項目：

```php
use App\Models\User;

$user = User::find(1);

$subscriptionItem = $user->subscription('default')->items->first();

// 檢索特定項目的 Stripe 價格和數量...
$stripePrice = $subscriptionItem->stripe_price;
$quantity = $subscriptionItem->quantity;
```

你也可以使用 `findItemOrFail` 方法檢索特定價格：

```php
$user = User::find(1);

$subscriptionItem = $user->subscription('default')->findItemOrFail('price_chat');
```

<a name="multiple-subscriptions"></a>
### 多個訂閱 (Multiple Subscriptions)

Stripe 允許你的客戶同時擁有多個訂閱。例如，你可能經營一家健身房，提供游泳訂閱和舉重訂閱，並且每個訂閱可能有不同的定價。當然，客戶應該能夠訂閱其中一個或兩個方案。

當你的應用程式建立訂閱時，你可以向 `newSubscription` 方法提供訂閱類型。類型可以是代表使用者正在啟動的訂閱類型的任何字串：

```php
use Illuminate\Http\Request;

Route::post('/swimming/subscribe', function (Request $request) {
    $request->user()->newSubscription('swimming')
        ->price('price_swimming_monthly')
        ->create($request->paymentMethodId);

    // ...
});
```

在此範例中，我們為客戶啟動了每月游泳訂閱。然而，如果不滿意，他們可能會想在以後交換到年度訂閱。當調整客戶的訂閱時，我們可以簡單地交換 `swimming` 訂閱上的價格：

```php
$user->subscription('swimming')->swap('price_swimming_yearly');
```

當然，你也可以完全取消訂閱：

```php
$user->subscription('swimming')->cancel();
```

<a name="usage-based-billing"></a>
### 基於使用量的計費 (Usage Based Billing)

[基於使用量的計費](https://stripe.com/docs/billing/subscriptions/metered-billing) 允許你根據客戶在計費週期內的產品使用量向他們收費。例如，你可以根據客戶每月發送的簡訊或電子郵件數量向他們收費。

要開始使用用量計費，你首先需要在 Stripe 儀表板中建立一個具有 [基於使用量的計費模型](https://docs.stripe.com/billing/subscriptions/usage-based/implementation-guide) 和 [計量器](https://docs.stripe.com/billing/subscriptions/usage-based/recording-usage#configure-meter) 的新產品。建立計量器後，儲存相關的事件名稱和計量器 ID，你需要它們來報告和檢索用量。然後，使用 `meteredPrice` 方法將計量價格 ID 新增到客戶訂閱：

```php
use Illuminate\Http\Request;

Route::post('/user/subscribe', function (Request $request) {
    $request->user()->newSubscription('default')
        ->meteredPrice('price_metered')
        ->create($request->paymentMethodId);

    // ...
});
```

你也可以透過 [Stripe Checkout](#checkout) 啟動計量訂閱：

```php
$checkout = Auth::user()
    ->newSubscription('default', [])
    ->meteredPrice('price_metered')
    ->checkout();

return view('your-checkout-view', [
    'checkout' => $checkout,
]);
```

<a name="reporting-usage"></a>
#### 報告用量 (Reporting Usage)

當你的客戶使用你的應用程式時，你將向 Stripe 報告他們的用量，以便準確地向他們收費。要報告計量事件的用量，你可以使用 `Billable` 模型上的 `reportMeterEvent` 方法：

```php
$user = User::find(1);

$user->reportMeterEvent('emails-sent');
```

預設情況下，計費週期會新增 1 的「用量數量」。或者，你可以傳遞特定數量的「用量」以新增到客戶在計費週期的用量中：

```php
$user = User::find(1);

$user->reportMeterEvent('emails-sent', quantity: 15);
```

要檢索客戶計量器的事件摘要，你可以使用 `Billable` 實例的 `meterEventSummaries` 方法：

```php
$user = User::find(1);

$meterUsage = $user->meterEventSummaries($meterId);

$meterUsage->first()->aggregated_value // 10
```

有關計量器事件摘要的更多資訊，請參閱 Stripe 的 [計量器事件摘要物件文件](https://docs.stripe.com/api/billing/meter-event_summary/object)。

要 [列出所有計量器](https://docs.stripe.com/api/billing/meter/list)，你可以使用 `Billable` 實例的 `meters` 方法：

```php
$user = User::find(1);

$user->meters();
```

<a name="subscription-taxes"></a>
### 訂閱稅務 (Subscription Taxes)

> [!WARNING]
> 你可以使用 [Stripe Tax 自動計算稅款](#tax-configuration)，而不是手動計算稅率。

要指定使用者為訂閱支付的稅率，你應該在可計費模型上實作 `taxRates` 方法，並回傳包含 Stripe 稅率 ID 的陣列。你可以在 [Stripe 儀表板](https://dashboard.stripe.com/test/tax-rates) 中定義這些稅率：

```php
/**
 * The tax rates that should apply to the customer's subscriptions.
 *
 * @return array<int, string>
 */
public function taxRates(): array
{
    return ['txr_id'];
}
```

`taxRates` 方法使你能夠在逐個客戶的基礎上套用稅率，這對於跨越並擁有多個國家和稅率的使用者群可能很有幫助。

如果你提供具有多個產品的訂閱，你可以透過在可計費模型上實作 `priceTaxRates` 方法為每個價格定義不同的稅率：

```php
/**
 * The tax rates that should apply to the customer's subscriptions.
 *
 * @return array<string, array<int, string>>
 */
public function priceTaxRates(): array
{
    return [
        'price_monthly' => ['txr_id'],
    ];
}
```

> [!WARNING]
> `taxRates` 方法僅適用於訂閱費用。如果你使用 Cashier 進行「一次性」收費，你需要在當時手動指定稅率。

<a name="syncing-tax-rates"></a>
#### 同步稅率 (Syncing Tax Rates)

當更改 `taxRates` 方法回傳的硬編碼稅率 ID 時，使用者任何現有訂閱的稅務設定將保持不變。如果你希望使用新的 `taxRates` 值更新現有訂閱的稅務值，你應該在使用者訂閱實例上呼叫 `syncTaxRates` 方法：

```php
$user->subscription('default')->syncTaxRates();
```

這還將同步具有多個產品的訂閱的任何項目稅率。如果你的應用程式提供具有多個產品的訂閱，你應該確保你的可計費模型實作了 [上面討論的](#subscription-taxes) `priceTaxRates` 方法。

<a name="tax-exemption"></a>
#### 免稅 (Tax Exemption)

Cashier 還提供 `isNotTaxExempt`、`isTaxExempt` 和 `reverseChargeApplies` 方法來確定客戶是否免稅。這些方法將呼叫 Stripe API 來確定客戶的免稅狀態：

```php
use App\Models\User;

$user = User::find(1);

$user->isTaxExempt();
$user->isNotTaxExempt();
$user->reverseChargeApplies();
```

> [!WARNING]
> 這些方法也可以在任何 `Laravel\Cashier\Invoice` 物件上使用。然而，當在 `Invoice` 物件上呼叫時，這些方法將確定發票建立時的免稅狀態。

<a name="subscription-anchor-date"></a>
### 訂閱錨定日期 (Subscription Anchor Date)

預設情況下，計費週期錨點是建立訂閱的日期，或者如果使用試用期，則是試用結束的日期。如果你想修改計費錨定日期，可以使用 `anchorBillingCycleOn` 方法：

```php
use Illuminate\Http\Request;

Route::post('/user/subscribe', function (Request $request) {
    $anchor = Carbon::parse('first day of next month');

    $request->user()->newSubscription('default', 'price_monthly')
        ->anchorBillingCycleOn($anchor->startOfDay())
        ->create($request->paymentMethodId);

    // ...
});
```

有關管理訂閱計費週期的更多資訊，請諮詢 [Stripe 計費週期文件](https://stripe.com/docs/billing/subscriptions/billing-cycle)

<a name="cancelling-subscriptions"></a>
### 取消訂閱 (Canceling Subscriptions)

要取消訂閱，請在使用者訂閱上呼叫 `cancel` 方法：

```php
$user->subscription('default')->cancel();
```

取消訂閱後，Cashier 將自動設定 `subscriptions` 資料庫資料表中的 `ends_at` 欄位。此欄位用於了解 `subscribed` 方法何時應開始回傳 `false`。

例如，如果客戶在 3 月 1 日取消訂閱，但訂閱原定於 3 月 5 日才結束，則 `subscribed` 方法將繼續回傳 `true` 直到 3 月 5 日。這樣做是因為通常允許使用者繼續使用應用程式直到他們的計費週期結束。

你可以使用 `onGracePeriod` 方法確定使用者是否已取消訂閱但仍處於「寬限期」：

```php
if ($user->subscription('default')->onGracePeriod()) {
    // ...
}
```

如果你希望立即取消訂閱，請呼叫使用者訂閱上的 `cancelNow` 方法：

```php
$user->subscription('default')->cancelNow();
```

如果你希望立即取消訂閱並為任何剩餘的未開發票的計量用量或新的 / 待處理的依比例計算發票項目開立發票，請呼叫使用者訂閱上的 `cancelNowAndInvoice` 方法：

```php
$user->subscription('default')->cancelNowAndInvoice();
```

你也可以選擇在特定時間取消訂閱：

```php
$user->subscription('default')->cancelAt(
    now()->addDays(10)
);
```

最後，你應該始終在刪除相關使用者模型之前取消使用者訂閱：

```php
$user->subscription('default')->cancelNow();

$user->delete();
```

<a name="resuming-subscriptions"></a>
### 恢復訂閱 (Resuming Subscriptions)

如果客戶取消了訂閱，而你希望恢復它，你可以在訂閱上呼叫 `resume` 方法。客戶必須仍處於「寬限期」內才能恢復訂閱：

```php
$user->subscription('default')->resume();
```

如果客戶取消訂閱，然後在訂閱完全過期之前恢復該訂閱，則不會立即向客戶收費。相反，他們的訂閱將被重新啟用，並將在原來的計費週期向他們收費。

<a name="subscription-trials"></a>
## 訂閱試用 (Subscription Trials)

<a name="with-payment-method-up-front"></a>
### 預先提供付款方式 (With Payment Method Up Front)

如果你想向客戶提供試用期，同時仍預先收集付款方式資訊，你應該在建立訂閱時使用 `trialDays` 方法：

```php
use Illuminate\Http\Request;

Route::post('/user/subscribe', function (Request $request) {
    $request->user()->newSubscription('default', 'price_monthly')
        ->trialDays(10)
        ->create($request->paymentMethodId);

    // ...
});
```

此方法將在資料庫中的訂閱記錄上設定試用期結束日期，並指示 Stripe 在此日期之後才開始向客戶收費。當使用 `trialDays` 方法時，Cashier 將覆寫 Stripe 中為價格設定的任何預設試用期。

> [!WARNING]
> 如果客戶的訂閱未在試用結束日期之前取消，他們將在試用期滿後立即被收費，因此你應該務必通知使用者他們的試用結束日期。

`trialUntil` 方法允許你提供一個 `DateTime` 實例，用於指定試用期何時結束：

```php
use Illuminate\Support\Carbon;

$user->newSubscription('default', 'price_monthly')
    ->trialUntil(Carbon::now()->addDays(10))
    ->create($paymentMethod);
```

你可以使用使用者實例的 `onTrial` 方法或訂閱實例的 `onTrial` 方法來確定使用者是否處於試用期內。以下兩個範例是等效的：

```php
if ($user->onTrial('default')) {
    // ...
}

if ($user->subscription('default')->onTrial()) {
    // ...
}
```

你可以使用 `endTrial` 方法立即結束訂閱試用：

```php
$user->subscription('default')->endTrial();
```

要確定現有試用是否已過期，你可以使用 `hasExpiredTrial` 方法：

```php
if ($user->hasExpiredTrial('default')) {
    // ...
}

if ($user->subscription('default')->hasExpiredTrial()) {
    // ...
}
```

<a name="defining-trial-days-in-stripe-cashier"></a>
#### 在 Stripe / Cashier 中定義試用天數 (Defining Trial Days in Stripe / Cashier)

你可以選擇在 Stripe 儀表板中定義你的價格獲得多少試用天數，或者始終使用 Cashier 明確傳遞它們。如果你選擇在 Stripe 中定義價格的試用天數，你應該知道，除非你明確呼叫 `skipTrial()` 方法，否則新訂閱（包括過去擁有訂閱的客戶的新訂閱）將始終獲得試用期。

<a name="without-payment-method-up-front"></a>
### 無需預先提供付款方式 (Without Payment Method Up Front)

如果你想在不預先收集使用者付款方式資訊的情況下提供試用期，你可以將使用者記錄上的 `trial_ends_at` 欄位設定為你想要的試用結束日期。這通常在使用者註冊期間完成：

```php
use App\Models\User;

$user = User::create([
    // ...
    'trial_ends_at' => now()->addDays(10),
]);
```

> [!WARNING]
> 請務必在可計費模型的類別定義中為 `trial_ends_at` 屬性新增 [日期轉換 (Date Cast)](/docs/eloquent-mutators#date-casting)。

Cashier 將這種類型的試用稱為「通用試用」，因為它未附加到任何現有訂閱。如果當前日期未超過 `trial_ends_at` 的值，則可計費模型實例上的 `onTrial` 方法將回傳 `true`：

```php
if ($user->onTrial()) {
    // 使用者處於試用期...
}
```

一旦你準備好為使用者建立實際訂閱，你可以像往常一樣使用 `newSubscription` 方法：

```php
$user = User::find(1);

$user->newSubscription('default', 'price_monthly')->create($paymentMethod);
```

要檢索使用者的試用結束日期，可以使用 `trialEndsAt` 方法。如果使用者處於試用期，此方法將回傳 Carbon 日期實例，如果不是，則回傳 `null`。如果你想獲取預設訂閱以外的特定訂閱的試用結束日期，你也可以傳遞可選的訂閱類型參數：

```php
if ($user->onTrial()) {
    $trialEndsAt = $user->trialEndsAt('main');
}
```

如果你想特別知道使用者是否處於其「通用」試用期內且尚未建立實際訂閱，也可以使用 `onGenericTrial` 方法：

```php
if ($user->onGenericTrial()) {
    // 使用者處於「通用」試用期...
}
```

<a name="extending-trials"></a>
### 延長試用 (Extending Trials)

`extendTrial` 方法允許你在建立訂閱後延長訂閱的試用期。如果試用期已過期，並且客戶已開始為訂閱付費，你仍然可以為他們提供延長試用。試用期內花費的時間將從客戶的下一張發票中扣除：

```php
use App\Models\User;

$subscription = User::find(1)->subscription('default');

// 在 7 天後結束試用...
$subscription->extendTrial(
    now()->addDays(7)
);

// 試用期再增加 5 天...
$subscription->extendTrial(
    $subscription->trial_ends_at->addDays(5)
);
```

<a name="handling-stripe-webhooks"></a>
## 處理 Stripe Webhook (Handling Stripe Webhooks)

> [!NOTE]
> 你可以使用 [Stripe CLI](https://stripe.com/docs/stripe-cli) 來協助在本機開發期間測試 Webhook。

Stripe 可以透過 Webhook 通知你的應用程式各種事件。預設情況下，指向 Cashier Webhook 控制器的路由由 Cashier 服務提供者自動註冊。此控制器將處理所有傳入的 Webhook 請求。

By default, the Cashier webhook controller will automatically handle cancelling subscriptions that have too many failed charges (as defined by your Stripe settings), customer updates, customer deletions, subscription updates, and payment method changes; however, as we'll soon discover, you can extend this controller to handle any Stripe webhook event you like.

To ensure your application can handle Stripe webhooks, be sure to configure the webhook URL in the Stripe control panel. By default, Cashier's webhook controller responds to the `/stripe/webhook` URL path. The full list of all webhooks you should enable in the Stripe control panel are:

- `customer.subscription.created`
- `customer.subscription.updated`
- `customer.subscription.deleted`
- `customer.updated`
- `customer.deleted`
- `payment_method.automatically_updated`
- `invoice.payment_action_required`
- `invoice.payment_succeeded`

For convenience, Cashier includes a `cashier:webhook` Artisan command. This command will create a webhook in Stripe that listens to all of the events required by Cashier:

```shell
php artisan cashier:webhook
```

By default, the created webhook will point to the URL defined by the `APP_URL` environment variable and the `cashier.webhook` route that is included with Cashier. You may provide the `--url` option when invoking the command if you would like to use a different URL:

```shell
php artisan cashier:webhook --url "https://example.com/stripe/webhook"
```

The webhook that is created will use the Stripe API version that your version of Cashier is compatible with. If you would like to use a different Stripe version, you may provide the `--api-version` option:

```shell
php artisan cashier:webhook --api-version="2019-12-03"
```

After creation, the webhook will be immediately active. If you wish to create the webhook but have it disabled until you're ready, you may provide the `--disabled` option when invoking the command:

```shell
php artisan cashier:webhook --disabled
```

> [!WARNING]
> Make sure you protect incoming Stripe webhook requests with Cashier's included [webhook signature verification](#verifying-webhook-signatures) middleware.

<a name="webhooks-csrf-protection"></a>
#### Webhooks and CSRF Protection

Since Stripe webhooks need to bypass Laravel's [CSRF protection](/docs/csrf), you should ensure that Laravel does not attempt to validate the CSRF token for incoming Stripe webhooks. To accomplish this, you should exclude `stripe/*` from CSRF protection in your application's `bootstrap/app.php` file:

```php
->withMiddleware(function (Middleware $middleware): void {
    $middleware->validateCsrfTokens(except: [
        'stripe/*',
    ]);
})
```

<a name="defining-webhook-event-handlers"></a>
### 定義 Webhook 事件處理器 (Defining Webhook Event Handlers)

Cashier 會自動處理失敗收費的訂閱取消和其他常見的 Stripe Webhook 事件。但是，如果你有其他想要處理的 Webhook 事件，你可以透過監聽 Cashier 派發的以下事件來完成：

- `Laravel\Cashier\Events\WebhookReceived`
- `Laravel\Cashier\Events\WebhookHandled`

Both events contain the full payload of the Stripe webhook. For example, if you wish to handle the `invoice.payment_succeeded` webhook, you may register a [listener](/docs/events#defining-listeners) that will handle the event:

```php
<?php

namespace App\Listeners;

use Laravel\Cashier\Events\WebhookReceived;

class StripeEventListener
{
    /**
     * Handle received Stripe webhooks.
     */
    public function handle(WebhookReceived $event): void
    {
        if ($event->payload['type'] === 'invoice.payment_succeeded') {
            // Handle the incoming event...
        }
    }
}
```

<a name="verifying-webhook-signatures"></a>
### 驗證 Webhook 簽章 (Verifying Webhook Signatures)

為了保護你的 Webhook，你可以使用 [Stripe 的 Webhook 簽章](https://stripe.com/docs/webhooks/signatures)。為了方便起見，Cashier 自動包含一個 Middleware，用於驗證傳入的 Stripe Webhook 請求是否有效。

To enable webhook verification, ensure that the `STRIPE_WEBHOOK_SECRET` environment variable is set in your application's `.env` file. The webhook `secret` may be retrieved from your Stripe account dashboard.

<a name="single-charges"></a>
## 單次收費 (Single Charges)

<a name="simple-charge"></a>
### 簡單收費 (Simple Charge)

如果你想對客戶進行一次性收費，可以在可計費模型實例上使用 `charge` 方法。你需要 [提供付款方式識別碼](#payment-methods-for-single-charges) 作為 `charge` 方法的第二個參數：

```php
use Illuminate\Http\Request;

Route::post('/purchase', function (Request $request) {
    $stripeCharge = $request->user()->charge(
        100, $request->paymentMethodId
    );

    // ...
});
```

The `charge` method accepts an array as its third argument, allowing you to pass any options you wish to the underlying Stripe charge creation. More information regarding the options available to you when creating charges may be found in the [Stripe documentation](https://stripe.com/docs/api/charges/create):

```php
$user->charge(100, $paymentMethod, [
    'custom_option' => $value,
]);
```

You may also use the `charge` method without an underlying customer or user. To accomplish this, invoke the `charge` method on a new instance of your application's billable model:

```php
use App\Models\User;

$stripeCharge = (new User)->charge(100, $paymentMethod);
```

The `charge` method will throw an exception if the charge fails. If the charge is successful, an instance of `Laravel\Cashier\Payment` will be returned from the method:

```php
try {
    $payment = $user->charge(100, $paymentMethod);
} catch (Exception $e) {
    // ...
}
```

> [!WARNING]
> The `charge` method accepts the payment amount in the lowest denominator of the currency used by your application. For example, if customers are paying in United States Dollars, amounts should be specified in pennies.

<a name="charge-with-invoice"></a>
### 發票收費 (Charge With Invoice)

有時你可能需要進行一次性收費並向客戶提供 PDF 發票。`invoicePrice` 方法可以讓你做到這一點。例如，讓我們向客戶開具五件新襯衫的發票：

```php
$user->invoicePrice('price_tshirt', 5);
```

The invoice will be immediately charged against the user's default payment method. The `invoicePrice` method also accepts an array as its third argument. This array contains the billing options for the invoice item. The fourth argument accepted by the method is also an array which should contain the billing options for the invoice itself:

```php
$user->invoicePrice('price_tshirt', 5, [
    'discounts' => [
        ['coupon' => 'SUMMER21SALE']
    ],
], [
    'default_tax_rates' => ['txr_id'],
]);
```

Similarly to `invoicePrice`, you may use the `tabPrice` method to create a one-time charge for multiple items (up to 250 items per invoice) by adding them to the customer's "tab" and then invoicing the customer. For example, we may invoice a customer for five shirts and two mugs:

```php
$user->tabPrice('price_tshirt', 5);
$user->tabPrice('price_mug', 2);
$user->invoice();
```

Alternatively, you may use the `invoiceFor` method to make a "one-off" charge against the customer's default payment method:

```php
$user->invoiceFor('One Time Fee', 500);
```

Although the `invoiceFor` method is available for you to use, it is recommended that you use the `invoicePrice` and `tabPrice` methods with pre-defined prices. By doing so, you will have access to better analytics and data within your Stripe dashboard regarding your sales on a per-product basis.

> [!WARNING]
> The `invoice`, `invoicePrice`, and `invoiceFor` methods will create a Stripe invoice which will retry failed billing attempts. If you do not want invoices to retry failed charges, you will need to close them using the Stripe API after the first failed charge.

<a name="creating-payment-intents"></a>
### 建立 Payment Intent (Creating Payment Intents)

你可以透過在可計費模型實例上呼叫 `pay` 方法來建立新的 Stripe Payment Intent。呼叫此方法將建立一個包裝在 `Laravel\Cashier\Payment` 實例中的 Payment Intent：

```php
use Illuminate\Http\Request;

Route::post('/pay', function (Request $request) {
    $payment = $request->user()->pay(
        $request->get('amount')
    );

    return $payment->client_secret;
});
```

After creating the payment intent, you can return the client secret to your application's frontend so that the user can complete the payment in their browser. To read more about building entire payment flows using Stripe payment intents, please consult the [Stripe documentation](https://stripe.com/docs/payments/accept-a-payment?platform=web).

When using the `pay` method, the default payment methods that are enabled within your Stripe dashboard will be available to the customer. Alternatively, if you only want to allow for some specific payment methods to be used, you may use the `payWith` method:

```php
use Illuminate\Http\Request;

Route::post('/pay', function (Request $request) {
    $payment = $request->user()->payWith(
        $request->get('amount'), ['card', 'bancontact']
    );

    return $payment->client_secret;
});
```

> [!WARNING]
> The `pay` and `payWith` methods accept the payment amount in the lowest denominator of the currency used by your application. For example, if customers are paying in United States Dollars, amounts should be specified in pennies.

<a name="refunding-charges"></a>
### 退款 (Refunding Charges)

如果你需要退款 Stripe 收費，可以使用 `refund` 方法。此方法接受 Stripe [Payment Intent ID](#payment-methods-for-single-charges) 作為其第一個參數：

```php
$payment = $user->charge(100, $paymentMethodId);

$user->refund($payment->id);
```

<a name="invoices"></a>
## 發票 (Invoices)

<a name="retrieving-invoices"></a>
### 檢索發票 (Retrieving Invoices)

你可以使用 `invoices` 方法輕鬆檢索可計費模型的發票陣列。`invoices` 方法回傳 `Laravel\Cashier\Invoice` 實例的集合：

```php
$invoices = $user->invoices();
```

If you would like to include pending invoices in the results, you may use the `invoicesIncludingPending` method:

```php
$invoices = $user->invoicesIncludingPending();
```

You may use the `findInvoice` method to retrieve a specific invoice by its ID:

```php
$invoice = $user->findInvoice($invoiceId);
```

<a name="displaying-invoice-information"></a>
#### 顯示發票資訊 (Displaying Invoice Information)

列出客戶的發票時，你可以使用發票的方法來顯示相關的發票資訊。例如，你可能希望在表格中列出每個發票，允許使用者輕鬆下載其中任何一個：

```blade
<table>
    @foreach ($invoices as $invoice)
        <tr>
            <td>{{ $invoice->date()->toFormattedDateString() }}</td>
            <td>{{ $invoice->total() }}</td>
            <td><a href="/user/invoice/{{ $invoice->id }}">Download</a></td>
        </tr>
    @endforeach
</table>
```

<a name="upcoming-invoices"></a>
### 即將到來的發票 (Upcoming Invoices)

要檢索客戶即將到來的發票，可以使用 `upcomingInvoice` 方法：

```php
$invoice = $user->upcomingInvoice();
```

Similarly, if the customer has multiple subscriptions, you can also retrieve the upcoming invoice for a specific subscription:

```php
$invoice = $user->subscription('default')->upcomingInvoice();
```

<a name="previewing-subscription-invoices"></a>
### 預覽訂閱發票 (Previewing Subscription Invoices)

使用 `previewInvoice` 方法，你可以在更改價格之前預覽發票。這將允許你確定在進行給定價格更改時客戶的發票會是什麼樣子：

```php
$invoice = $user->subscription('default')->previewInvoice('price_yearly');
```

You may pass an array of prices to the `previewInvoice` method in order to preview invoices with multiple new prices:

```php
$invoice = $user->subscription('default')->previewInvoice(['price_yearly', 'price_metered']);
```

<a name="generating-invoice-pdfs"></a>
### 產生發票 PDF (Generating Invoice PDFs)

在產生發票 PDF 之前，你應該使用 Composer 安裝 Dompdf 函式庫，這是 Cashier 的預設發票渲染器：

```shell
composer require dompdf/dompdf
```

From within a route or controller, you may use the `downloadInvoice` method to generate a PDF download of a given invoice. This method will automatically generate the proper HTTP response needed to download the invoice:

```php
use Illuminate\Http\Request;

Route::get('/user/invoice/{invoice}', function (Request $request, string $invoiceId) {
    return $request->user()->downloadInvoice($invoiceId);
});
```

By default, all data on the invoice is derived from the customer and invoice data stored in Stripe. The filename is based on your `app.name` config value. However, you can customize some of this data by providing an array as the second argument to the `downloadInvoice` method. This array allows you to customize information such as your company and product details:

```php
return $request->user()->downloadInvoice($invoiceId, [
    'vendor' => 'Your Company',
    'product' => 'Your Product',
    'street' => 'Main Str. 1',
    'location' => '2000 Antwerp, Belgium',
    'phone' => '+32 499 00 00 00',
    'email' => 'info@example.com',
    'url' => 'https://example.com',
    'vendorVat' => 'BE123456789',
]);
```

The `downloadInvoice` method also allows for a custom filename via its third argument. This filename will automatically be suffixed with `.pdf`:

```php
return $request->user()->downloadInvoice($invoiceId, [], 'my-invoice');
```

<a name="custom-invoice-render"></a>
#### 自訂發票渲染器 (Custom Invoice Renderer)

Cashier 也使得使用自訂發票渲染器成為可能。預設情況下，Cashier 使用 `DompdfInvoiceRenderer` 實作，該實作利用 [dompdf](https://github.com/dompdf/dompdf) PHP 函式庫來產生 Cashier 的發票。但是，你可以透過實作 `Laravel\Cashier\Contracts\InvoiceRenderer` 介面來使用任何你想要的渲染器。例如，你可能希望使用對第三方 PDF 渲染服務的 API 呼叫來渲染發票 PDF：

```php
use Illuminate\Support\Facades\Http;
use Laravel\Cashier\Contracts\InvoiceRenderer;
use Laravel\Cashier\Invoice;

class ApiInvoiceRenderer implements InvoiceRenderer
{
    /**
     * Render the given invoice and return the raw PDF bytes.
     */
    public function render(Invoice $invoice, array $data = [], array $options = []): string
    {
        $html = $invoice->view($data)->render();

        return Http::get('https://example.com/html-to-pdf', ['html' => $html])->get()->body();
    }
}
```

Once you have implemented the invoice renderer contract, you should update the `cashier.invoices.renderer` configuration value in your application's `config/cashier.php` configuration file. This configuration value should be set to the class name of your custom renderer implementation.

<a name="checkout"></a>
## Checkout

Cashier Stripe 也提供對 [Stripe Checkout](https://stripe.com/payments/checkout) 的支援。Stripe Checkout 透過提供預先建立的託管付款頁面，消除了實作自訂頁面以接受付款的痛苦。

以下文件包含有關如何開始使用 Stripe Checkout 與 Cashier 的資訊。要了解有關 Stripe Checkout 的更多資訊，你還應該考慮查看 [Stripe 自己的 Checkout 文件](https://stripe.com/docs/payments/checkout)。

<a name="product-checkouts"></a>
### 產品 Checkout (Product Checkouts)

你可以使用可計費模型上的 `checkout` 方法對 Stripe 儀表板中已建立的現有產品執行 Checkout。`checkout` 方法將啟動一個新的 Stripe Checkout 會話。預設情況下，你需要傳遞 Stripe Price ID：

```php
use Illuminate\Http\Request;

Route::get('/product-checkout', function (Request $request) {
    return $request->user()->checkout('price_tshirt');
});
```

If needed, you may also specify a product quantity:

```php
use Illuminate\Http\Request;

Route::get('/product-checkout', function (Request $request) {
    return $request->user()->checkout(['price_tshirt' => 15]);
});
```

When a customer visits this route they will be redirected to Stripe's Checkout page. By default, when a user successfully completes or cancels a purchase they will be redirected to your `home` route location, but you may specify custom callback URLs using the `success_url` and `cancel_url` options:

```php
use Illuminate\Http\Request;

Route::get('/product-checkout', function (Request $request) {
    return $request->user()->checkout(['price_tshirt' => 1], [
        'success_url' => route('your-success-route'),
        'cancel_url' => route('your-cancel-route'),
    ]);
});
```

When defining your `success_url` checkout option, you may instruct Stripe to add the checkout session ID as a query string parameter when invoking your URL. To do so, add the literal string `{CHECKOUT_SESSION_ID}` to your `success_url` query string. Stripe will replace this placeholder with the actual checkout session ID:

```php
use Illuminate\Http\Request;
use Stripe\Checkout\Session;
use Stripe\Customer;

Route::get('/product-checkout', function (Request $request) {
    return $request->user()->checkout(['price_tshirt' => 1], [
        'success_url' => route('checkout-success').'?session_id={CHECKOUT_SESSION_ID}',
        'cancel_url' => route('checkout-cancel'),
    ]);
});

Route::get('/checkout-success', function (Request $request) {
    $checkoutSession = $request->user()->stripe()->checkout->sessions->retrieve($request->get('session_id'));

    return view('checkout.success', ['checkoutSession' => $checkoutSession]);
})->name('checkout-success');
```

<a name="checkout-promotion-codes"></a>
#### 促銷代碼 (Promotion Codes)

預設情況下，Stripe Checkout 不允許 [使用者可兌換的促銷代碼](https://stripe.com/docs/billing/subscriptions/discounts/codes)。幸運的是，有一種簡單的方法可以為你的 Checkout 頁面啟用這些功能。為此，你可以呼叫 `allowPromotionCodes` 方法：

```php
use Illuminate\Http\Request;

Route::get('/product-checkout', function (Request $request) {
    return $request->user()
        ->allowPromotionCodes()
        ->checkout('price_tshirt');
});
```

<a name="single-charge-checkouts"></a>
### 單次收費 Checkout (Single Charge Checkouts)

你也可以對未在 Stripe 儀表板中建立的臨時產品執行簡單收費。為此，你可以在可計費模型上使用 `checkoutCharge` 方法，並傳遞可收費金額、產品名稱和可選數量。當客戶造訪此路由時，他們將被重新導向到 Stripe 的 Checkout 頁面：

```php
use Illuminate\Http\Request;

Route::get('/charge-checkout', function (Request $request) {
    return $request->user()->checkoutCharge(1200, 'T-Shirt', 5);
});
```

> [!WARNING]
> When using the `checkoutCharge` method, Stripe will always create a new product and price in your Stripe dashboard. Therefore, we recommend that you create the products up front in your Stripe dashboard and use the `checkout` method instead.

<a name="subscription-checkouts"></a>
### 訂閱 Checkout (Subscription Checkouts)

> [!WARNING]
> 使用 Stripe Checkout 進行訂閱需要在 Stripe 儀表板中啟用 `customer.subscription.created` Webhook。此 Webhook 將在你的資料庫中建立訂閱記錄並儲存所有相關的訂閱項目。

你也可以使用 Stripe Checkout 來啟動訂閱。使用 Cashier 的訂閱建構器方法定義訂閱後，你可以呼叫 `checkout` 方法。當客戶造訪此路由時，他們將被重新導向到 Stripe 的 Checkout 頁面：

```php
use Illuminate\Http\Request;

Route::get('/subscription-checkout', function (Request $request) {
    return $request->user()
        ->newSubscription('default', 'price_monthly')
        ->checkout();
});
```

Just as with product checkouts, you may customize the success and cancellation URLs:

```php
use Illuminate\Http\Request;

Route::get('/subscription-checkout', function (Request $request) {
    return $request->user()
        ->newSubscription('default', 'price_monthly')
        ->checkout([
            'success_url' => route('your-success-route'),
            'cancel_url' => route('your-cancel-route'),
        ]);
});
```

Of course, you can also enable promotion codes for subscription checkouts:

```php
use Illuminate\Http\Request;

Route::get('/subscription-checkout', function (Request $request) {
    return $request->user()
        ->newSubscription('default', 'price_monthly')
        ->allowPromotionCodes()
        ->checkout();
});
```

> [!WARNING]
> Unfortunately Stripe Checkout does not support all subscription billing options when starting subscriptions. Using the `anchorBillingCycleOn` method on the subscription builder, setting proration behavior, or setting payment behavior will not have any effect during Stripe Checkout sessions. Please consult [the Stripe Checkout Session API documentation](https://stripe.com/docs/api/checkout/sessions/create) to review which parameters are available.

<a name="stripe-checkout-trial-periods"></a>
#### Stripe Checkout 與試用期 (Stripe Checkout and Trial Periods)

當然，你可以在建立將使用 Stripe Checkout 完成的訂閱時定義試用期：

```php
$checkout = Auth::user()->newSubscription('default', 'price_monthly')
    ->trialDays(3)
    ->checkout();
```

但是，試用期必須至少為 48 小時，這是 Stripe Checkout 支援的最短試用時間。

<a name="stripe-checkout-subscriptions-and-webhooks"></a>
#### 訂閱與 Webhook (Subscriptions and Webhooks)

請記住，Stripe 和 Cashier 透過 Webhook 更新訂閱狀態，因此當客戶在輸入付款資訊後返回應用程式時，訂閱可能尚未生效。為了處理這種情況，你可能希望顯示一條訊息，通知使用者他們的付款或訂閱正在處理中。

<a name="collecting-tax-ids"></a>
### 收集稅務 ID (Collecting Tax IDs)

Checkout 也支援收集客戶的稅務 ID。要在 Checkout 會話上啟用此功能，請在建立會話時呼叫 `collectTaxIds` 方法：

```php
$checkout = $user->collectTaxIds()->checkout('price_tshirt');
```

When this method is invoked, a new checkbox will be available to the customer that allows them to indicate if they're purchasing as a company. If so, they will have the opportunity to provide their Tax ID number.

> [!WARNING]
> If you have already configured [automatic tax collection](#tax-configuration) in your application's service provider then this feature will be enabled automatically and there is no need to invoke the `collectTaxIds` method.

<a name="guest-checkouts"></a>
### 訪客 Checkout (Guest Checkouts)

使用 `Checkout::guest` 方法，你可以為沒有「帳戶」的應用程式訪客啟動 Checkout 會話：

```php
use Illuminate\Http\Request;
use Laravel\Cashier\Checkout;

Route::get('/product-checkout', function (Request $request) {
    return Checkout::guest()->create('price_tshirt', [
        'success_url' => route('your-success-route'),
        'cancel_url' => route('your-cancel-route'),
    ]);
});
```

Similarly to when creating checkout sessions for existing users, you may utilize additional methods available on the `Laravel\Cashier\CheckoutBuilder` instance to customize the guest checkout session:

```php
use Illuminate\Http\Request;
use Laravel\Cashier\Checkout;

Route::get('/product-checkout', function (Request $request) {
    return Checkout::guest()
        ->withPromotionCode('promo-code')
        ->create('price_tshirt', [
            'success_url' => route('your-success-route'),
            'cancel_url' => route('your-cancel-route'),
        ]);
});
```

After a guest checkout has been completed, Stripe can dispatch a `checkout.session.completed` webhook event, so make sure to [configure your Stripe webhook](https://dashboard.stripe.com/webhooks) to actually send this event to your application. Once the webhook has been enabled within the Stripe dashboard, you may [handle the webhook with Cashier](#handling-stripe-webhooks). The object contained in the webhook payload will be a [checkout object](https://stripe.com/docs/api/checkout/sessions/object) that you may inspect in order to fulfill your customer's order.

<a name="handling-failed-payments"></a>
## 處理失敗的付款 (Handling Failed Payments)

有時，訂閱或單次收費的付款可能會失敗。發生這種情況時，Cashier 會拋出 `Laravel\Cashier\Exceptions\IncompletePayment` 異常，通知你發生了這種情況。捕獲此異常後，你有兩個選擇如何繼續。

首先，你可以將客戶重新導向到 Cashier 包含的專用付款確認頁面。此頁面已有一個透過 Cashier 的服務提供者註冊的關聯命名路由。因此，你可以捕獲 `IncompletePayment` 異常並將使用者重新導向到付款確認頁面：

```php
use Laravel\Cashier\Exceptions\IncompletePayment;

try {
    $subscription = $user->newSubscription('default', 'price_monthly')
        ->create($paymentMethod);
} catch (IncompletePayment $exception) {
    return redirect()->route(
        'cashier.payment',
        [$exception->payment->id, 'redirect' => route('home')]
    );
}
```

On the payment confirmation page, the customer will be prompted to enter their credit card information again and perform any additional actions required by Stripe, such as "3D Secure" confirmation. After confirming their payment, the user will be redirected to the URL provided by the `redirect` parameter specified above. Upon redirection, `message` (string) and `success` (integer) query string variables will be added to the URL. The payment page currently supports the following payment method types:

<div className="content-list" markdown="1">

- Credit Cards
- Alipay
- Bancontact
- BECS Direct Debit
- EPS
- Giropay
- iDEAL
- SEPA Direct Debit

</div>

Alternatively, you could allow Stripe to handle the payment confirmation for you. In this case, instead of redirecting to the payment confirmation page, you may [setup Stripe's automatic billing emails](https://dashboard.stripe.com/account/billing/automatic) in your Stripe dashboard. However, if an `IncompletePayment` exception is caught, you should still inform the user they will receive an email with further payment confirmation instructions.

Payment exceptions may be thrown for the following methods: `charge`, `invoiceFor`, and `invoice` on models using the `Billable` trait. When interacting with subscriptions, the `create` method on the `SubscriptionBuilder`, and the `incrementAndInvoice` and `swapAndInvoice` methods on the `Subscription` and `SubscriptionItem` models may throw incomplete payment exceptions.

Determining if an existing subscription has an incomplete payment may be accomplished using the `hasIncompletePayment` method on the billable model or a subscription instance:

```php
if ($user->hasIncompletePayment('default')) {
    // ...
}

if ($user->subscription('default')->hasIncompletePayment()) {
    // ...
}
```

You can derive the specific status of an incomplete payment by inspecting the `payment` property on the exception instance:

```php
use Laravel\Cashier\Exceptions\IncompletePayment;

try {
    $user->charge(1000, 'pm_card_threeDSecure2Required');
} catch (IncompletePayment $exception) {
    // Get the payment intent status...
    $exception->payment->status;

    // Check specific conditions...
    if ($exception->payment->requiresPaymentMethod()) {
        // ...
    } elseif ($exception->payment->requiresConfirmation()) {
        // ...
    }
}
```

<a name="confirming-payments"></a>
### 確認付款 (Confirming Payments)

某些付款方式需要額外資料才能確認付款。例如，SEPA 付款方式在付款過程中需要額外的「授權」資料。你可以使用 `withPaymentConfirmationOptions` 方法將此資料提供給 Cashier：

```php
$subscription->withPaymentConfirmationOptions([
    'mandate_data' => '...',
])->swap('price_xxx');
```

You may consult the [Stripe API documentation](https://stripe.com/docs/api/payment_intents/confirm) to review all of the options accepted when confirming payments.

<a name="strong-customer-authentication"></a>
## 強大客戶驗證 (Strong Customer Authentication)

如果你的企業或你的客戶之一位於歐洲，你需要遵守歐盟的強大客戶驗證 (SCA) 法規。這些法規由歐盟於 2019 年 9 月實施，旨在防止支付詐欺。幸運的是，Stripe 和 Cashier 已準備好建立符合 SCA 的應用程式。

> [!WARNING]
> 在開始之前，請查看 [Stripe 關於 PSD2 和 SCA 的指南](https://stripe.com/guides/strong-customer-authentication) 以及他們 [關於新 SCA API 的文件](https://stripe.com/docs/strong-customer-authentication)。

<a name="payments-requiring-additional-confirmation"></a>
### 需要額外確認的付款 (Payments Requiring Additional Confirmation)

SCA 法規通常需要額外驗證才能確認和處理付款。發生這種情況時，Cashier 會拋出 `Laravel\Cashier\Exceptions\IncompletePayment` 異常，通知你需要額外驗證。有關如何處理這些異常的更多資訊，請參閱 [處理失敗的付款](#handling-failed-payments) 文件。

Payment confirmation screens presented by Stripe or Cashier may be tailored to a specific bank or card issuer's payment flow and can include additional card confirmation, a temporary small charge, separate device authentication, or other forms of verification.

<a name="incomplete-and-past-due-state"></a>
#### Incomplete and Past Due State

When a payment needs additional confirmation, the subscription will remain in an `incomplete` or `past_due` state as indicated by its `stripe_status` database column. Cashier will automatically activate the customer's subscription as soon as payment confirmation is complete and your application is notified by Stripe via webhook of its completion.

For more information on `incomplete` and `past_due` states, please refer to [our additional documentation on these states](#incomplete-and-past-due-status).

<a name="off-session-payment-notifications"></a>
### 非會話付款通知 (Off-Session Payment Notifications)

由於 SCA 法規要求客戶即使在訂閱有效的情況下也偶爾驗證其付款詳細資訊，因此當需要非會話付款確認時，Cashier 可以向客戶發送通知。例如，這可能發生在訂閱續訂時。可以透過將 `CASHIER_PAYMENT_NOTIFICATION` 環境變數設定為通知類別來啟用 Cashier 的付款通知。預設情況下，此通知已停用。當然，Cashier 包含一個你可以用於此目的的通知類別，但如果需要，你可以自由提供自己的通知類別：

```ini
CASHIER_PAYMENT_NOTIFICATION=Laravel\Cashier\Notifications\ConfirmPayment
```

To ensure that off-session payment confirmation notifications are delivered, verify that [Stripe webhooks are configured](#handling-stripe-webhooks) for your application and the `invoice.payment_action_required` webhook is enabled in your Stripe dashboard. In addition, your `Billable` model should also use Laravel's `Illuminate\Notifications\Notifiable` trait.

> [!WARNING]
> Notifications will be sent even when customers are manually making a payment that requires additional confirmation. Unfortunately, there is no way for Stripe to know that the payment was done manually or "off-session". But, a customer will simply see a "Payment Successful" message if they visit the payment page after already confirming their payment. The customer will not be allowed to accidentally confirm the same payment twice and incur an accidental second charge.

<a name="stripe-sdk"></a>
## Stripe SDK

許多 Cashier 的物件都是 Stripe SDK 物件的包裝器。如果你想直接與 Stripe 物件互動，可以使用 `asStripe` 方法方便地檢索它們：

```php
$stripeSubscription = $subscription->asStripeSubscription();

$stripeSubscription->application_fee_percent = 5;

$stripeSubscription->save();
```

You may also use the `updateStripeSubscription` method to update a Stripe subscription directly:

```php
$subscription->updateStripeSubscription(['application_fee_percent' => 5]);
```

You may invoke the `stripe` method on the `Cashier` class if you would like to use the `Stripe\StripeClient` client directly. For example, you could use this method to access the `StripeClient` instance and retrieve a list of prices from your Stripe account:

```php
use Laravel\Cashier\Cashier;

$prices = Cashier::stripe()->prices->all();
```

<a name="testing"></a>
## 測試 (Testing)

在測試使用 Cashier 的應用程式時，你可以模擬對 Stripe API 的實際 HTTP 請求；但是，這需要你部分重新實作 Cashier 自己的行為。因此，我們建議允許你的測試觸及實際的 Stripe API。雖然這比較慢，但它提供了更多的信心，確信你的應用程式按預期工作，並且任何緩慢的測試都可以放在它們自己的 Pest / PHPUnit 測試群組中。

When testing, remember that Cashier itself already has a great test suite, so you should only focus on testing the subscription and payment flow of your own application and not every underlying Cashier behavior.

To get started, add the **testing** version of your Stripe secret to your `phpunit.xml` file:

```xml
<env name="STRIPE_SECRET" value="sk_test_<your-key>"/>
```

Now, whenever you interact with Cashier while testing, it will send actual API requests to your Stripe testing environment. For convenience, you should pre-fill your Stripe testing account with subscriptions / prices that you may use during testing.

> [!NOTE]
> In order to test a variety of billing scenarios, such as credit card denials and failures, you may use the vast range of [testing card numbers and tokens](https://stripe.com/docs/testing) provided by Stripe.
