---
title: "Fortify "
description: Fortify 是 Laravel 的前端無關驗證後端實作
---

- [簡介](#introduction)
  - [什麼是 Fortify？](#what-is-fortify)
  - [何時該使用 Fortify？](#when-should-i-use-fortify)
- [安裝](#installation)
  - [Fortify 功能](#fortify-features)
  - [停用視圖](#disabling-views)
- [認證](#authentication)
  - [自訂使用者認證](#customizing-user-authentication)
  - [自訂認證 Pipeline](#customizing-the-authentication-pipeline)
  - [自訂重新導向](#customizing-authentication-redirects)
- [雙重認證](#two-factor-authentication)
  - [啟用雙重認證](#enabling-two-factor-authentication)
  - [使用雙重認證進行認證](#authenticating-with-two-factor-authentication)
  - [停用雙重認證](#disabling-two-factor-authentication)
- [註冊](#registration)
  - [自訂註冊](#customizing-registration)
- [重設密碼](#password-reset)
  - [請求重設密碼連結](#requesting-a-password-reset-link)
  - [重設密碼](#resetting-the-password)
  - [自訂重設密碼](#customizing-password-resets)
- [電子郵件驗證](#email-verification)
  - [保護路由](#protecting-routes)
- [密碼確認](#password-confirmation)

<a name="introduction"></a>
## 簡介 (Introduction)

[Laravel Fortify](https://github.com/laravel/fortify) 是 Laravel 的一個與前端無關的後端認證實作。Fortify 註冊了實作 Laravel 所有認證功能所需的路由和控制器，包括登入、註冊、重設密碼、電子郵件驗證等。安裝 Fortify 後，你可以執行 `route:list` Artisan 指令來查看 Fortify 註冊的路由。

由於 Fortify 不提供自己的使用者介面，因此它旨在與你自己建立的使用者介面搭配使用，該介面會向其註冊的路由發出請求。我們將在本文檔的其餘部分詳細討論如何向這些路由發出請求。

> [!NOTE]
> 請記住，Fortify 是一個旨在讓你快速開始實作 Laravel 認證功能的套件。**你並非必須使用它。** 你始終可以按照 [認證](/docs/authentication)、[重設密碼](/docs/passwords) 和 [電子郵件驗證](/docs/verification) 文件中的說明，手動與 Laravel 的認證服務互動。

<a name="what-is-fortify"></a>
### 什麼是 Fortify？ (What is Fortify?)

如前所述，Laravel Fortify 是 Laravel 的一個與前端無關的後端認證實作。Fortify 註冊了實作 Laravel 所有認證功能所需的路由和控制器，包括登入、註冊、重設密碼、電子郵件驗證等。

**你並非必須使用 Fortify 才能使用 Laravel 的認證功能。** 你始終可以按照 [認證](/docs/authentication)、[重設密碼](/docs/passwords) 和 [電子郵件驗證](/docs/verification) 文件中的說明，手動與 Laravel 的認證服務互動。

如果你是 Laravel 的新手，你可能希望探索 [我們的應用程式入門套件](/docs/starter-kits)。Laravel 的應用程式入門套件在內部使用 Fortify 來為你的應用程式提供認證鷹架，其中包括使用 [Tailwind CSS](https://tailwindcss.com) 建構的使用者介面。這讓你可以學習並熟悉 Laravel 的認證功能。

Laravel Fortify 本質上是將我們應用程式入門套件的路由和控制器提取出來，並將它們作為一個不包含使用者介面的套件提供。這讓你可以快速搭建應用程式認證層的後端實作，而無需受限於任何特定的前端觀點。

<a name="when-should-i-use-fortify"></a>
### 何時該使用 Fortify？ (When Should I Use Fortify?)

你可能想知道何時適合使用 Laravel Fortify。首先，如果你正在使用 Laravel 的 [應用程式入門套件](/docs/starter-kits) 之一，你不需要安裝 Laravel Fortify，因為所有 Laravel 的應用程式入門套件都已經使用了 Fortify 並提供了完整的認證實作。

如果你沒有使用應用程式入門套件，並且你的應用程式需要認證功能，你有兩個選擇：手動實作應用程式的認證功能，或者使用 Laravel Fortify 來提供這些功能的後端實作。

如果你選擇安裝 Fortify，你的使用者介面將向本文檔中詳細介紹的 Fortify 認證路由發出請求，以驗證和註冊使用者。

如果你選擇手動與 Laravel 的認證服務互動而不是使用 Fortify，你可以按照 [認證](/docs/authentication)、[重設密碼](/docs/passwords) 和 [電子郵件驗證](/docs/verification) 文件中的說明進行操作。

<a name="laravel-fortify-and-laravel-sanctum"></a>
#### Laravel Fortify 與 Laravel Sanctum (Laravel Fortify And Laravel Sanctum)

有些開發者會對 [Laravel Sanctum](/docs/sanctum) 和 Laravel Fortify 之間的區別感到困惑。因為這兩個套件解決了兩個不同但相關的問題，Laravel Fortify 和 Laravel Sanctum 並不是互斥或競爭的套件。

Laravel Sanctum 僅關注管理 API Token 以及使用 Session Cookie 或 Token 驗證現有使用者。Sanctum 不提供任何處理使用者註冊、重設密碼等的路由。

如果你試圖為提供 API 或作為單頁應用程式後端的應用程式手動建構認證層，完全有可能同時使用 Laravel Fortify（用於使用者註冊、重設密碼等）和 Laravel Sanctum（API Token 管理、Session 認證）。

<a name="installation"></a>
## 安裝 (Installation)

要開始使用，請使用 Composer 套件管理器安裝 Fortify：

```shell
composer require laravel/fortify
```

接下來，使用 `fortify:install` Artisan 指令發布 Fortify 的資源：

```shell
php artisan fortify:install
```

此指令會將 Fortify 的 Action 發布到你的 `app/Actions` 目錄，如果該目錄不存在，則會建立它。此外，還會發布 `FortifyServiceProvider`、設定檔和所有必要的資料庫遷移。

接下來，你應該遷移你的資料庫：

```shell
php artisan migrate
```

<a name="fortify-features"></a>
### Fortify 功能 (Fortify Features)

`fortify` 設定檔包含一個 `features` 設定陣列。此陣列定義了 Fortify 預設將公開哪些後端路由 / 功能。我們建議你只啟用以下功能，這些是大多數 Laravel 應用程式提供的基本認證功能：

```php
'features' => [
    Features::registration(),
    Features::resetPasswords(),
    Features::emailVerification(),
],
```

<a name="disabling-views"></a>
### 停用視圖 (Disabling Views)

預設情況下，Fortify 定義了旨在回傳視圖的路由，例如登入畫面或註冊畫面。但是，如果你正在建構 JavaScript 驅動的單頁應用程式，你可能不需要這些路由。因此，你可以透過將應用程式的 `config/fortify.php` 設定檔中的 `views` 設定值設為 `false` 來完全停用這些路由：

```php
'views' => false,
```

<a name="disabling-views-and-password-reset"></a>
#### 停用視圖和重設密碼 (Disabling Views And Password Reset)

如果你選擇停用 Fortify 的視圖，並且將為你的應用程式實作重設密碼功能，你仍然應該定義一個名為 `password.reset` 的路由，該路由負責顯示應用程式的「重設密碼」視圖。這是必要的，因為 Laravel 的 `Illuminate\Auth\Notifications\ResetPassword` 通知將透過 `password.reset` 命名路由產生重設密碼 URL。

<a name="authentication"></a>
## 認證 (Authentication)

要開始使用，我們需要指示 Fortify 如何回傳我們的「登入」視圖。請記住，Fortify 是一個無頭（Headless）認證函式庫。如果你想要一個已經為你完成的 Laravel 認證功能的前端實作，你應該使用 [應用程式入門套件](/docs/starter-kits)。

所有認證視圖的渲染邏輯都可以使用 `Laravel\Fortify\Fortify` 類別提供的適當方法進行自訂。通常，你應該從應用程式的 `App\Providers\FortifyServiceProvider` 類別的 `boot` 方法中呼叫此方法。Fortify 將負責定義回傳此視圖的 `/login` 路由：

```php
use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Fortify::loginView(function () {
        return view('auth.login');
    });

    // ...
}
```

你的登入模板應包含一個向 `/login` 發出 POST 請求的表單。`/login` 端點需要一個字串 `email` / `username` 和一個 `password`。電子郵件 / 使用者名稱欄位的名稱應與 `config/fortify.php` 設定檔中的 `username` 值相符。此外，還可以提供一個布林值 `remember` 欄位，以指示使用者希望使用 Laravel 提供的「記住我」功能。

如果登入嘗試成功，Fortify 會將你重新導向到應用程式 `fortify` 設定檔中 `home` 設定選項所設定的 URI。如果登入請求是 XHR 請求，則會回傳 200 HTTP 回應。

如果請求不成功，使用者將被重新導向回登入畫面，並且驗證錯誤將透過共用的 `$errors` [Blade 模板變數](/docs/validation#quick-displaying-the-validation-errors) 提供給你。或者，如果是 XHR 請求，驗證錯誤將隨 422 HTTP 回應一起回傳。

<a name="customizing-user-authentication"></a>
### 自訂使用者認證 (Customizing User Authentication)

Fortify 會根據提供的憑證和為你的應用程式設定的認證 Guard 自動檢索和驗證使用者。但是，你有時可能希望完全自訂如何驗證登入憑證和檢索使用者。幸運的是，Fortify 允許你使用 `Fortify::authenticateUsing` 方法輕鬆實現這一點。

此方法接受一個接收傳入 HTTP 請求的閉包。該閉包負責驗證附加到請求的登入憑證並回傳關聯的使用者實例。如果憑證無效或找不到使用者，閉包應回傳 `null` 或 `false`。通常，此方法應從你的 `FortifyServiceProvider` 的 `boot` 方法中呼叫：

```php
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Fortify::authenticateUsing(function (Request $request) {
        $user = User::where('email', $request->email)->first();

        if ($user &&
            Hash::check($request->password, $user->password)) {
            return $user;
        }
    });

    // ...
}
```

<a name="authentication-guard"></a>
#### 認證 Guard (Authentication Guard)

你可以在應用程式的 `fortify` 設定檔中自訂 Fortify 使用的認證 Guard。但是，你應該確保設定的 Guard 是 `Illuminate\Contracts\Auth\StatefulGuard` 的實作。如果你試圖使用 Laravel Fortify 來驗證 SPA，你應該結合使用 Laravel 預設的 `web` Guard 和 [Laravel Sanctum](https://laravel.com/docs/sanctum)。

<a name="customizing-the-authentication-pipeline"></a>
### 自訂認證 Pipeline (Customizing the Authentication Pipeline)

Laravel Fortify 透過一個可呼叫類別的 Pipeline 來驗證登入請求。如果需要，你可以定義一個自訂的類別 Pipeline，登入請求應通過該 Pipeline。每個類別都應該有一個 `__invoke` 方法，該方法接收傳入的 `Illuminate\Http\Request` 實例，並且像 [Middleware](/docs/middleware) 一樣，接收一個 `$next` 變數，該變數被呼叫以將請求傳遞給 Pipeline 中的下一個類別。

要定義你的自訂 Pipeline，你可以使用 `Fortify::authenticateThrough` 方法。此方法接受一個閉包，該閉包應回傳登入請求應通過的類別陣列。通常，此方法應從你的 `App\Providers\FortifyServiceProvider` 類別的 `boot` 方法中呼叫。

下面的範例包含預設的 Pipeline 定義，你在進行自己的修改時可以將其作為起點：

```php
use Laravel\Fortify\Actions\AttemptToAuthenticate;
use Laravel\Fortify\Actions\CanonicalizeUsername;
use Laravel\Fortify\Actions\EnsureLoginIsNotThrottled;
use Laravel\Fortify\Actions\PrepareAuthenticatedSession;
use Laravel\Fortify\Actions\RedirectIfTwoFactorAuthenticatable;
use Laravel\Fortify\Features;
use Laravel\Fortify\Fortify;
use Illuminate\Http\Request;

Fortify::authenticateThrough(function (Request $request) {
    return array_filter([
            config('fortify.limiters.login') ? null : EnsureLoginIsNotThrottled::class,
            config('fortify.lowercase_usernames') ? CanonicalizeUsername::class : null,
            Features::enabled(Features::twoFactorAuthentication()) ? RedirectIfTwoFactorAuthenticatable::class : null,
            AttemptToAuthenticate::class,
            PrepareAuthenticatedSession::class,
    ]);
});
```

#### 認證限流 (Authentication Throttling)

預設情況下，Fortify 會使用 `EnsureLoginIsNotThrottled` Middleware 來限制認證嘗試。此 Middleware 會限制對使用者名稱和 IP 位址組合唯一的嘗試。

某些應用程式可能需要不同的認證嘗試限流方法，例如僅透過 IP 位址進行限流。因此，Fortify 允許你透過 `fortify.limiters.login` 設定選項指定你自己的 [速率限制器](/docs/routing#rate-limiting)。當然，此設定選項位於你的應用程式的 `config/fortify.php` 設定檔中。

> [!NOTE]
> 混合使用限流、[雙重認證](/docs/fortify#two-factor-authentication) 和外部 Web 應用程式防火牆 (WAF) 將為你的合法應用程式使用者提供最強大的防禦。

<a name="customizing-authentication-redirects"></a>
### 自訂重新導向 (Customizing Redirects)

如果登入嘗試成功，Fortify 會將你重新導向到應用程式 `fortify` 設定檔中 `home` 設定選項所設定的 URI。如果登入請求是 XHR 請求，則會回傳 200 HTTP 回應。使用者登出應用程式後，將被重新導向到 `/` URI。

如果你需要對此行為進行進階自訂，你可以將 `LoginResponse` 和 `LogoutResponse` 契約的實作綁定到 Laravel [服務容器](/docs/container) 中。通常，這應該在你的應用程式的 `App\Providers\FortifyServiceProvider` 類別的 `register` 方法中完成：

```php
use Laravel\Fortify\Contracts\LogoutResponse;

/**
 * Register any application services.
 */
public function register(): void
{
    $this->app->instance(LogoutResponse::class, new class implements LogoutResponse {
        public function toResponse($request)
        {
            return redirect('/');
        }
    });
}
```

<a name="two-factor-authentication"></a>
## 雙重認證 (Two-Factor Authentication)

當 Fortify 的雙重認證功能啟用時，使用者在認證過程中需要輸入一個六位數的數字 Token。此 Token 是使用基於時間的一次性密碼 (TOTP) 產生的，可以從任何相容 TOTP 的行動認證應用程式（如 Google Authenticator）中檢索。

在開始之前，你應該先確保你的應用程式的 `App\Models\User` 模型使用了 `Laravel\Fortify\TwoFactorAuthenticatable` trait：

```php
<?php

namespace App\Models;

use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Fortify\TwoFactorAuthenticatable;

class User extends Authenticatable
{
    use Notifiable, TwoFactorAuthenticatable;
}
```

接下來，你應該在應用程式中建立一個畫面，讓使用者可以管理他們的雙重認證設定。此畫面應允許使用者啟用和停用雙重認證，以及重新產生他們的雙重認證復原碼。

> 預設情況下，`fortify` 設定檔的 `features` 陣列指示 Fortify 的雙重認證設定在修改前需要密碼確認。因此，在繼續之前，你的應用程式應實作 Fortify 的 [密碼確認](#password-confirmation) 功能。

<a name="enabling-two-factor-authentication"></a>
### 啟用雙重認證 (Enabling Two-Factor Authentication)

要開始啟用雙重認證，你的應用程式應向 Fortify 定義的 `/user/two-factor-authentication` 端點發出 POST 請求。如果請求成功，使用者將被重新導向回上一個 URL，並且 `status` Session 變數將被設定為 `two-factor-authentication-enabled`。你可以在模板中偵測此 `status` Session 變數以顯示適當的成功訊息。如果請求是 XHR 請求，則會回傳 `200` HTTP 回應。

選擇啟用雙重認證後，使用者仍必須透過提供有效的雙重認證碼來「確認」其雙重認證設定。因此，你的「成功」訊息應指示使用者仍需要確認雙重認證：

```html
@if (session('status') == 'two-factor-authentication-enabled')
<div className="mb-4 font-medium text-sm">請在下方完成雙重認證設定。</div>
@endif
```

接下來，你應該顯示雙重認證 QR Code 供使用者掃描到他們的認證應用程式中。如果你使用 Blade 渲染應用程式的前端，你可以使用使用者實例上可用的 `twoFactorQrCodeSvg` 方法檢索 QR Code SVG：

```php
$request->user()->twoFactorQrCodeSvg();
```

如果你正在建構 JavaScript 驅動的前端，你可以向 `/user/two-factor-qr-code` 端點發出 XHR GET 請求以檢索使用者的雙重認證 QR Code。此端點將回傳一個包含 `svg` 鍵的 JSON 物件。

<a name="confirming-two-factor-authentication"></a>
#### 確認雙重認證 (Confirming Two-Factor Authentication)

除了顯示使用者的雙重認證 QR Code 之外，你還應該提供一個文字輸入框，讓使用者可以提供有效的認證碼以「確認」其雙重認證設定。此代碼應透過 POST 請求提供給 Laravel 應用程式，請求發送至 Fortify 定義的 `/user/confirmed-two-factor-authentication` 端點。

如果請求成功，使用者將被重新導向回上一個 URL，並且 `status` Session 變數將被設定為 `two-factor-authentication-confirmed`：

```html
@if (session('status') == 'two-factor-authentication-confirmed')
<div className="mb-4 font-medium text-sm">雙重認證已成功確認並啟用。</div>
@endif
```

如果對雙重認證確認端點的請求是透過 XHR 請求發出的，則會回傳 `200` HTTP 回應。

<a name="displaying-the-recovery-codes"></a>
#### 顯示復原碼 (Displaying the Recovery Codes)

你還應該顯示使用者的雙重認證復原碼。這些復原碼允許使用者在無法存取行動裝置時進行認證。如果你使用 Blade 渲染應用程式的前端，你可以透過已認證的使用者實例存取復原碼：

```php
(array) $request->user()->recoveryCodes()
```

如果你正在建構 JavaScript 驅動的前端，你可以向 `/user/two-factor-recovery-codes` 端點發出 XHR GET 請求。此端點將回傳包含使用者復原碼的 JSON 陣列。

要重新產生使用者的復原碼，你的應用程式應向 `/user/two-factor-recovery-codes` 端點發出 POST 請求。

<a name="authenticating-with-two-factor-authentication"></a>
### 使用雙重認證進行認證 (Authenticating With Two-Factor Authentication)

在認證過程中，Fortify 會自動將使用者重新導向到應用程式的雙重認證挑戰畫面。但是，如果你的應用程式正在發出 XHR 登入請求，則成功認證嘗試後回傳的 JSON 回應將包含一個具有 `two_factor` 布林屬性的 JSON 物件。你應該檢查此值以了解是否應重新導向到應用程式的雙重認證挑戰畫面。

要開始實作雙重認證功能，我們需要指示 Fortify 如何回傳我們的雙重認證挑戰視圖。所有 Fortify 的認證視圖渲染邏輯都可以使用 `Laravel\Fortify\Fortify` 類別提供的適當方法進行自訂。通常，你應該從應用程式的 `App\Providers\FortifyServiceProvider` 類別的 `boot` 方法中呼叫此方法：

```php
use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Fortify::twoFactorChallengeView(function () {
        return view('auth.two-factor-challenge');
    });

    // ...
}
```

Fortify 將負責定義回傳此視圖的 `/two-factor-challenge` 路由。你的 `two-factor-challenge` 模板應包含一個向 `/two-factor-challenge` 端點發出 POST 請求的表單。`/two-factor-challenge` 動作需要一個包含有效 TOTP Token 的 `code` 欄位，或者一個包含使用者其中一個復原碼的 `recovery_code` 欄位。

如果登入嘗試成功，Fortify 會將使用者重新導向到應用程式 `fortify` 設定檔中 `home` 設定選項所設定的 URI。如果登入請求是 XHR 請求，則會回傳 204 HTTP 回應。

如果請求不成功，使用者將被重新導向回雙重認證挑戰畫面，並且驗證錯誤將透過共用的 `$errors` [Blade 模板變數](/docs/validation#quick-displaying-the-validation-errors) 提供給你。或者，如果是 XHR 請求，驗證錯誤將隨 422 HTTP 回應一起回傳。

<a name="disabling-two-factor-authentication"></a>
### 停用雙重認證 (Disabling Two-Factor Authentication)

要停用雙重認證，你的應用程式應向 `/user/two-factor-authentication` 端點發出 DELETE 請求。請記住，Fortify 的雙重認證端點在呼叫之前需要 [密碼確認](#password-confirmation)。

<a name="registration"></a>
## 註冊 (Registration)

要開始實作我們應用程式的註冊功能，我們需要指示 Fortify 如何回傳我們的「註冊」視圖。請記住，Fortify 是一個無頭（Headless）認證函式庫。如果你想要一個已經為你完成的 Laravel 認證功能的前端實作，你應該使用 [應用程式入門套件](/docs/starter-kits)。

所有 Fortify 的視圖渲染邏輯都可以使用 `Laravel\Fortify\Fortify` 類別提供的適當方法進行自訂。通常，你應該從你的 `App\Providers\FortifyServiceProvider` 類別的 `boot` 方法中呼叫此方法：

```php
use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Fortify::registerView(function () {
        return view('auth.register');
    });

    // ...
}
```

Fortify 將負責定義回傳此視圖的 `/register` 路由。你的 `register` 模板應包含一個向 Fortify 定義的 `/register` 端點發出 POST 請求的表單。

`/register` 端點需要字串 `name`、字串電子郵件地址 / 使用者名稱、`password` 和 `password_confirmation` 欄位。電子郵件 / 使用者名稱欄位的名稱應與應用程式 `fortify` 設定檔中定義的 `username` 設定值相符。

如果註冊嘗試成功，Fortify 會將使用者重新導向到應用程式 `fortify` 設定檔中 `home` 設定選項所設定的 URI。如果請求是 XHR 請求，則會回傳 201 HTTP 回應。

如果請求不成功，使用者將被重新導向回註冊畫面，並且驗證錯誤將透過共用的 `$errors` [Blade 模板變數](/docs/validation#quick-displaying-the-validation-errors) 提供給你。或者，如果是 XHR 請求，驗證錯誤將隨 422 HTTP 回應一起回傳。

<a name="customizing-registration"></a>
### 自訂註冊 (Customizing Registration)

可以透過修改安裝 Laravel Fortify 時產生的 `App\Actions\Fortify\CreateNewUser` Action 來自訂使用者驗證和建立過程。

<a name="password-reset"></a>
## 重設密碼 (Password Reset)

<a name="requesting-a-password-reset-link"></a>
### 請求重設密碼連結 (Requesting a Password Reset Link)

要開始實作我們應用程式的重設密碼功能，我們需要指示 Fortify 如何回傳我們的「忘記密碼」視圖。請記住，Fortify 是一個無頭（Headless）認證函式庫。如果你想要一個已經為你完成的 Laravel 認證功能的前端實作，你應該使用 [應用程式入門套件](/docs/starter-kits)。

所有 Fortify 的視圖渲染邏輯都可以使用 `Laravel\Fortify\Fortify` 類別提供的適當方法進行自訂。通常，你應該從應用程式的 `App\Providers\FortifyServiceProvider` 類別的 `boot` 方法中呼叫此方法：

```php
use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Fortify::requestPasswordResetLinkView(function () {
        return view('auth.forgot-password');
    });

    // ...
}
```

Fortify 將負責定義回傳此視圖的 `/forgot-password` 端點。你的 `forgot-password` 模板應包含一個向 `/forgot-password` 端點發出 POST 請求的表單。

`/forgot-password` 端點需要一個字串 `email` 欄位。此欄位 / 資料庫欄位的名稱應與應用程式 `fortify` 設定檔中的 `email` 設定值相符。

<a name="handling-the-password-reset-link-request-response"></a>
#### 處理重設密碼連結請求回應 (Handling The Password Reset Link Request Response)

如果重設密碼連結請求成功，Fortify 會將使用者重新導向回 `/forgot-password` 端點，並向使用者發送一封電子郵件，其中包含他們可以用來重設密碼的安全連結。如果請求是 XHR 請求，則會回傳 200 HTTP 回應。

在成功請求後被重新導向回 `/forgot-password` 端點後，可以使用 `status` Session 變數來顯示重設密碼連結請求嘗試的狀態。

`$status` Session 變數的值將與應用程式 `passwords` [語言檔](/docs/localization) 中定義的翻譯字串之一相符。如果你想自訂此值且尚未發布 Laravel 的語言檔，你可以透過 `lang:publish` Artisan 指令來完成：

```html
@if (session('status'))
<div className="mb-4 font-medium text-sm text-green-600">
  {{ session('status') }}
</div>
@endif
```

如果請求不成功，使用者將被重新導向回請求重設密碼連結畫面，並且驗證錯誤將透過共用的 `$errors` [Blade 模板變數](/docs/validation#quick-displaying-the-validation-errors) 提供給你。或者，如果是 XHR 請求，驗證錯誤將隨 422 HTTP 回應一起回傳。

<a name="resetting-the-password"></a>
### 重設密碼 (Resetting the Password)

要完成實作我們應用程式的重設密碼功能，我們需要指示 Fortify 如何回傳我們的「重設密碼」視圖。

所有 Fortify 的視圖渲染邏輯都可以使用 `Laravel\Fortify\Fortify` 類別提供的適當方法進行自訂。通常，你應該從應用程式的 `App\Providers\FortifyServiceProvider` 類別的 `boot` 方法中呼叫此方法：

```php
use Laravel\Fortify\Fortify;
use Illuminate\Http\Request;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Fortify::resetPasswordView(function (Request $request) {
        return view('auth.reset-password', ['request' => $request]);
    });

    // ...
}
```

Fortify 將負責定義顯示此視圖的路由。你的 `reset-password` 模板應包含一個向 `/reset-password` 發出 POST 請求的表單。

`/reset-password` 端點需要一個字串 `email` 欄位、一個 `password` 欄位、一個 `password_confirmation` 欄位，以及一個名為 `token` 的隱藏欄位，其中包含 `request()->route('token')` 的值。「email」欄位 / 資料庫欄位的名稱應與應用程式 `fortify` 設定檔中定義的 `email` 設定值相符。

<a name="handling-the-password-reset-response"></a>
#### 處理重設密碼回應 (Handling The Password Reset Response)

如果重設密碼請求成功，Fortify 會將重新導向回 `/login` 路由，以便使用者可以使用新密碼登入。此外，將設定一個 `status` Session 變數，以便你可以在登入畫面上顯示重設成功的狀態：

```blade
@if (session('status'))
    <div className="mb-4 font-medium text-sm text-green-600">
        {{ session('status') }}
    </div>
@endif
```

如果請求是 XHR 請求，則會回傳 200 HTTP 回應。

如果請求不成功，使用者將被重新導向回重設密碼畫面，並且驗證錯誤將透過共用的 `$errors` [Blade 模板變數](/docs/validation#quick-displaying-the-validation-errors) 提供給你。或者，如果是 XHR 請求，驗證錯誤將隨 422 HTTP 回應一起回傳。

<a name="customizing-password-resets"></a>
### 自訂重設密碼 (Customizing Password Resets)

可以透過修改安裝 Laravel Fortify 時產生的 `App\Actions\ResetUserPassword` Action 來自訂重設密碼過程。

<a name="email-verification"></a>
## 電子郵件驗證 (Email Verification)

註冊後，你可能希望使用者在繼續存取你的應用程式之前驗證他們的電子郵件地址。要開始使用，請確保在 `fortify` 設定檔的 `features` 陣列中啟用了 `emailVerification` 功能。接下來，你應該確保你的 `App\Models\User` 類別實作了 `Illuminate\Contracts\Auth\MustVerifyEmail` 介面。

完成這兩個設定步驟後，新註冊的使用者將收到一封電子郵件，提示他們驗證其電子郵件地址的所有權。但是，我們需要通知 Fortify 如何顯示電子郵件驗證畫面，該畫面通知使用者他們需要點擊電子郵件中的驗證連結。

所有 Fortify 的視圖渲染邏輯都可以使用 `Laravel\Fortify\Fortify` 類別提供的適當方法進行自訂。通常，你應該從應用程式的 `App\Providers\FortifyServiceProvider` 類別的 `boot` 方法中呼叫此方法：

```php
use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Fortify::verifyEmailView(function () {
        return view('auth.verify-email');
    });

    // ...
}
```

當使用者被 Laravel 內建的 `verified` Middleware 重新導向到 `/email/verify` 端點時，Fortify 將負責定義顯示此視圖的路由。

你的 `verify-email` 模板應包含一條訊息，指示使用者點擊發送到其電子郵件地址的電子郵件驗證連結。

<a name="resending-email-verification-links"></a>
#### 重新發送電子郵件驗證連結 (Resending Email Verification Links)

如果願意，你可以在應用程式的 `verify-email` 模板中新增一個按鈕，該按鈕會觸發對 `/email/verification-notification` 端點的 POST 請求。當此端點收到請求時，新的驗證電子郵件連結將透過電子郵件發送給使用者，如果前一個連結被意外刪除或遺失，使用者可以獲取新的驗證連結。

如果重新發送驗證連結電子郵件的請求成功，Fortify 會將使用者重新導向回 `/email/verify` 端點，並帶有 `status` Session 變數，讓你可以向使用者顯示一條訊息，通知他們操作成功。如果請求是 XHR 請求，則會回傳 202 HTTP 回應：

```blade
@if (session('status') == 'verification-link-sent')
    <div className="mb-4 font-medium text-sm text-green-600">
        新的電子郵件驗證連結已發送給你！
    </div>
@endif
```

<a name="protecting-routes"></a>
### 保護路由 (Protecting Routes)

要指定路由或路由群組要求使用者已驗證其電子郵件地址，你應該將 Laravel 內建的 `verified` Middleware 附加到路由。`verified` Middleware 別名由 Laravel 自動註冊，並作為 `Illuminate\Auth\Middleware\EnsureEmailIsVerified` Middleware 的別名：

```php
Route::get('/dashboard', function () {
    // ...
})->middleware(['verified']);
```

<a name="password-confirmation"></a>
## 密碼確認 (Password Confirmation)

在建構應用程式時，你可能偶爾會有需要在執行操作之前要求使用者確認密碼的操作。通常，這些路由受 Laravel 內建的 `password.confirm` Middleware 保護。

要開始實作密碼確認功能，我們需要指示 Fortify 如何回傳我們應用程式的「密碼確認」視圖。請記住，Fortify 是一個無頭（Headless）認證函式庫。如果你想要一個已經為你完成的 Laravel 認證功能的前端實作，你應該使用 [應用程式入門套件](/docs/starter-kits)。

所有 Fortify 的視圖渲染邏輯都可以使用 `Laravel\Fortify\Fortify` 類別提供的適當方法進行自訂。通常，你應該從應用程式的 `App\Providers\FortifyServiceProvider` 類別的 `boot` 方法中呼叫此方法：

```php
use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Fortify::confirmPasswordView(function () {
        return view('auth.confirm-password');
    });

    // ...
}
```

Fortify 將負責定義回傳此視圖的 `/user/confirm-password` 端點。你的 `confirm-password` 模板應包含一個向 `/user/confirm-password` 端點發出 POST 請求的表單。`/user/confirm-password` 端點需要一個包含使用者目前密碼的 `password` 欄位。

如果密碼與使用者的目前密碼相符，Fortify 會將使用者重新導向到他們試圖存取的路由。如果請求是 XHR 請求，則會回傳 201 HTTP 回應。

如果請求不成功，使用者將被重新導向回確認密碼畫面，並且驗證錯誤將透過共用的 `$errors` Blade 模板變數提供給你。或者，如果是 XHR 請求，驗證錯誤將隨 422 HTTP 回應一起回傳。
