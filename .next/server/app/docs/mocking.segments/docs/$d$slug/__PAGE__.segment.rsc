1:"$Sreact.fragment"
1b:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
1c:"$Sreact.suspense"
0:{"buildId":"kjEMIxu9odGG-VQSDbSTB","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"container mx-auto py-10","children":["$","div",null,{"className":"mx-auto max-w-3xl","children":[["$","div",null,{"className":"mb-8","children":[["$","h1",null,{"className":"scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl"}],"$undefined"]}],["$","article",null,{"className":"prose prose-slate dark:prose-invert max-w-none","children":[["$","h1",null,{"id":"mocking","children":["$","a",null,{"href":"#mocking","children":"Mocking"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["$","a",null,{"href":"#introduction","children":"介紹"}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"#mocking-objects","children":"Mocking 物件"}]}],"\n",["$","li",null,{"children":[["$","a",null,{"href":"#mocking-facades","children":"Mocking Facades"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["$","a",null,{"href":"#facade-spies","children":"Facade Spies"}]}],"\n"]}],"\n"]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"#interacting-with-time","children":"與時間互動"}]}],"\n"]}],"\n",["$","a",null,{"name":"introduction"}],"\n",["$","h2",null,{"id":"介紹","children":["$","a",null,{"href":"#介紹","children":"介紹"}]}],"\n",["$","p",null,{"children":"在測試 Laravel 應用程式時，你可能希望「模擬」應用程式的某些部分，以便它們在特定測試期間不會真正被執行。例如，在測試一個會派發事件的控制器時，你可能希望模擬事件監聽器，這樣它們在測試期間就不會真正被執行。這讓你可以只測試控制器的 HTTP 回應，而不用擔心事件監聽器的執行，因為事件監聽器可以在它們自己的測試案例中進行測試。"}],"\n",["$","p",null,{"children":"Laravel 提供了開箱即用的實用方法來模擬事件、任務和其他 facades。這些輔助方法主要提供了一個 Mockery 的便利層，因此你不必手動進行複雜的 Mockery 方法調用。"}],"\n",["$","a",null,{"name":"mocking-objects"}],"\n",["$","h2",null,{"id":"mocking-物件","children":["$","a",null,{"href":"#mocking-物件","children":"Mocking 物件"}]}],"\n",["$","p",null,{"children":["當模擬一個將透過 Laravel ",["$","a",null,{"href":"/docs/%7B%7Bversion%7D%7D/container","children":"service container"}]," 注入到你的應用程式的物件時，你需要將你模擬的實例作為 ",["$","code",null,{"children":"instance"}]," 綁定到容器中。這會指示容器使用你模擬的物件實例，而不是自己建構該物件："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"use App\\Service;\nuse Mockery;\nuse Mockery\\MockInterface;\n\ntest('something can be mocked', function () {\n    $this->instance(\n        Service::class,\n        Mockery::mock(Service::class, function (MockInterface $mock) {\n            $mock->expects('process');\n        })\n    );\n});\n"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"use App\\Service;\nuse Mockery;\nuse Mockery\\MockInterface;\n\npublic function test_something_can_be_mocked(): void\n{\n    $this->instance(\n        Service::class,\n        Mockery::mock(Service::class, function (MockInterface $mock) {\n            $mock->expects('process');\n        })\n    );\n}\n"}]}],"\n",["$","p",null,{"children":["為了讓這更加方便，你可以使用 Laravel 基礎測試案例類別提供的 ",["$","code",null,{"children":"mock"}]," 方法。例如，以下範例與上面的範例是等效的："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"use App\\Service;\nuse Mockery\\MockInterface;\n\n$mock = $this->mock(Service::class, function (MockInterface $mock) {\n    $mock->expects('process');\n});\n"}]}],"\n",["$","p",null,{"children":["當你只需要模擬物件的幾個方法時，你可以使用 ",["$","code",null,{"children":"partialMock"}]," 方法。未被模擬的方法在被呼叫時會正常執行："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"use App\\Service;\nuse Mockery\\MockInterface;\n\n$mock = $this->partialMock(Service::class, function (MockInterface $mock) {\n    $mock->expects('process');\n});\n"}]}],"\n",["$","p",null,{"children":["同樣地，如果你想要",["$","a",null,{"href":"http://docs.mockery.io/en/latest/reference/spies.html","children":"監視"}],"一個物件，Laravel 的基礎測試案例類別提供了一個 ",["$","code",null,{"children":"spy"}]," 方法作為 ",["$","code",null,{"children":"Mockery::spy"}]," 方法的便利包裝器。Spies 類似於 mocks；然而，spies 會記錄 spy 與被測試程式碼之間的任何互動，讓你可以在程式碼執行後進行斷言："]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"use App\\Service;\n\n$spy = $this->spy(Service::class);\n\n// ...\n\n$spy->shouldHaveReceived('process');\n"}]}],"\n",["$","a",null,{"name":"mocking-facades"}],"\n",["$","h2",null,{"id":"mocking-facades","children":["$","a",null,{"href":"#mocking-facades","children":"Mocking Facades"}]}],"\n",["$","p",null,{"children":["與傳統的靜態方法調用不同，","$L2","（包括","$L3","）可以被模擬。這提供了相對於傳統靜態方法的巨大優勢，並賦予你與使用傳統依賴注入相同的可測試性。在測試時，你可能經常想要模擬在你的控制器中發生的 Laravel facade 調用。例如，考慮以下控制器動作："]}],"\n","$L4","\n","$L5","\n","$L6","\n","$L7","\n","$L8","\n","$L9","\n","$La","\n","$Lb","\n","$Lc","\n","$Ld","\n","$Le","\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13","\n","$L14","\n","$L15","\n","$L16","\n","$L17","\n","$L18","\n","$L19"]}]]}]}],null,"$L1a"]}],"loading":null,"isPartial":false}
2:["$","a",null,{"href":"/docs/%7B%7Bversion%7D%7D/facades","children":"facades"}]
3:["$","a",null,{"href":"/docs/%7B%7Bversion%7D%7D/facades#real-time-facades","children":"即時 facades"}]
4:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Support\\Facades\\Cache;\n\nclass UserController extends Controller\n{\n    /**\n     * Retrieve a list of all users of the application.\n     */\n    public function index(): array\n    {\n        $value = Cache::get('key');\n\n        return [\n            // ...\n        ];\n    }\n}\n"}]}]
5:["$","p",null,{"children":["我們可以使用 ",["$","code",null,{"children":"expects"}]," 方法來模擬對 ",["$","code",null,{"children":"Cache"}]," facade 的調用，這會回傳一個 ",["$","a",null,{"href":"https://github.com/padraic/mockery","children":"Mockery"}]," mock 的實例。由於 facades 實際上是由 Laravel ",["$","a",null,{"href":"/docs/%7B%7Bversion%7D%7D/container","children":"service container"}]," 解析和管理的，它們比典型的靜態類別具有更高的可測試性。例如，讓我們模擬對 ",["$","code",null,{"children":"Cache"}]," facade 的 ",["$","code",null,{"children":"get"}]," 方法的調用："]}]
6:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"<?php\n\nuse Illuminate\\Support\\Facades\\Cache;\n\ntest('get index', function () {\n    Cache::expects('get')\n        ->with('key')\n        ->andReturn('value');\n\n    $response = $this->get('/users');\n\n    // ...\n});\n"}]}]
7:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"<?php\n\nnamespace Tests\\Feature;\n\nuse Illuminate\\Support\\Facades\\Cache;\nuse Tests\\TestCase;\n\nclass UserControllerTest extends TestCase\n{\n    public function test_get_index(): void\n    {\n        Cache::expects('get')\n            ->with('key')\n            ->andReturn('value');\n\n        $response = $this->get('/users');\n\n        // ...\n    }\n}\n"}]}]
8:["$","blockquote",null,{"children":["\n",["$","p",null,{"children":["[!WARNING]\n你不應該模擬 ",["$","code",null,{"children":"Request"}]," facade。相反地，在執行測試時，將你想要的輸入傳遞給 ",["$","a",null,{"href":"/docs/%7B%7Bversion%7D%7D/http-tests","children":"HTTP 測試方法"}],"，如 ",["$","code",null,{"children":"get"}]," 和 ",["$","code",null,{"children":"post"}],"。同樣地，與其模擬 ",["$","code",null,{"children":"Config"}]," facade，不如在測試中調用 ",["$","code",null,{"children":"Config::set"}]," 方法。"]}],"\n"]}]
9:["$","a",null,{"name":"facade-spies"}]
a:["$","h3",null,{"id":"facade-spies","children":["$","a",null,{"href":"#facade-spies","children":"Facade Spies"}]}]
b:["$","p",null,{"children":["如果你想要",["$","a",null,{"href":"http://docs.mockery.io/en/latest/reference/spies.html","children":"監視"}],"一個 facade，你可以在對應的 facade 上調用 ",["$","code",null,{"children":"spy"}]," 方法。Spies 類似於 mocks；然而，spies 會記錄 spy 與被測試程式碼之間的任何互動，讓你可以在程式碼執行後進行斷言："]}]
c:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"<?php\n\nuse Illuminate\\Support\\Facades\\Cache;\n\ntest('values are stored in cache', function () {\n    Cache::spy();\n\n    $response = $this->get('/');\n\n    $response->assertStatus(200);\n\n    Cache::shouldHaveReceived('put')->with('name', 'Taylor', 10);\n});\n"}]}]
d:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"use Illuminate\\Support\\Facades\\Cache;\n\npublic function test_values_are_stored_in_cache(): void\n{\n    Cache::spy();\n\n    $response = $this->get('/');\n\n    $response->assertStatus(200);\n\n    Cache::shouldHaveReceived('put')->with('name', 'Taylor', 10);\n}\n"}]}]
e:["$","a",null,{"name":"interacting-with-time"}]
f:["$","h2",null,{"id":"與時間互動","children":["$","a",null,{"href":"#與時間互動","children":"與時間互動"}]}]
10:["$","p",null,{"children":["在測試時，你可能偶爾需要修改像 ",["$","code",null,{"children":"now"}]," 或 ",["$","code",null,{"children":"Illuminate\\Support\\Carbon::now()"}]," 這類輔助函式回傳的時間。幸運的是，Laravel 的基礎功能測試類別包含了讓你能夠操作當前時間的輔助方法："]}]
11:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"test('time can be manipulated', function () {\n    // Travel into the future...\n    $this->travel(5)->milliseconds();\n    $this->travel(5)->seconds();\n    $this->travel(5)->minutes();\n    $this->travel(5)->hours();\n    $this->travel(5)->days();\n    $this->travel(5)->weeks();\n    $this->travel(5)->years();\n\n    // Travel into the past...\n    $this->travel(-5)->hours();\n\n    // Travel to an explicit time...\n    $this->travelTo(now()->subHours(6));\n\n    // Return back to the present time...\n    $this->travelBack();\n});\n"}]}]
12:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"public function test_time_can_be_manipulated(): void\n{\n    // Travel into the future...\n    $this->travel(5)->milliseconds();\n    $this->travel(5)->seconds();\n    $this->travel(5)->minutes();\n    $this->travel(5)->hours();\n    $this->travel(5)->days();\n    $this->travel(5)->weeks();\n    $this->travel(5)->years();\n\n    // Travel into the past...\n    $this->travel(-5)->hours();\n\n    // Travel to an explicit time...\n    $this->travelTo(now()->subHours(6));\n\n    // Return back to the present time...\n    $this->travelBack();\n}\n"}]}]
13:["$","p",null,{"children":"你也可以提供一個閉包給各種時間穿梭方法。閉包將在時間凍結於指定時間時被調用。一旦閉包執行完成，時間將恢復正常："}]
14:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"$$this->travel(5)->days(function () {\n    // Test something five days into the future...\n});\n\n$this->travelTo(now()->subDays(10), function () {\n    // Test something during a given moment...\n});\n"}]}]
15:["$","p",null,{"children":[["$","code",null,{"children":"freezeTime"}]," 方法可用於凍結當前時間。同樣地，",["$","code",null,{"children":"freezeSecond"}]," 方法會凍結當前時間，但是是在當前秒的開始："]}]
16:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"use Illuminate\\Support\\Carbon;\n\n// Freeze time and resume normal time after executing closure...\n$this->freezeTime(function (Carbon $time) {\n    // ...\n});\n\n// Freeze time at the current second and resume normal time after executing closure...\n$this->freezeSecond(function (Carbon $time) {\n    // ...\n})\n"}]}]
17:["$","p",null,{"children":"如你所料，上面討論的所有方法主要用於測試對時間敏感的應用程式行為，例如鎖定討論論壇上的非活躍貼文："}]
18:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"use App\\Models\\Thread;\n\ntest('forum threads lock after one week of inactivity', function () {\n    $thread = Thread::factory()->create();\n\n    $this->travel(1)->week();\n\n    expect($thread->isLockedByInactivity())->toBeTrue();\n});\n"}]}]
19:["$","pre",null,{"children":["$","code",null,{"className":"language-php","children":"use App\\Models\\Thread;\n\npublic function test_forum_threads_lock_after_one_week_of_inactivity()\n{\n    $thread = Thread::factory()->create();\n\n    $this->travel(1)->week();\n\n    $this->assertTrue($thread->isLockedByInactivity());\n}\n"}]}]
1a:["$","$L1b",null,{"children":["$","$1c",null,{"name":"Next.MetadataOutlet","children":"$@1d"}]}]
1d:null
